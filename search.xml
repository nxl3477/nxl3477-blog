<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【工程化】webpack4 时代如何更好的配置 dll]]></title>
    <url>%2F2019%2F11%2F19%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack4-%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%85%8D%E7%BD%AE-dll%2F</url>
    <content type="text"><![CDATA[因为公司的pc 项目有点庞大， 每次打包构建都得1分钟左右， 实在有点无法接受， 于是尝试优化一下 webpack 看看能否提升提升相关的性能也就有了这篇文章的由来，也是想记录一下关于webpack优化的内容 如果你去搜索 webpack 优化一定会搜索到dll相关的配置，同样也会被一串莫名其妙的webpack 搞的一头雾水， 那么我们就来简单理解一下 什么是dll呢dll原本是window系统的一种优化手段 利用动态链接，大体上的操作是: 许多应用共享的代码能够切分到一个DLL中，在硬盘上存为一个文档，在内存中只需使用一个实例。 用于节省应用程序的资源和状态， 总的来说是一种用空间换时间的方案 再人话一点就是： 把程序可复用的公共代码抽出来，作为外部依赖引用 那么 Dll 在前端中的作用就是将需要打包的第三方依赖从项目中抽离出来， 单独打包一份 vender 文件， 我们的配置也就是在干这么一件事: 第一次打包： 将依赖单独打包抽离， 存储在磁盘中并生成映射关系， 方便后续查找，也就是 manifest.json 文件 第二次打包： 根据 manifest.json 获取之前的依赖打包缓存， 只需要打包业务相关的代码 简单介绍应该如何配置 dll首先编写一个专门用来打包和更新 dll 的 webpack 配置, 保存到项目根目录中 webpack.dll.config.js1234567891011121314151617181920212223242526272829'use strict';const path = require('path');const webpack = require('webpack');module.exports = &#123; mode: 'production', entry: &#123; react: ['react', 'react-dom'], &#125;, output: &#123; path: path.resolve(__dirname, '../dll'), filename: '[name].dll.js', library: '[name]_library', &#125;, plugins: [ new webpack.DllPlugin(&#123; name: '[name]_library', context: __dirname, path: path.resolve(__dirname, '../dll/[name]-manifest.json'), &#125;) ]&#125;;``` 编写好脚本必然需要有一个方法去触发他， 我们到 package.json 中编写一个 script : ```json"script": &#123; "dll": "webpack --config=webpack.dll.config.js"&#125; 此时我们运行npm run dll便可生成一份打包的 dll文件 那如何建立起动态链接呢? 上面的打包操作会产出一份 manifest.json 映射关系文件，它就像一个“地图”绘制着各个被打包到dll的依赖的相关信息， 那我们只要把这份映射关系文件告诉webpck ， 让他按照这个份“地图” 去寻址 所以我们要在正常的打包配置中加入这样一个 plugins, 然后利用 add-asset-html-webpack-plugin 将静态资源的路径插入到html中 123456789plugins: [ new webpack.DllReferencePlugin(&#123; context: path.resolve(__dirname, '../'), manifest: path.resolve(__dirname, '../dll/react.manifest.json'), &#125;), new AddAssetHtmlPlugin(&#123; filepath: path.resolve(__dirname, '../dll/_dll_react.js'), &#125;)] dll 优劣dll的缓存机制带来的打包效果是非常显著的， 能大幅减少项目的打包时间， 上面也说了dll 是一种拿空间换时间的一种方式， 可以先将项目所依赖的库提前打包出来， 存储在本地磁盘中， 然后通过mainifest.json 的映射文件， 在下次打包的时候产生链接关系， 这样就可以做到， 你把这份提前打包的dll包放置在 cdn上？ 因为他不会经常性的修改， 只需要在项目的第三方依赖需要修改的时候再去替换他即可， 然后每次打包都可以跳过打包第三方依赖，只处理业务代码， 但其实这样也有一个问题， 那就是整个 spa 应用就会很蠢， 本来是可以利用 code split 来达到按需加载js 文件的功能， 但是这样一整吧， 不管用户访问哪个页面都会把整个作为 dll 的依赖包下载下来， 变相的增加了加载时间， 所以dll也只是推荐在开发环境使用， 生产环境还是使用 commonChunk 的方式提取公共依赖把， 虽然 commonChunk无法为你优化打包时间 webpack4 中我们应该怎么做同样的配置我尝试在使用了 webpack4的新项目中试了试， 发现 dll 加速太不明显了， 测试了几次感觉只优化了100毫秒， 因为webpack4 的性能足够好 （ 项目原本打包需要1.8秒上下 ）， 所以这也是 vue-cli 将 dll 这种方式弃用的原因 123dll option will be removed. Webpack 4 should provide good enough perf and the cost of maintaining DLL mode inside Vue CLI is no longer justified.dll 配置将会被移除，因为 Webpack 4 的打包性能足够好的，dll 没有在 Vue ClI 里继续维护的必要了。 那我们真的只能跟 dll 分手告别了吗? 不会的，工具只会越发展越完善， 在webpack4的时代，我们可以使用 hard-source-webpack-plugin ，只需要在webpack的plugins 中加入123plugins: [ new HardSourceWebpackPlugin()] 就这仅仅一行即可， 效果拔群 就是他了， 上了这车直接提升了3分之一的速度， 太秀了吧， 硬核 并且听说等到了 webpack5 自身就会集成了 参考文献 https://segmentfault.com/a/1190000020485804]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】记一次支付功能的开发]]></title>
    <url>%2F2019%2F09%2F30%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[今天国庆赶车回家 ，陪女朋友赶车（女朋友的票要早两个小时）， 无聊本想着看会剧， 但是车展坑爹啊， 网络太卡了， 想下载个腾讯视频都下载不了， 既然没网看不了剧， 发呆太可惜了， 想着最近很久没补博客了， 趁这个事件补一点好了， 这星期做的这个支付的几个关键点记录一下。 提到支付当然微信和支付宝都得做， 还有公司内部的支付方式， 当然公司内部的支付就不提了， 这个每个公司的情况都不一样， 这里关键记录一下微信和支付宝的 微信中打开支付在微信自身中打开我们的支付页面， 此时我们的网页可以被赋能可以获得jsBridge ， 这是微信暴露给webview的方法， 类似于Cordova 之类的 web容器式混合应用, 通过jsBridge 唤起微信原生的支付 获取微信code在微信原生中支付，需要获取一串code, 类似于登录操作， 需要把code交给后台， 后台去问微信索要openID , 用来支付 那么如果获取到这串code：我们需要在路径上判断一下query， 如果没有query 那就跳转到获取code的地址， 并携带上当前的地址，因为跳转到该地址后会携带着code 跳转回来， 跳转去获取code：1234567891011121314// 获取路径上携带的codedata() &#123; return &#123; code: this.$route.query.code ? this.$route.query.code : '', &#125;&#125;// 检测微信环境if (verify('wechat')) &#123; // 如果code 不存在就跳去获取 if (!this.code) &#123; window.location.href = "https://open.weixin.qq.com/connect/oauth2/authorize?appid=" + wechatAppId + "&amp;redirect_uri=" + encodeURIComponent(window.location.href) + "&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect" &#125;&#125; 同时这里还有需要注意的地方，微信获取的code只能使用一次支付， 也就是说， 当用户唤起一次支付以后， 但并没有真的支付， 而是取消支付了， 那他下次就无法再唤起支付， 因为code使用过了， 后台的订单会创建失败， 解决方法就是在获取一次code！ 如何再获取一次code呢？ 刷新页面呗 这里我用了比较偷懒的办法， 我们不是判断 this.code 是否存在才去获取code吗， 那我们把旧的code干掉就可以了 12345678910111213141516171819202122232425262728293031getCodeAgain() &#123; let _url = window.location.href // soot 是废弃的意思，， 随便起的名字， 可以随意换， _url = _url.replace('code', 'soot') window.location.href = _url&#125;,``` 如此替换之后访问页面时就获取不到code， 自然会再去跳转获取新code , 嘿嘿， 这是比较偷懒的方法， 最好还是去正则匹配一下路径参数， 然后把code相关内容删掉， 避免url过长***关键的调用js 支付方法, 有比较坑爹的是， 使用 `res.err_msg` 来判断用户是否支付成功, 微信居然无法保证其可靠性！顺便一提， params 参数是后台给的（我们公司的情况）， 这种支付相关的还是交给后台保存吧```jsWeixinJSBridge.invoke('getBrandWCPayRequest', params, function (res) &#123; if (res.err_msg == "get_brand_wcpay_request:ok") &#123; // 支付成功 // 微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 success &amp;&amp; success('ok'); &#125; else if (res.err_msg == "get_brand_wcpay_request:cancel") &#123; // 支付取消 cancel &amp;&amp; cancel('cancel'); &#125; else &#123; // 支付失败或错误 fail &amp;&amp; fail('fail'); &#125;&#125;); 进行封装后的代码， 个人觉得还是封装的挺烂的， 但姑且可以用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 微信支付/** * @msg 设置微信js 桥的 支付相关配置 * @param &#123;type&#125; * @param &#123; function &#125; success 成功回调 * @param &#123; function &#125; cancel 用户去取消回调 * @param &#123; function &#125; fail 支付失败或错误回调 * @param &#123; function &#125; localError 本地出现错误回调 - 会在 wxPay 方法中被拦截 * @param &#123; function &#125; params 支付的相关配置 - 由后台返回 * @return: */function setWxBridgeConfig(&#123; success, cancel, fail, ...params &#125;) &#123; WeixinJSBridge.invoke('getBrandWCPayRequest', params, function (res) &#123; if (res.err_msg == "get_brand_wcpay_request:ok") &#123; // 支付成功 // 微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 success &amp;&amp; success('ok'); &#125; else if (res.err_msg == "get_brand_wcpay_request:cancel") &#123; // 支付取消 cancel &amp;&amp; cancel('cancel'); &#125; else &#123; // 支付失败或错误 fail &amp;&amp; fail('fail'); &#125; &#125;);&#125;/** * @msg 尝试调起微信支付 * @param &#123;type&#125; * @param &#123; function &#125; success 成功回调 * @param &#123; function &#125; cancel 用户去取消回调 * @param &#123; function &#125; fail 支付失败或错误回调 * @param &#123; function &#125; localError 本地出现错误回调 - 会在 wxPay 方法中被拦截 * @param &#123; function &#125; params 支付的相关配置 - 由后台返回 * @return: */export default function wxPay(&#123; localError, ...params &#125;) &#123; try &#123; let JSBridgeInterval = null; // 如果 WeixinJSBridge 对象存在则进入配置 if (!(typeof WeixinJSBridge == "undefined")) &#123; setWxBridgeConfig(params); &#125; else &#123; // 等待sdk 加载完成， 如果sdk未加载完成就调用支付时 WeixinJSBridge 对象 不存在 JSBridgeInterval = setInterval(() =&gt; &#123; if (!(typeof WeixinJSBridge == "undefined")) &#123; clearInterval(JSBridgeInterval); setWxBridgeConfig(params); &#125; &#125;, 100); &#125; &#125; catch (error) &#123; localError &amp;&amp; localError() &#125;&#125; 浏览器中打开微信支付浏览器中唤醒微信支付, 这就比较简单了， 当我们创建订单后只需要将网页跳转至后台返回的微信页面 12// res 指得是后台接口的返回， mweb_url这也是我们公司的字段， 和微信没有关系，只是demowindow.location.href = res.data.mweb_url 支付宝支付（浏览器中）同样的， 支付宝也有jsBridge 这种方式， 但我们没有选择， 因为我们的主要面向是微信用户， 支付宝我们选择一种比较通用的方式就可以， 也就是浏览器中的支付方式 这种方式需要在创建订单后后台返回一个html 字符串， 这是一段form表单， 我们接收到这串字符串以后，使用下面这段打开唤醒支付宝， alipayHtml就是后台返回的表单字符串 12345let div = document.createElement('div');// alipayHtml 是后台返回的字符串div.innerHTML = alipayHtml;document.body.appendChild(div);document.forms[0].submit(); 如此就可以调用支付宝支付了]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】什么叫中台]]></title>
    <url>%2F2019%2F09%2F24%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E5%8F%AB%E4%B8%AD%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[今天看到了一对很有趣的漫画， 讲述了什么叫中台的问题， 之前自己一直对中台这个概念很模糊， 找不清楚这个定位。 看完了漫画特地过来记录一下。做下笔记 没有中台的时代在没有中台的时代， 不管项目大小， 都可以分为 “前台“和”后台” 什么是前台？ 首先，这里所说的“前台”和“前端”并不是一回事。所谓前台即包括各种和用户直接交互的界面，比如web页面，手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。 什么是后台？ 后台并不直接面向用户，而是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供了一些简单的配置。 前台、后台、用户之间的关系，可以用下图简单表示： 这样的架构带来的潜在问题就是，每次有新的独立项目了， 都要重新去搭建后台相关的技术支撑，许多项目都在重复造轮子， 项目也就变得越来越臃肿 为了解决这个问题， 中台就因此诞生了 中台最早提出中台这个概念的是一家芬兰的手机游戏公司叫SuperCell。 虽然可能没听过公司名字，但应该听过游戏吧， 大名鼎鼎的部落冲突 SuperCell公司就像是一个高产的游戏孵化器，在几年内开发出了10款以上的游戏，但是大部分用于试错的游戏都在研发过程中被腰斩了，最终呈献给用户的几款游戏都是经典中的经典。 是什么让SuperCell公司能够如此高效地试错和迭代呢？他们依靠的是强大的平台资源，支撑起各个游戏开发的小团队。 他们开发出的游戏看上去风格迥异，却存在许多共同之处。在业务上，共通的东西包括支付系统、用户系统等等，在技术上，共同的东西包括游戏引擎，内部开发工具等等。而这些共通的资源，都可以由一个强大的“中台”来提供： 中台的架构思想改变的不只是项目结构，也影响了研发团队的组织形式。SuperCell公司把这种高效的组织形式称为“部落”。 紧随其后，国内互联网公司也纷纷开始了各自的中台战略。 阿里巴巴提出了“大中台，小前台”的战略： 中台的具体划分按照不同的角色和功能，中台可以分成4个维度： 业务中台业务中台在前文中反复提及，就是把各个项目的共通业务进行下沉，整合成通用的服务平台： 技术中台技术平台，为了避免研发人员重复发明轮子，向各个项目提供通用的底层框架、引擎、中间件 数据中台数据中台，为各个项目进行各种数据采集和分析： 算法中台算法中台，为各个项目提供算法能力，比如推荐算法、搜索算法、图像识别、语音识别等等 何时使用中台架构适合业务较大的公司， 整合资源需要中台， 需要极速扩张的小公司没有必要考虑中台 参考文献原文写的很不错， 我这篇属于删减后的搬运工， 方便自己理解！请支持原作者！ 原文链接 https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ]]></content>
      <categories>
        <category>中台</category>
      </categories>
      <tags>
        <tag>中台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】为什么React 的方法需要bind]]></title>
    <url>%2F2019%2F09%2F24%2F%E3%80%90React%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88React-%E7%9A%84%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81bind%2F</url>
    <content type="text"><![CDATA[今天下班的时候， 同事问我React 的中的方法为什么需要箭头函数包裹， 或者是bind 绑定一下this指向， 才能被调用， 我当时也是一愣啊， 虽然以前好像也去研究过这个问题， 但好像答案也并不是那么明确。 于是我就把当时我的想法跟他阐述了一下， 当时我是这么说的： this 在初始化时是指向的对象实例， 但调用方法的时候不是， 因为jsx不是真正的dom 它会被转化为虚拟dom, 所以事件是通过react代理的， 并且这个涉及到javascript的作用域问题， 正常的变量都会是词法作用域， 也就是在书写阶段就能确定该变量的作用域， 而this 则是一个怪咖，他是一个动态作用域， 它是在执行期间才会确定 this 指向， 俗话说就是谁调用就指向谁。 因此，事件被react 代理了注册了， 如果是正常情况的this 在调用期间自然无法获得原本的class 指向， 至于为什么 this 是undefind ， 这是因为 this 应该是指向到了 window 上， 而执行react 的代码中开启了严格模式所以 this 就变成了undefind 上面这些， 咋一看好像没什么问题， 但我仔细一想好像又不太对劲， 问题真的是出在 React 代理注册事件的时候吗 让我们来一探究竟： 这是React 官网的一段话， 大致意思是（用的翻译工具🐶）: 你必须要小心的这JSX回调的this。 在JavaScript中，类方法不是默认绑定的。 如果你忘了绑定this.handleClick并把它传递到的onClick，这将是不确定的，当函数实际被调用的时候。 这不是React 的行为; 这是在JavaScript中的函数工作的原理的一部分。 通常，如果指的是方法，无需（）后，如onClick = {this.handleClick}，则应该bind 指向。 如果调用bind惹恼了你，可以使用箭头函数 也就是说问题不是出在了React 身上， 而是出在了javascript 自身的执行机制上。 那让我们回归本质， 看看到底是怎么一回事吧。 让我们来看同样一段代码， 不同情况下的this指向。 12345678910111213var demo = &#123; fn(key) &#123; console.log(key, this) &#125;&#125;demo.fn('1')// 这一步就类似我们在jsx中的事件赋值操作var dFn = demo.fndFn('2')var arrowsFn = () =&gt; demo.fn('3')arrowsFn() 我们可以看到 ，2 的赋值方式导致了this指向的丢失， React 的事件挂载时我们也是如此操作， 这也就说明了是js 本身的问题而非 React 导致的， 尽管React 没有做相应的处理也有责任 让我们继续， 不是说React 中指向的是 undefind 吗， 那我们打开严格模式看看是不是如此: 12345678910111213"use strict";var demo = &#123; fn(key) &#123; console.log(key, this) &#125;&#125;demo.fn('1')var dFn = demo.fndFn('2')var arrowsFn = () =&gt; demo.fn('3')arrowsFn() 果然如此， this 指向变为了undefind]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWA】如何使用PWA]]></title>
    <url>%2F2019%2F09%2F19%2F%E3%80%90PWA%E3%80%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PWA%2F</url>
    <content type="text"><![CDATA[为什么选择PWA 浏览器的存储机制有缺陷， indexDB, webSQL 虽有存储空间，但读取性能较弱， localhost 存储存在上线, 虽能通过iframe 和域名 扩展空间， 但成本较大， 并且较差的手机， 超过2.5M就会出现性能问题，引起卡顿 浏览器实现的mainifest 不完善， 很有可能一份数据在用户手机上存一辈子， 无法更新 以上的方式始终离不开网络 2018年safari 全面支持pwa 增加首屏体验 pwa 的特点[ 响应式 ] — ⽤用户界⾯面可以兼容多种设备，⽐比如: 桌⾯面，移动端，平板。[ 应⽤化 ] — 交互体验接近native应⽤用。[ ⽹络低依赖: ] — 无⽹络或者低速网络下依然可以使⽤。[ 延续性 ] 借助推送功能，能够维持⽤户粘性。[ 可安装 ] 可以被安装到主屏，这样⽤户随时可以从主屏启动应⽤。[ 可被发现 ] 被视为⼀个独⽴立应⽤，⽽且可以被搜索.[ 可更新 ] — 当⽤户重新联⽹网时，可以更新内容.[ 安全 ] — 可以使⽤HTTPS来防⽌止内容伪造和中间⼈攻击。[ 渐进性 ] — 所有⽤用户都可以使⽤用，浏览器器⽆无关。[ 兼容url ] — 可以通过url传播。 pwa 数据获取流程 注册成功的service worker , 会在网站运行时拦截住网页的所有请求， 然后向服务器询问是否有需要更新的数据， 如果得知不需要更新就从之前存储的缓存中读取， 大大加快网页加载速度 pwa 的生命周期 生命周期如图所示， 在service worker 初次加载时， 只会从 install 阶段执行到 activating 也就是从 安装 -&gt; 激活阶段 在第二次用户访问后， 才会触发fetch 事件 并且，整个service worker 的所有工作都是一个事务的过程， 也就是说， 当有多个service workder 时有一个失败， 所有的service worker 注册都失败 如何更好的监控离线使用offline.js 如何编写 service worker注册在注册service workder 之前先判断一下浏览器是否支持 然后从 navigator 中提供的serviceWorker 引入’sw.js’ 文件， 一般整个文件放在网站根目录 并且我们可以通过一些方法获得注册的相关信息 比如应用范围等等。1234567891011121314&lt;script&gt; if( "serviceWorker" in navigator ) &#123; console.log("当前 控制权", navigator.serviceWorker.controller) // 注册service worker navigator.serviceWorker.register('./sw.js').then((registeraction) =&gt; &#123; // 注册成功 console.log('serviceWorker注册成功,范围: ', registeraction.scope) &#125;).catch((err) =&gt; &#123; // 注册失败 console.log("serviceWorker 注册失败", err) &#125;) &#125;&lt;/script&gt; 安装首先创建一个 sw.js 文件， 然后编写相对应需要被缓存的文件数组， 也就是 下面的filesToCahe ， 还要为你的缓存编写一个类似于版本戳的 cacheName ，然后在self 对象上挂载intsall 事件, 编写一个方法， 将需要缓存的列表添加到caches 上， 然后用event方法去执行 12345678910111213141516171819202122232425262728var cacheName = "nxl-pwa-step-v1"var filesToCahe = [ "/css/index.css", "/images/cat.png", "/index.html", "/"]// 生命周期， 安装阶段， 首次注册才会触发self.addEventListener('install', (event) =&gt; &#123; // 首次注册被触发 // 能够缓存所有的应用 console.log('安装成功') // 等待缓存工作完成 event.waitUntil(updateStaticCache)&#125;)// 具体的缓存操作function updateStaticCache() &#123; // 使用 serveice workder 全局参数caches return caches.open(cacheName).then((cache) =&gt; &#123; // 原子事务操作， 一旦某个文件缓存失败 整个缓存全部作废 return cache.addAll(filesToCahe) &#125;) // 强制 处于wait 状态的脚本 进入激活状态， 当有多个 service workder 注册任务的时候 会变成事务等待， 一旦一个失败之后， 就会全部放弃， 这句话的意思就是放弃等待其他的service workder任务自己执行下去 .then(() =&gt; self.skipWaiting())&#125; 监听激活事件 同样是sw.js 监听激活事件 并对比之前编写的版本戳， 如果本次的版本戳和之前的不一样， 就把之前的版本戳从缓存中删掉 123456789101112131415// 生命周期， 激活阶段self.addEventListener('activate', function(event) &#123; console.log('激活成功') // caches 对象中不一定只有一个key , 会有多个key 的情况， 如果有多个就需要遍历， 一般多页面应用就会有多个 event.waitUntil(caches.keys().then(function(keyList) &#123; // 遍历当前版本戳的缓存 return Promise.all(keyList.map(function(key) &#123; // 如果旧的key 不等于 当前的 key 那就把旧的删了， （ 这里只判断了一种key 的情况 ） if( key !== cacheName ) &#123; return caches.delete(key) &#125; &#125;)) &#125;))&#125;) 拦截请求 同sw.js 网站的每一个请求都会被service worker 拦截住， 我们可以利用 Response 对象去伪造一个服务端的响应， 在这里我们主要是去匹配 caches 对象中的文件是否和发送请求的目标数据相等， 如果相等， 则直接走缓存，如果不想等则放行这个请求， 不影响数据加载 12345678910111213141516171819202122// 资源请求阶段 截取数据请求// 所有网站请求都会经过它self.addEventListener('fetch', (event) =&gt; &#123; // 拦截网络请求 console.log('拦截请求触发') // 伪造响应 // event.respondWith(new Response("拦截请求")) console.log("截取当前网络请求", event.request, fetch) event.respondWith( // 去匹配 每次的请求 caches.match(event.request).then(function (response) &#123; // 如果匹配到了则返回匹配结果, 如果没有匹配到，就使用fetch 请求放行 if( response ) &#123; console.log('response 🍊') return response &#125;else &#123; console.log('fetch 🍎') return fetch(event.request.url) &#125; &#125;) )&#125;) webpack工程化 offline-plugin Worker-precache-webpack-plugin 更优的方案利用google 的workderbox ， 当然，这也有工程化的方案, 一句话搞定所有 workbox-webpack-plugin 官方地址: https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin 更完善的pwa 解决方案更完善的pwa 解决方案可以使用 lavas ， 这是vue + pwa 的解决方案 全部代码 index.js 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;学习Pwa&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" href="./css/index.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;PWA测试应用&lt;/h1&gt; &lt;img src="./images/cat.png" width="200px" alt=""&gt; &lt;script src="./js/index.js"&gt;&lt;/script&gt; &lt;script&gt; if( "serviceWorker" in navigator ) &#123; console.log("当前 控制权", navigator.serviceWorker.controller) // 注册service worker navigator.serviceWorker.register('./sw.js').then((registeraction) =&gt; &#123; // 注册成功 console.log('serviceWorker注册成功,范围: ', registeraction.scope) &#125;).catch((err) =&gt; &#123; // 注册失败 console.log("serviceWorker 注册失败", err) &#125;) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; sw.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * serviceWorker几个重要的参数 * 1.self 代表了serviceWorker作用域 * 2.caches 代表了serviceWorker的全局参数*/// 添加版本戳// 所有sw 的值全部以cacheName 为版本戳依据， 当此时的key 和老的key 相同则从老的记录取， 如不一致，则重新安装var cacheName = "nxl-pwa-step-v1"var filesToCahe = [ "/css/index.css", "/images/cat.png", "/index.html", "/"]// 生命周期， 安装阶段， 首次注册才会触发self.addEventListener('install', (event) =&gt; &#123; // 首次注册被触发 // 能够缓存所有的应用 console.log('安装成功') // 等待缓存工作完成 event.waitUntil(updateStaticCache)&#125;)// 具体的缓存操作function updateStaticCache() &#123; // 使用 serveice workder 全局参数caches return caches.open(cacheName).then((cache) =&gt; &#123; // 原子事务操作， 一旦某个文件缓存失败 整个缓存全部作废 return cache.addAll(filesToCahe) &#125;) // 强制 处于wait 状态的脚本 进入激活状态， 当有多个 service workder 注册任务的时候 会变成事务等待， 一旦一个失败之后， 就会全部放弃， 这句话的意思就是放弃等待其他的service workder任务自己执行下去 .then(() =&gt; self.skipWaiting())&#125;// 生命周期， 激活阶段self.addEventListener('activate', function(event) &#123; console.log('激活成功') // caches 对象中不一定只有一个key , 会有多个key 的情况， 如果有多个就需要遍历， 一般多页面应用就会有多个 event.waitUntil(caches.keys().then(function(keyList) &#123; // 遍历当前版本戳的缓存 return Promise.all(keyList.map(function(key) &#123; // 如果旧的key 不等于 当前的 key 那就把旧的删了， （ 这里只判断了一种key 的情况 ） if( key !== cacheName ) &#123; return caches.delete(key) &#125; &#125;)) &#125;))&#125;)// 资源请求阶段 截取数据请求// 所有网站请求都会经过它self.addEventListener('fetch', (event) =&gt; &#123; // 拦截网络请求 console.log('拦截请求触发') // 伪造响应 // event.respondWith(new Response("拦截请求")) console.log("截取当前网络请求", event.request, fetch) event.respondWith( // 去匹配 每次的请求 caches.match(event.request).then(function (response) &#123; // 如果匹配到了则返回匹配结果, 如果没有匹配到，就使用fetch 请求放行 if( response ) &#123; console.log('response 🍊') return response &#125;else &#123; console.log('fetch 🍎') return fetch(event.request.url) &#125; &#125;) )&#125;) 项目地址 https://github.com/nxl3477/note/tree/master/pwa/code]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】利用systemJs构建微前端]]></title>
    <url>%2F2019%2F09%2F17%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%88%A9%E7%94%A8systemJs%E6%9E%84%E5%BB%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[微前端，其实就是微服务在前端的一种实践 微前端的特性 取代 iframe 各个开发团队都可以自行选择技术栈， 不受同一项目中其他团队影响; 各个交付产物都可以被独立使用， 避免和其它交付产物耦合; 各个交付产物中的样式不会污染到其他组件; 各个交付产物都可以自由使用浏览器原生API， 而非要求使用封装后的API; 目前实现微前端的多种手段现阶段实现微前端的方式大致有以下六种： 使用 HTTP 服务器的路由来重定向多个应用 在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA 通过组合多个独立应用、组件来构建一个单体应用 iFrame。使用 iFrame 及自定义消息传递机制 使用纯 Web Components 构建应用 结合 Web Components 构建 为什么不用 iframe[ 不可控制 ] — iframe 嵌入的显示区大小不容易控制， 存在一定局限性[ bfcache ] — URL的记录完全无效， 页面刷新不能够记忆， 刷新会返回首页， iframe 功能之间跳转也无效[ 兼容性坑 ] — iframe 的样式显示， 兼容性等都具有局限性[ 性能开销 ] — iframe 阻塞onload， 占用连接池， 多层嵌套页面崩溃 整体实现思路利用systemJs 的模块加载能力，略微调整webpack 产出相关配置， 将各个项目按照 systemJs 的模块规则导出， 利用脚本将所有应用整合到项目总线上， 利用cdn的形式引入各个框架的运行内核，有效提高缓存能力。使用订阅/发布的方式提供项目的总线订阅能力， 用以各个不同项目之间的通信。 搭建环境这里推荐大家自己去搭建webpack 开发环境，vue-cli、 create-react-app虽好， 但很多时候并不能完全满足我们的需求。 而且你不明白它是怎么搭建起来的， 当有需要修改的时候就会束手无措。 当然本文的重点是微前端， 我重点贴出需要关键的配置代码 将 webpack 的 entry 改为你的组件, 然后加入 webpack-system-register 插件， 这个插件可以将webpack产出的代码变为 systemJs 所支持的模块格式. 在使用 webpack-system-register插件时请关闭html-webpack-plugin， 否则会报错 构建一个观察者 懒得上babel 转了， 所以直接写的es5的代码 大家可以网上早开源的库，我这里选择构建这样的一个 订阅/发布者模式， 就叫eventBus好了， 用于框架之间的通信， 这需要团队之间遵守规范 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function(fn, global) &#123; global.EventBus = fn()&#125;)(function() &#123; function EventBus() &#123; this.observer = &#123;&#125;; &#125; // 监听事件 EventBus.prototype.subscribe = function(eventName, callback) &#123; const _this = this; // 判断该系列事件之前是否存在 if (!_this.observer[eventName]) &#123; _this.observer[eventName] = []; &#125; // 添加到该事件名称的队列中 _this.observer[eventName].push(callback); // 返回注销该事件的方法 return function unsubscribe() &#123; // 新的事件队列 var newEventQueue = []; // 旧的事件队列 var oldEventQueue = _this.observer[eventName]; // 遍历事件队列 for (var i = 0; i &lt; oldEventQueue.length; i++) &#123; // 获取当前回调事件 const itemCallback = oldEventQueue[i]; // 判断当前回调和订阅时的是否相同 if (callback !== itemCallback) &#123; // 不同则加入新的事件队列 newEventQueue.push(itemCallback); &#125; &#125; // 覆盖之前的事件队列 _this.observer[eventName] = newEventQueue; &#125;; &#125;; // 触发某一事件 EventBus.prototype.dispatch = function(eventName) &#123; const eventQueue = this.observer[eventName]; // 确保该事件队列存在 if (!eventQueue) &#123; return false; &#125; const args = Array.prototype.slice.call(arguments, 1) // 挨个调用订阅的回调 for (var i = 0; i &lt; eventQueue.length; i++) &#123; const itemCallback = eventQueue[i]; // 调用回调，传入参数， 进行this 的软绑定 itemCallback.apply(null, args); &#125; &#125;; return EventBus&#125;, window); 业务逻辑分别用react 和 vue 实现一个点击按钮数字增加的小功能， 然后用上我们上面写的eventBus 这样的一个观察者，来进行订阅和发布， 打到框架和框架之间，项目和项目之间共享状态 React 关键代码1234567module.exports = &#123; entry: './src/APP.jsx', // ....... 省略其他代码 plugins: [ new WebpackSystemRegister(&#123;&#125;), ]&#125; Vue 项目关键代码1234567module.exports = &#123; entry: './src/App.vue', // ....... 省略其他代码 plugins: [ new WebpackSystemRegister(&#123;&#125;), ]&#125; 构建vue项目逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class="vue-wrap"&gt; vue 组件 &lt;p class="vue-wrap-status"&gt;vue组件内状态： &#123;&#123;vueCount&#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;button @click="addVue"&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p class="vue-react-status"&gt; react组件内状态： &#123;&#123;reactCount&#125;&#125; &lt;/p&gt; &lt;div class="vue-react-trigger"&gt; &lt;button @click="addReact"&gt;通信react &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; vueCount: 0, reactCount: 0 &#125; &#125;, mounted() &#123; window.eventBus.subscribe('addVueCount', (count) =&gt; &#123; this.vueCount++ &#125;) &#125;, methods: &#123; addVue() &#123; this.vueCount++ &#125;, addReact() &#123; this.reactCount++ window.eventBus.dispatch('addReactCount', this.reactCount) &#125; &#125;,&#125;&lt;/script&gt;&lt;style lang="scss"&gt;.vue&#123; &amp;-wrap &#123; border: 3px solid green; color: green; font-size: 22px; font-weight: bold; text-align: center; &#125; &amp;-react &#123; &amp;-trigger &#123; padding-bottom: 20px; &#125; &#125;&#125;&lt;/style&gt; 此时的界面 构建react项目逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class App extends Component &#123; constructor(props) &#123; super(props) // 订阅事件 window.eventBus.subscribe('addReactCount', (count) =&gt; &#123; this.setState(&#123; reactCount: count &#125;) &#125;) this.state = &#123; reactCount: 0, vueCount: 0 &#125; &#125; addReactHandle() &#123; const &#123; reactCount &#125; = this.state this.setState(&#123; reactCount: reactCount + 1 &#125;) &#125; addVueHandle() &#123; const &#123; vueCount &#125; = this.state const newCount = vueCount + 1 // 派发事件 window.eventBus.dispatch('addVueCount', newCount) this.setState(&#123; vueCount: newCount &#125;) &#125; render() &#123; return ( &lt;div className="react-wrap"&gt; &lt;p&gt;React 组件&lt;/p&gt; &lt;p&gt;当前React 状态: &#123; this.state.reactCount &#125;&lt;/p&gt; &lt;button onClick=&#123; () =&gt; this.addReactHandle() &#125;&gt;点我&lt;/button&gt; &lt;hr/&gt; &lt;p&gt;当前Vue状态: &#123; this.state.vueCount &#125;&lt;/p&gt; &lt;button onClick=&#123; () =&gt; this.addVueHandle() &#125;&gt;通信vue&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 此时的界面 整合至总线首先我们想让总线项目同时具有 vue, react 的开发环境， 我们首先需要将其依赖导入。12345// vue&lt;script src="https://cdn.staticfile.org/vue/2.6.10/vue.min.js"&gt;&lt;/script&gt;// react&lt;script src="https://cdn.staticfile.org/react/16.9.0-rc.0/umd/react.production.min.js" crossorigin&gt;&lt;/script&gt;&lt;script src="https://cdn.staticfile.org/react-dom/16.9.0-rc.0/umd/react-dom.production.min.js" crossorigin&gt;&lt;/script&gt; 对了， 不能漏了最关键的systemJS1&lt;script src="https://cdn.staticfile.org/systemjs/3.1.6/system.min.js"&gt;&lt;/script&gt; 然后将我们之前写好的eventBus 引入1&lt;script src="./scripts/eventBus/eventBus.js"&gt;&lt;/script&gt; 并将其绑定到 window1window.eventBus = new EventBus() 然后我们将vue 项目和 react项目分别打包出来， 放入总线项目中：这里的index.js 就是项目打包产出的文件，需要注意的是,jsx想要在浏览器中运行， 我们还需要引入babel,1&lt;script src="https://cdn.staticfile.org/babel-standalone/7.0.0-beta.3/babel.min.js"&gt;&lt;/script&gt; 并且script标签上要加上type=&quot;text/babel&quot; data-type=&quot;react-app&quot; 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="vue"&gt; &lt;index&gt;&lt;/index&gt; &lt;/div&gt; &lt;div id="react"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;new Vue(&#123; el: "#vue", components: &#123; "index": () =&gt; System.import("./scripts/vue/index.js") &#125;&#125;)&lt;/script&gt;&lt;script type="text/babel" data-type="react-app"&gt; System.import("./scripts/react/index.js").then(_ =&gt; &#123; const domContainer = document.querySelector('#react'); const e = React.createElement; const App = _.default; ReactDOM.render(&lt;App /&gt;, domContainer); &#125;)&lt;/script&gt; 让我们打开看一下此时的效果。不但保留了 vue , react 两个项目的各自逻辑功能， 而且还成功进行了组件之间的通信， 如图中， 点击的通信按钮会影另一个组件的内部状态。 结尾一个基本的微前端架构成功实现了， 接下来我们需要做的更多的事情， 就是： 解决整合的难度及成本， 可以编写shell脚本或者是构建一个额外的打包配置 无法直观调试开发， 需要合并后， 才能看到， 无法热更新 项目代码地址 https://github.com/nxl3477/note/tree/master/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84 参考文献 https://juejin.im/post/5d7f702ce51d4561f777e258?utm_source=gold_browser_extension]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工程化】webpack5不完全尝鲜]]></title>
    <url>%2F2019%2F09%2F15%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack5%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%B0%9D%E9%B2%9C%2F</url>
    <content type="text"><![CDATA[如何安装webpack 5 npm install webpack@next -D 📦打包一下我们还是去尝试打包这样一段代码 最终生成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/******/ ((modules, runtime) =&gt; &#123; // webpackBootstrap/******/ "use strict";/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId](module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******//******/ // the startup function/******/ function startup() &#123;/******/ // Load entry module and return exports/******/ return __webpack_require__("./src/index.js");/******/ &#125;;/******//******/ // run startup/******/ return startup();/******/ &#125;)/************************************************************************//******/ (&#123;/***/ "./src/index.js":/*!**********************!*\ !*** ./src/index.js ***! \**********************//*! exports [maybe provided (runtime-defined)] [no usage info] *//*! runtime requirements: *//***/ (() =&gt; &#123;eval("console.log(\"你好，webpack\")\n\n//# sourceURL=webpack:///./src/index.js?");/***/ &#125;)/******/ &#125;); 是不是比webpack4 少了好多 webpack4 具体情况可以参考 站内文章 【工程化】webpack-编译后文件解析 少去了一大坨的恶心代码！ 这是因为： webpack5放弃了对兼容做处理的相关代码， 转而交给用户去做， 以此将其代码量减少为之前的三分之一不到 固定的id 天下苦moduleIds 和 chunkIds 已久 在webpack4 的时候， 我们的异步 chunkId 和moduleId 一直是一个大问题， 为什么这么说呢， 在此之前的各种 id 如下: natural , size 一般会用在我们的动态引入的异步组件上， natural 是自然数， size 是尺寸大小， 一般动态文件都会变成这样: 0.js, 1.js, 看似很完美的东西, 实际上， 会带来一些问题 不管是 natural 还是 size , 当一个组件模块被改变时就会影响到其他的模块的id, 比如: 一开始有a.js , b.js, c.js 对应 0.js , 1.js ,2.js ,但是后来我们不需要a.js 了， 那现在就变成了: b.js , c.js 对应 0.js , 1.js。 1⃣️所说的id 所带来的改变， 随之而来的影响就是造成网站缓存的报废， 也就是说之前用户辛苦加载的缓存没有用了， 并且是全部报废， 一个文件的改动影响到全部， 整个代价太大了。 更有，甚至可能会造成文件的引用错误， 因为之前0.js 对应的是 a.js , 1.js 对应的 b.js , 现在变了 0.js 对应了 b.js, 1.js 对应了 c.js, 浏览器直接走缓存 获取到这份js 文件， 就是引错文件了， 那项目不久炸了 在webpack4 时期的曲线救国方案： 使用魔法注释来告诉webpack 这个异步组件应该叫什么名字 这确实是一个解决办法， 但是很麻烦， 大点的项目动则上百个组件， 一个一个维护成本实在有点大， 而且后期的修改都得注意， 所以， 虽然有用， 但是不好用 webpack5 的福音 该方法的原理是通过分析文件， 来产生的简版md5 webpack5 带来了一个新的chunkId 的实现方式 deterministic , 123456module.exports = &#123; optimization:&#123; chunkIds: "deterministic”, moduleIds: "deterministic" &#125;&#125; 只需要这样， 就可以生成针对该文件的唯一chunkId, 太棒啦 更好的缓存如下当使用持久缓存时，不再需要cache-loader。 对于 babel cacheDirectory 等也是如此。 12345module.exports = &#123; cache: &#123; type: "filesystem" &#125;&#125; 参考文献: https://juejin.im/post/5c8761925188251a0844d3a4]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工程化】webpack 编译后文件解析]]></title>
    <url>%2F2019%2F09%2F15%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack-%E7%BC%96%E8%AF%91%E5%90%8E%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[webpack 为什么这么神奇？ 为什么能把 es6的模块化，node js 的模块化变成能让浏览器支持的代码？？ 让我们看看一个最简单的bundle文件， 一探究竟 如何实现模块化 webpack 打包后需要把所有模块的代码同步过来， 所以遵守的是commonJs 规范， 这是一个简简单单的代码，编译后的一个文件， 实际代码如下 这也证明了 webpack 不管你干了啥都会往你的代码里赛进这么一坨东西。 好的， 现在让我们把代码折叠起来然后删除没用的注释， 先不管细节，看看他的整体脉络 我们可以看到， 这就是我们最最熟悉的IIFE， 原来神秘的webapck 无非也就是做了一件事， 将现在的模块化转变成为上古时代的模块化。 并且一个个模块， 都已以其文件路径作为key , 具体的业务逻辑作为value , 这里我们就可以清晰的看到， 一个src/index.js 的文件路径后面跟着的一个函数 ， 里面就大大的写着 1eval("console.log(\"你好，webpack\")\n\n//# sourceURL=webpack:///./src/index.js?"); 这里顺带一嘴， 这里生成的1(\"你好，webpack\")\n 这样字符串就是我们当初玩弄 AST 时，看到的 raw, 也就是带转译的元数据， 当然， 这里如果不实用整个就无法运行了，对吧 为什么是evalwebpack 在 development 模式下产出的就是 eavl ， 如果是 production 生产环境模式， 是绝对不会有这样的形式代码 生产环境下的产出: 那 webapck 为什么会这样选择呢? 生成eavl 方便开发环境下的热更新 生产环境不使用 eval 是因为 eval的性能不高，并且不安全， 容易被人XSS]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工程化】如何编写一个自己的webpack插件]]></title>
    <url>%2F2019%2F09%2F14%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[webpack 实现插件的机制[ 创建 ] – webpack在其内部对象上创建各种钩子[ 注册 ] – 插件将自己的方法注册到对应钩子上， 交给webpack[ 调用 ] – webpack 编译过程中， 会适时地触发相应钩子， 因此也就触发了插件的方法 第一个demo不知道这么起步， 那咱就先去复制一个， 官网提供了一个最最最简易的demo https://webpack.js.org/concepts/plugins/ 复制下来是这样的:1234567891011121314const pluginName = 'ConsoleLogOnBuildWebpackPlugin';class ConsoleLogOnBuildWebpackPlugin &#123; // 每个插件必备的方法 apply(compiler) &#123; // compiler 是整个webpack编译的核心 // tap 可以理解为触发订阅 compiler.hooks.run.tap(pluginName, compilation =&gt; &#123; console.log('🍎The webpack build process is starting!!!'); &#125;); &#125;&#125;module.exports = ConsoleLogOnBuildWebpackPlugin; 把这个插件引入webpack , 虽然是成功跑起来了啊， 但是一脸蒙蔽， 完全不知道在干嘛也不行啊 首先每个插件都必须要有一个apply 方法， 它会接收一个compiler ， 这个compiler 是所有webpack的核心， 所以webpack 编译相关的内容自然也就在它上面了 接着，我们看到了 complier 上有一个hooks , 后面还有一大串， 那这个hooks是哪里来的呢， 怎么回事呢？ 让我们去源码里一探究竟： 哦～ 原来所有 hooks 相关的方法都在这里了， 并且我们发现 compiler 是继承自 Tapable 不光如此， 连接受的参数中的 compilation 也继承自 Tapable, compilation 代表了当次编译的chunk 那啥是 Tapable 啊？ 认识 TapableTapble 是 webpack 的灵魂插件， 它是一个用于做消息通知的包. 多说无用， 让我们来单独玩一下 tapable 12345678910111213141516171819202122232425262728293031323334const &#123; //同步串行的钩子， 不用关心函数的返回值 SyncHook, // 同步串行的钩子 ， 上一个返回值不为null 跳过剩下的逻辑 SyncBailHook, // 同步串行， 上一个值可以传递给下一个值 SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook &#125; = require("tapable");const queue = new SyncHook(["name", "name2"])// 订阅queue.tap("1", function (name, name2) &#123; console.log("1⃣️", name, name2) return 1&#125;)queue.tap("2", function (name, name2) &#123; console.log("2⃣️", name, name2)&#125;)queue.tap("3", function (name, name2) &#123; console.log("3⃣️", name, name2)&#125;)// 触发整个钩子queue.call('webpack', "webpack-cli") 此时的输出 可以看的出 ， 当queue 的call 方法被调用时， 之前挂载的 tap 方法都被触发了， 这其实就是前端里几乎无处不在的观察者模式 附上一个之前写的webpack 插件这是之前用来处理swig模版编译的plugin1234567891011121314151617181920212223242526272829303132// 1. 何时才能拦截最后生成的swig// 2. 如何分清这个swig文件对应的Jsclass HtmlAfterWebpackPlugin &#123; // compiler 是webpack的实例 apply(compiler) &#123; // 此处是实例运行期间， 可以吧 tap 当成是 on // 实例上有钩子， 将插件注册到webpack实例钩子上 （run初始运行阶段, compilation: 完成阶段） compiler.hooks.compilation.tap(pluginName, compilation =&gt; &#123; console.log("🍉webpack 构建过程开始！"); // 因为webpack的版本更新不友好， 所以新的插件挂载方式需要自己从源码中查找 // 此阶段是 html-webpack-plugin 提供的， 所以必须在 html-webpack-plugin 之后执行 // 此处是将回调挂载到 webpack 执行过程中的某个阶段， 也就是生命周期 // Plugin的顺序是 从上至下挂钩子， 但执行顺序不一定 compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(pluginName, htmlPluginData =&gt; &#123; let _html = htmlPluginData.html const jsResult = assetsHelp(htmlPluginData.assets) // 路径别名 _html = _html.replace(/views:/g, "../../") _html = _html.replace(/components:/g, "../../../components/") // 指定位置插入js css _html = _html.replace(/&lt;!--injectjs--&gt;/g, jsResult.js.join("")) _html = _html.replace(/&lt;!--injectcss--&gt;/g, jsResult.css.join("")) // _html = _html.replace("&lt;!--injectjs--&gt;", jsResult.js.join("")) htmlPluginData.html = _html // htmlPluginData.html = _html &#125;) &#125;); &#125;&#125;]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工程化】babel简单原理及简单实现]]></title>
    <url>%2F2019%2F09%2F14%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91babel%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[我们知道babel 的原理是通过转换为Ast的方式， 进行一系列的处理， 然后最终得到了我们看到的代码。 这就是它强大之处。 如果让你来实现一个babel 这样的转换代码工具， 你会如何去做呢？ 是不是首先会想到使用正则呢， 但实际上， 正则无法很好的满足需求， 这是因为： 需要针对各个类库编写相关正则 当类库内部实现改变则正则也要改变 正则的匹配需要区分注释情况， 有写代码被注释掉如果也被正则匹配了那就会影响实现， 比如requireJs就是使用正则匹配的， 导致注释掉相关方法还是调用了 综上所诉， 最终我们的解决方案应该是 AST! 如何实现一个简单的babel 呢： 我们需要有将代码转换为 AST 的工具， 处理AST 的工具， AST 转回代码的工具！ 让我们来做一个 es6 变量转为es5变量的小工具， 让我们开始动手吧 让我们先 从字符串转为AST： 12345678910111213const esprima = require('esprima')const estraverse = require('estraverse')const code = ` const view = &#123; a: 3, init: () =&gt; &#123; view.a = 5 &#125;, render: () =&gt; &#123; &#125; &#125;`const ast = esprima.parse(code) 让我们看看上面构建的这段代码字符串会被转换为什么 看到了结果， 我们也看到了我们需要的关键字const ， 是不是我们只要把它改为var 就可以了呢， 哈哈， 动手试试吧 1234567891011121314151617181920212223242526272829const esprima = require('esprima')const estraverse = require('estraverse')const escodegen = require('escodegen')// mock 一段代码const code = ` const view = &#123; a: 3, init: () =&gt; &#123; view.a = 5 &#125;, render: () =&gt; &#123; &#125;&#125;`// 将代码转为 astconst ast = esprima.parse(code)console.log(ast)// 遍历ast 修改相关操作estraverse.traverse(ast, &#123; enter(node) &#123; if( node.type === "VariableDeclaration" ) &#123; node.kind = 'var' &#125; &#125;&#125;)// 得到经过ast处理的 js 代码 const reg_code = escodegen.generate(ast)console.log('--------- 输出结果 ---------------')console.log(JSON.stringify(reg_code, null,4)) 此时的输出: 可以看到最下面的字符串， const 被成功替换为了 var ， 完美！ 一个最小最简陋的babel 就这么实现了！]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>工程化</tag>
        <tag>Ast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】小程序中如何引入iconfont 字体图标]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5iconfont-%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[icon引入小程序需要将字体文件转换成base64格式，所以 先解压压缩包 找到ttf格式文件 上传到平台转化为base64格式 下载压缩包 将css文件名改为wxss 放入项目样式文件夹 字体文件转换成base64格式的链接 https://transfonter.org/ 参考文档 https://www.cnblogs.com/minimo/p/8795774.html]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】vue-cli3 jest单元测试报错（不支持ES6)]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91vue-cli3-jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8A%A5%E9%94%99%EF%BC%88%E4%B8%8D%E6%94%AF%E6%8C%81ES6%2F</url>
    <content type="text"><![CDATA[在使用公司项目想尝试单元测试的时候， 公司使用的是jest, 发现提示了ES6相关的语法错误提示， 网上百度好多， 各种尝试依旧未能解决 最后的解决办法: 用vue-cli3 重新创建了一个带单元测试的项目， 然后发现运行成功， 于是把该项目的单元测试相关依赖版本拷贝到公司项目里， 于是公司项目成功运行 ， ✌️ 最后发现只需要把 babel-jest版本降一下就可以了， 1&quot;babel-jest&quot;: &quot;^23.6.0&quot;, 如果不生效记得把 package.lock文件删了]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】ios无法播放部分mp4视频怎么办]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91ios%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E9%83%A8%E5%88%86mp4%E8%A7%86%E9%A2%91%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[今天遇到了， 安卓可以播放某个mp4视频，但是ios就是无法播放 抓耳挠腮半天， 才得知， 原来是视频的压缩级别的问题，ios对 mp4的压缩级别支持有限， 最后我转成MPEG-4编码格式， 完美运行（当然其他的编码格式也行， 我只是随便使用了下） mac可以使用handBreak转一下 参考文档 https://www.jianshu.com/p/31f0593496ef]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】a 标签下载视频却跳去播放的问题]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91a-%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91%E5%8D%B4%E8%B7%B3%E5%8E%BB%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[明明写了 a 标签， 也加了 download属性， 但是还是跳去播放视频了， 原来，如果想下载视频， 你得在 a 标签的视频链接地址后面带个参数?filename=xxx 比如: 1www.aaa.com/video?filename=xxx]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】mac 下 ssh 连接gitHub死活不成功的问题]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91mac-%E4%B8%8B-ssh-%E8%BF%9E%E6%8E%A5gitHub%E6%AD%BB%E6%B4%BB%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通 git clone 一直提示这样的错误1234Cloning into &apos;xxx&apos;...zsh:1: command not found: connectssh_exchange_identification: Connection closed by remote hostfatal: Could not read from remote repository. 或是这样的错误:123456Cloning into &apos;xxx&apos;git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 不止配置了一遍gitHub 的 ssh key 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案. 后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加 需要添加一下你创建的公钥， 告诉系统可以使用 1ssh-add -K ~/.ssh/你的ssh key名称(不带.pub) 比如：1ssh-add -K ~/.ssh/github_rsa 于是， clone 顺利 附上创建密钥的命令: ssh-keygen -t rsa -C “your_email@youremail.com“ 参考文献: http://shinancao.cn/2016/12/18/Programming-Git-1/]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】jest进行单元测试时提示router-view 未注册报错了]]></title>
    <url>%2F2019%2F09%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91jest%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%97%B6%E6%8F%90%E7%A4%BArouter-view-%E6%9C%AA%E6%B3%A8%E5%86%8C%E6%8A%A5%E9%94%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通 git clone 一直提示这样的错误1234Cloning into &apos;xxx&apos;...zsh:1: command not found: connectssh_exchange_identification: Connection closed by remote hostfatal: Could not read from remote repository. 或是这样的错误:123456Cloning into &apos;xxx&apos;git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 不止配置了一遍gitHub 的 ssh key 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案. 后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加 需要添加一下你创建的公钥， 告诉系统可以使用 1ssh-add -K ~/.ssh/你的ssh key名称(不带.pub) 比如：1ssh-add -K ~/.ssh/github_rsa 于是， clone 顺利 附上创建密钥的命令: ssh-keygen -t rsa -C “your_email@youremail.com“ 参考文献: http://shinancao.cn/2016/12/18/Programming-Git-1/]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【工程化】了解webpack原理]]></title>
    <url>%2F2019%2F07%2F11%2F%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91%E4%BA%86%E8%A7%A3webpack%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[webpack 的成功之处在于其loader , 但 webpack 的失败之处也出在这个loader 对于webpack 来讲， 万物都是模块， webpack 为什么可以做到万物都可以 require就是使用了loader, 但同时也是loader 导致了webpack 的编译速度（你懂的）， 这是为什么呢， 这里先说一下基本原理 webpack 在处理的时候， 会经过多个loader, 比如babel-loader,less-loader， 那如何把这些看似毫不相关的， 又是天南地北找来的， 出自不同开发者之手的loader 集合起来呢: 首先是第一个接受任务的loader, loader1 会接受代码的字符串， 然后把代码变成 Ast 进行处理， 结束以后再转为 string字符串。 也就是说，整个 loader1 经历了一下的流程: 1字符串 -&gt; Ast 静态语法树 -&gt; 遍历Ast处理业务 -&gt; 字符串 同样的loader2 也会经历这样一个过程！ 也就是说所有loader 穿起来就是:1234loader1 开始 -&gt; 获取字符串 -&gt; Ast -&gt; 遍历Ast处理业务 -&gt; 字符串 -&gt; loader1结束 -&gt; loader2 开始 -&gt; 获得字符串 -&gt; Ast -&gt; 遍历Ast处理业务 -&gt; 字符串 -&gt; loader 2 结束 -&gt; loader3开始 -&gt; ………等等 乍一看， 你可能会觉得， 是不是太蠢了， 为什么不等到全部loader处理完成再转换回 字符串， 还要转来转去， 原来打包时间都在这消耗掉了。没错， 你当然不是第一个想到的， 这就是之前大火的parcel 的打包机制（虽然parcel的零配置很优秀， 但因为被webpack抄走了， 所以也渐渐势头不在）, 并且parcel还启用了多核打包: 1string字符串 -&gt; Ast(loader1 &amp; loader2 &amp; loader3) -&gt; string 字符串 外加多核打包📦 一气呵成， 这感觉，多爽， 确实比webpack快多了 ，省了那么多步骤， 能不快吗 webpack 与优化上面提到了 parcel 的多核打包， 可我们的主场是webpack ,怎么能不提一提webpack 的多核打包呢， 相信大家都听过或者尝试过臭名昭著的 happypack 多核打包插件， 但这个插件实际上在高版本的webpack 上效果略低啊 happypack 可以用，但也需要考虑下应用场景： 在需要打包的文件太少不建议， 因为多核打包也是需要消耗系统性能的， 反而会使打包变慢了 实际操作起来效果不明显 如何实现一个loader 熟话说， 看源码是最好的学习方式， 现在我们先找一个比较简单的开源loader ,看看别人是怎么写的? 我们下载markdon-loader, 打开node_modules 中其的代码， 发现如下： 让我们加点注释理解一下 loader 有一个前置钩子， 会在进入主体函数前被调用： 1234567891011121314module.exports = function (content, map, meta) &#123; // this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函 // 数库来从 this 获取外部 rule 处对 loader 配置的option console.log('🍎进入loader') console.log('前置钩子内容🍌', this.data) return content + ";console.log(1)"&#125;// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)module.exports.pitch = function (r, prerequest, data) &#123; console.log("进入前置钩子") data.value = "are you ok"&#125; 在外面webpack 配置的地方引用我们上方编写的loader123456789101112131415161718const path = require('path')module.exports = &#123; module: &#123; rules: [ &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: path.resolve("./loader/index.js"), options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; ] &#125;&#125; 让我们看下此时的输出结果 获取相关的option 配置webpack 提供的函数库可以帮助我们， 在执行阶段从 this 对象上获取到我们配置时所传入的 option 的相关 loader 配置123456789101112131415161718const loaderUtils = require('loader-utils')module.exports = function (content, map, meta) &#123; // this 是我们运行时数据调用方法和补充载体 也就是loader函数的执行上下文， 所以可以通过webpack 提供的函 // 数库来从 this 获取外部 rule 处对 loader 配置的option console.log('🍎进入loader') console.log('前置钩子内容🍌', this.data) const options = loaderUtils.getOptions(this) console.log('🍊获取到的配置文件', options) return content + ";console.log(1)"&#125;// 一个叫pitch的前置钩子 ( 在进入⬆️主体前触发)module.exports.pitch = function (r, prerequest, data) &#123; console.log("进入前置钩子") data.value = "are you ok"&#125; 此时我们就成功获取到了配置时所传入的参数了 异步loader如果我们的编写过程中有异步的需求, 我们可以使用下面这两个方法 this.async 执行异步函数 this.callback 执行函数的回调， 返回处理结果 loader 与 Ast既然loader处理的核心是 Ast, 那么我们同样的夜来尝试一下Ast 的使用, 首先我们下载一个acorn , 这是一个专门处理 ast 的库, 我们使用 acorn 提供的方法尝试去转换一段代码， 然后使用walk 所提供的方法将其转换回来123456789const acorn = require("acorn")const walk = require('acorn-walk')console.log(acorn.parse("const a = 20"))walk.simple(acorn.parse('let x = 10'), &#123; Literal(node) &#123; console.log(`Found a literal: $&#123;node.value&#125;`) &#125;&#125;) 输出的结果]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>Ast</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Redux】react、redux与函数式编程]]></title>
    <url>%2F2019%2F07%2F07%2F%E3%80%90React%E3%80%91react%E3%80%81redux%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[redux 本身是container ， state就是value ， action 就是 变形关系 可以将React看作输入为state， 输出为view的“纯”函数 范畴论将世界抽象为对象和对象之间的联系， Redux将所有事件抽象为 action (变形关系) container 有_value 和 map 两个属性， 而修改 _value 的方法直有 map , 在操作完 _value 后将新值放回 Container中 如何操作或修改_value 由f给出 store 是一个容器含有state 和 reducer , 这从store 的创建语句， 并且currentState在修改完后将新值依然存放在 store内。如何修改 currentState 是根据用户操作 action 12345store -&gt; containercurrentState -&gt; _valueaction -&gt; fcurrentReducer -&gt; mapmiddleware -&gt; IO functior // 解决异步操作的各种问题]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】immutable 内部实现原理]]></title>
    <url>%2F2019%2F07%2F03%2F%E3%80%90React%E3%80%91immutable-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[immutable.jsImmutable.js 采用了持久化数据结构（每次修改后我们都会得到一个新的版本，且旧版本可以完好保留），保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过结构共享(对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享)等方式大幅提高性能。 原理解读 Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。 Immutable.js 实现了一个hash函数，可以把一个值转换成相应数字。接下来HAMT Hash array maps trie 压缩treeImmutablejs 对于 Map，使用了这种方式优化，并且通过树宽与树高的压缩，形成了文中例图中的效果（10010 10000 聚合成了一个节点，并且移除了同级的空节点）。 查找原理可以看到上面那张图一样， 查找 tea, 先找到 t 再找到e ,再往下找到a， 根据这个查找路径， 找到对应的值 二进制的查找方式也是这个原理， 如下图所示， 左上角的值与二进制路径互相映射 分区 数字分区（Digit partitioning）指我们把一个 key 作为数字对应到一棵前缀树上。 位分区（Bit Partitioning）数字分区的方法是有点耗时的，在每一层我们都要进行两次除法一次取模，显然这样并不高效，位分区就是对其的一种优化。位分区是建立在数字分区的基础上的，所有以2的整数次幂（2，4，8，16，32…）为基数的数字分区前缀树，都可以转为位分区。基于一些位运算相关的知识，我们就能避免一些耗时的计算。数字分区把 key 拆分成一个个数字，而位分区把 key 分成一组组 bit。以一个 32 路的前缀树为例，数字分区的方法是把 key 以 32 为基数拆分（实际上就是 32 进制），而位分区是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二进制位 。 bitMap bitMap学习链接：https://blog.csdn.net/moakun/article/details/79927791 利用位运算来快速查找计算， 得出结果， immutable 也正是利用了这一点， 在代码逻辑的关键处大量的使用了位运算 为什么选择32位Immutable.js 的 Vector Trie 采用了 32 作为数组的长度，我们解释了由于采用了位分区，该数字只能是2的整数次幂，所以不能是 31、33 等。但8、16、64等等呢？这是通过实际测试得出的，图中分别是查找和更新的时间，看上去似乎 8 或 16 更好？考虑到平时的使用中，查找比更新频次高很多，所以Immutable.js 选择了 32 32位如何处理immutable 会把32位挨个转换为二进制， 因为 2^5 = 32， 类似如下图， 每一位都会转换为相应的二进制用于快速位运算 核心原理 Bitmap 一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他的数据和元素相关联。在索引，数据压缩等方面有广泛应用。 HashArrayMapNode，拥有的子节点数量 ＞16 ，拥有的数组长度为 32 BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap压缩 ValueNode，叶子节点，存储 key 和 value HashCollisionNode的节点去处理发生冲突的键值 经典的代码段123456789//计算二进制中1的数量function popCount(x) &#123; x -= (x &gt;&gt; 1) &amp; 0x55555555; x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333); x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f; x += x &gt;&gt; 8; x += x &gt;&gt; 16; return x &amp; 0x7f;&#125;]]></content>
      <categories>
        <category>immutable</category>
      </categories>
      <tags>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】Object、Array与Map的比较]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%90JS%E3%80%91Object%E3%80%81Array%E4%B8%8EMap%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Object 与 Map Object 在V8中的实现是 key - value 分别作为一个数组存储, 所以存储空间是元素的两倍 和Array对比]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】Set是如何实现的]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%90JS%E3%80%91Set%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%2F</url>
    <content type="text"><![CDATA[一般情况Set一般是使用红黑树实现的, 红黑树是一种平衡查找二叉树, 它的查找时间复杂度为O(logN). 从O(N)变成O(logN), 而总体时间从O(N2)变成O(NlogN) V8中的实现(哈希实现)Chrome V8的Set是哈希实现的, 他是一个哈希Set, 哈希的查找复杂度为O(1), 因此总的时间复杂度为O(N), Set/ Map都是这样 哈希的存储空间通常为数据大小的两倍. 典型的用空间换时间的算法. for 、Set和Map如何选型 面试标准回答一般情况是使用 红黑树实现的, 复杂度是 O(logN) V8进行了优化, 复杂度降低至 O(1)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】MessageChannel消息通道]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%90JS%E3%80%91MessageChannel%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[介绍宏任务! 点对点之间的通信 Channel Messaging API的Channel Messaging接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。 它会返回两个端口 Port1和 Port2 使用场景思考 Vue 中用作与 $nextTick 的备选方案, 是宏任务 用作与Fiber 的进程调度中 可以用在组件之间的通信 利用参数传递默认深拷贝的特性来做深拷贝. 与Iframe 通信 一段Demo12345678910111213141516var channel = new MessageChannel();var para = document.querySelector('p'); var ifr = document.querySelector('iframe');var otherWindow = ifr.contentWindow;ifr.addEventListener("load", iframeLoaded, false); function iframeLoaded() &#123; otherWindow.postMessage('Hello from the main page!', '*', [channel.port2]);&#125;channel.port1.onmessage = handleMessage;function handleMessage(e) &#123; para.innerHTML = e.data;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】关于requestIdleCallback函数的作用]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%90JS%E3%80%91%E5%85%B3%E4%BA%8ErequestIdleCallback%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[requestIdleCallback 会在浏览器每一帧的空闲时期依次调用函数， 如果说， 一个浏览器的效率很高，有60fps的刷新频率， 也就是说该浏览器每一帧的刷新时间是16.6s， 如果说电脑比较卡， 那刷新频率可能就会下降， 会是 30fps(原则上30fps是肉眼能接收的最低频率)。 此时，每一帧也就是33.3s， 该函数的出发场景就是在帧与帧之间， 也可以是说帧的末尾， 实际上每一帧并不一定会完全消耗完 16.6s 甚至是 33.3s， 他会有剩余的时间留给浏览器去执行js， requestIdleCallback 就是如此， 用它调用的函数会在浏览器的该帧期间，渲染过后的剩余时间内调用该回调， 这也是react 16 fiber架构的调度算法核心 基本语法 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback 并且我们还可以通过 deadline.timeRemaining方法来查看该帧期间的剩余时间 Demo首先尝试搭建一个最简单的demo ,打印一下 deadline 、剩余时间 和 该函数的返回值123456789101112const id = window.requestIdleCallback((deadline) =&gt; &#123; // 剩余时间， 单位ms, 指的是该帧的剩余时间 console.log(deadline.timeRemaining()) // 表示该帧里面没有执行回调， 超时了 console.log(deadline)&#125;, &#123; // 1. 即超时时间， 不提供的话浏览器会自己去算 // 2. 如果给定 timeout ， 那到了时间， 都会立刻执行回调 callback timeout: 1000&#125;)console.log(id) 返回结果: 我们可以看到： 该函数的返回结果(id)的值： 1 浏览器本帧的剩余空闲时间: 1.2750000000000001 回调接收的 deadline方法， 里面有一个 didTimeout 属性 如何取消requestIdleCallback将 requestIdleCallback 的返回值（一个无符号长整数），可以把它传入 Window.cancelIdleCallback() 方法，来结束回调 如何实现 polyfillrequestIdleCallback 这个方法浏览器的兼容相当差， 那怎么办， React16 Fiber中也使用了， 别人是如何解决的呢？ 答案是： requestAnimationFrame 利用回调接收的 DOMHighResTimeStamp 参数， 计算出每一帧所花费的时间， 自己去实现一个 requestIdleCallback 的polyfill , 简直完美]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】Fiber架构]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%90React%E3%80%91Fiber%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Fiber 是什么Fiber 是一个名词， 在计算机科学中除了进程（Process） 和线程（Thread）的概念还有一个概念叫做Fiber, 英文含义就是“纤维”， 意指比Thread更细的线， 也就是比线程（Thread）控制得更精密的并发处理机制。Fiber可以提升复杂React应用的可响应性和性能。 Fiber 即是React 新的调度算法（ reconciliation algorithm） 现有React 中， 更新过程是同步的，当组件树比较庞大的时候， 浏览器主线程被React占用。用户此时输入Input 会造成页面卡顿。 Fiber使用协作式多任务处理任务。 将原来的整个Virtual Dom 的更新任务拆分成一个个小的任务。 每次做完一个小任务之后， 放弃一下自己的执行将线程空闲出来， 看看有没有其他的任务。如果有的话， 就暂停本次仍无， 执行其他的任务， 如果没有的话，就继续下一个任务。 React16与Fiber react16升级了reconcile 算法架构， 从stack升级为fiber 架构。每次组件的state更新都会出发reconcile的执行也是一个递归过程， 而且一开始知道递归完所有节点才停止， 因此称为stack算法。由于js是单线程的， 因此此时就可能会影响用户的输入或者Ui的渲染帧频造成卡顿， 降低用户体验。而fiber 架构则不一样， 底层是基于 requestdleCallback来调度diff算法的执行， 它的特点顾名思义就是利用空闲时间来完成任务。 注意这里的空闲时间就是相对于那些优先级更高的任务（比如用户输入、 Ui渲染）来说的。 requestIdelCallback Polyfill 使用了一个33毫秒， 这个时间是React 认为的一个可以接收的最大值， 如果运行设备能做到大与30fps， 那么它会去调整这个值（通常情况下可以调整到16.6ms）。 调整策略是用当前每帧的总时间与实际每帧的时间进行比较， 当实际时间小于当前时间且稳定( 前后两次都小于当前时间 )， 那么就会认为这个值是有效的， 然后将没帧时间调整为该值（取前后两次中时间大的值）， 还有就是requestAnimationFrame 回调的第一个参数， 每一帧的起始时间， 最终借助requestAnimationFrame 让一批扁平任务恰好控制在一块一块的33ms这样的时间片内执行即可 Fiber的两个阶段由reconciler和 renderer两个概念引出的是Phase的概念， Phase指的是React组件渲染时的阶段。 Reconcile 阶段。 此阶段中， 依序遍历组件， 通过diff算法， 判断组件是否需要更新， 给需要更新的组件加上tag， 遍历完之后， 将所有带有tag的组件加到一个数组中。 这个阶段的任务可以被打断。 Commit 阶段。 根据Reconcile 阶段生成的数组， 遍历更新DOM， 这个阶段需要一次性执行完。（无法被打断） 如何打断任务Fiber的打断方式就是使用cancelIdleCallback方法取消掉回调 Fiber如何排列任务 利用双向链表， 按照任务的优先级设定任务的过期时间，然后根据任务的过期时间，插入到双向链表中 React Fiber 把更新过程碎片化， 每执行完一段更新过程， 就把控制权交还给React 负责仍无协调的模块， 看看有没有其他紧急任务要做， 如果没有就继续去更新， 如果由紧急任务， 那就去做紧急任务。Fiber分为2个阶段， 第一阶段Reconciliation Phase( componentWillMount、componentWillReceiveProps、 shouldComponentUpdate、componentWillUpdate) 第二阶段Commit Phase(componentDidMount、componentDidUpdate、componentWillUnmount )第一阶段可能会被打断， 也就意味着第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！ getDerivedStateFromProps在处在Render Phase阶段， 每次的更新都要触发。这个生命周期是纯函数、静态方法为了隔离实例(禁止this.refs等)单纯且高效， getSnapshotBeforeUpdate到了commit 阶段，因此这个函数只会运行一次 概述Fiber原理Fiber 核心思想是渲染和js执行之间的调度, 为了在进行复杂的js代码时不阻碍到用户体验, 比如React 在执行某些代码时, input 的框没有办法在用户执行时及时的做出响应, 这就会让用户觉得这个网页卡死了!, Fiber 就是为了解决这个问题而生的 Fiber 可以说是参考了操作系统管理进程的方式, 分时调度, 给每个进程一定的执行时间来回切换, 而Fiber 是让js任务与浏览器渲染之间来回切换, 以防止出现无响应的情况. 那Fiber 会如何做呢: 首先, Fiber 会模拟一个requestIdleCallback 方法, 是利用requestAnimationFrame 实现的polyfill 方法, 利用该方法回调中接收的参数来判定每一帧留下的空闲期, 然后给每一个任务都判定级别, 轻重缓急, 如下 12345var ImmediatePriority = 1;var UserBlockingPriority = 2;var NormalPriority = 3;var LowPriority = 4;var IdlePriority = 5; 每个优先级都对应着不一样的 deadline(超时时间): 12345678910// Times out immediatelyvar IMMEDIATE_PRIORITY_TIMEOUT = -1;// Eventually times out// 250ms以后过期var USER_BLOCKING_PRIORITY = 250;var NORMAL_PRIORITY_TIMEOUT = 5000;var LOW_PRIORITY_TIMEOUT = 10000;// Never times out// 永不过期 - 为什么是12天， 因为v8整数上限var IDLE_PRIORITY = maxSigned31BitInt; 规定好每个不同优先级任务的 超时时间后, 我们就可以对每个任务进行排队了, 那如何排队最灵活呢? 首先Fiber 会构建一个 循环双向链 , 将每个任务都作为一个节点, 并根据超时时间作为排序的依据, 每当有新任务进入时, 从头挨个对比每个节点, 直至遇到超时时间大于该任务自身的节点, 将其插入到该位置, 如果整个链表中都没有找到超时时间大于该任务的节点, 那么就他就作为了链表的末尾节点, 并将 Next 指向链表的首节点. 又或者,如果首节点就符合条件, 那该节点就转而变成了首节点 Fiber对浏览器的帧率有个最低下限的取值, 也就是33 ( 根据每秒30帧得出 ), 但是这个值也并不是写死的, 它会去跑两次方法尝试计算, 如果两次计算所花费的时间小于这个值, 也就是用两次测试来判断浏览器性能, 如果浏览器性能超出预期, 那么就会使用着两次计算结果的最大值. 这是Fiber在进行动态的压帧. 根据性能提供最优的时间. 优先次序排列好了, 执行间隔也确定了, 那剩下的事情就是执行了, 执行呢就是我们刚刚说的, 利用requestAnimationFrame 计算出每一帧的空档期, 这里需要注意, Fiber 还留有一手备用, 那就是 setTimeout. 为什么要使用setTimeout 呢, 这是因为, requestAnimationFrame有个致命的问题, 当用户切换浏览器tab页以后, requestAnimationFrame 就会停止执行, 所以Fiber就会转而切换至使用setTimeout 代替. 并且在 requestAnimationFrame 执行时打断了 setTimeout , 在setTimeout 执行时打断了requestAnimationFrame 1234567891011121314var requestAnimationFrameWithTimeout = function(callback) &#123; // schedule rAF and also a setTimeout rAFID = localRequestAnimationFrame(function(timestamp) &#123; //每一次系统执行的performance.now 默认间隔是16.7 // cancel the setTimeout localClearTimeout(rAFTimeoutID); callback(timestamp); &#125;); rAFTimeoutID = localSetTimeout(function() &#123; // cancel the requestAnimationFrame localCancelAnimationFrame(rAFID); callback(exports.unstable_now()); &#125;, ANIMATION_FRAME_TIMEOUT);&#125;; Fiber在每一帧的具体执行期间,会尽可能多的执行任务, 也就是说一个任务执行完如果时间还没到还会再找下一个任务, 并使用MessageChannel来进行分配任务, 并且有时候会有浏览器渲染任务较重时,如重排, 导致了占用时间超时, 那么Fiber会强制执行以超时的那些任务, 因为这些任务实在不能再拖了, 再拖下去,整个程序就废了, 所以必须现在执行完毕, 执行完的任务就会退出链表, 当本次查找到的超时任务都执行完毕后, Fiber 又会再去遍历一遍链表看看还有没有新的超时任务, 如果有那就接着执行掉, 执行完了同理, 又去再查找一遍, 一直重复, 直至没有超时任务了, 然后让出线程让浏览器渲染. 到这里就是Fiber 调度的主要原理, 写的很糙, 可能直有我自己能看懂了 Fiber 源码 + 注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816/** @license React v0.13.6 * scheduler.development.js * * Copyright (c) Facebook, Inc. and its affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. *//** * 老袁解析react fiber * 1.获取当前系统的开始时间 * 2.设置任务的优先级 * 3.根据优先级别设置对应的过期时间 * 4.根据过期时间进行双向链表的排序 * 5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled * 6.按照每一帧之后的空闲开始进行更新 requestAnimationFrameWithTimeout * 7.animationTick是线索 计算帧过期时间并压缩帧 * 8.配合MessageChannel进行具体的调度任务 * 9.prevScheduledCallback == flushWork最终执行调度 * 原则：有过期的执行全部过期 没过期尽可能多的执行 * 剩下没执行完轮回到5 如果插入了高优先级的立即执行 * */"use strict";if (process.env.NODE_ENV !== "production") &#123; (function() &#123; "use strict"; Object.defineProperty(exports, "__esModule", &#123; value: true &#125;); var enableSchedulerDebugging = false; /* eslint-disable no-var */ // TODO: Use symbols? //yideng 2.设置任务的优先级 var ImmediatePriority = 1; var UserBlockingPriority = 2; var NormalPriority = 3; var LowPriority = 4; var IdlePriority = 5; // var ImmediatePriority = 1; //最高优先级 // var UserBlockingPriority = 2; //用户阻塞型优先级 // var NormalPriority = 3; //普通优先级 // var LowPriority = 4; // 低优先级 // var IdlePriority = 5; // 空闲优先级 //==========接下来是对五种优先级别设置的五个过期时间============= // Max 31 bit integer. The max integer size in V8 for 32-bit systems. // Math.pow(2, 30) - 1 // 0b111111111111111111111111111111 //3.根据优先级别设置对应的过期时间 //32位系统V8引擎里最大的整数 据粗略计算这个时间大概是12.427天 //tab页开着12天才会过期 var maxSigned31BitInt = 1073741823; // 立马过期 ==&gt; ImmediatePriority // Times out immediately var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out // 250ms以后过期 var USER_BLOCKING_PRIORITY = 250; var NORMAL_PRIORITY_TIMEOUT = 5000; var LOW_PRIORITY_TIMEOUT = 10000; // Never times out // 永不过期 - 为什么是12天， 因为v8整数上限 var IDLE_PRIORITY = maxSigned31BitInt; /*每个任务在添加到链表里的时候，都会通过 performance.now() + timeout 来得出这个任务的过期时间，随着时间的推移，当前时间会越来越接近这个过期时间， 所以过期时间越小的代表优先级越高。如果过期时间已经比当前时间小了， 说明这个任务已经过期了还没执行，需要立马去执行(asap)。*/ // Callbacks are stored as a circular, doubly linked list. //第一个任务节点 var firstCallbackNode = null; var currentDidTimeout = false; // Pausing the scheduler is useful for debugging. var isSchedulerPaused = false; var currentPriorityLevel = NormalPriority; var currentEventStartTime = -1; var currentExpirationTime = -1; // This is set when a callback is being executed, to prevent re-entrancy. var isExecutingCallback = false; var isHostCallbackScheduled = false; //yideng 1.获取当前系统的开始时间-performance.now var hasNativePerformanceNow = typeof performance === "object" &amp;&amp; typeof performance.now === "function"; function ensureHostCallbackIsScheduled() &#123; if (isExecutingCallback) &#123; // Don't schedule work yet; wait until the next time we yield. return; &#125; // Schedule the host callback using the earliest expiration in the list. var expirationTime = firstCallbackNode.expirationTime; // 加锁 if (!isHostCallbackScheduled) &#123; isHostCallbackScheduled = true; &#125; else &#123; // Cancel the existing host callback. cancelHostCallback(); &#125; requestHostCallback(flushWork, expirationTime); &#125; function flushFirstCallback() &#123; var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the // list is in a consistent state even if the callback throws. var next = firstCallbackNode.next; if (firstCallbackNode === next) &#123; // This is the last callback in the list. firstCallbackNode = null; next = null; &#125; else &#123; var lastCallbackNode = firstCallbackNode.previous; firstCallbackNode = lastCallbackNode.next = next; next.previous = lastCallbackNode; &#125; flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback. var callback = flushedNode.callback; var expirationTime = flushedNode.expirationTime; var priorityLevel = flushedNode.priorityLevel; var previousPriorityLevel = currentPriorityLevel; var previousExpirationTime = currentExpirationTime; currentPriorityLevel = priorityLevel; currentExpirationTime = expirationTime; var continuationCallback; try &#123; continuationCallback = callback(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentExpirationTime = previousExpirationTime; &#125; // A callback may return a continuation. The continuation should be scheduled // with the same priority and expiration as the just-finished callback. if (typeof continuationCallback === "function") &#123; var continuationNode = &#123; callback: continuationCallback, priorityLevel: priorityLevel, expirationTime: expirationTime, next: null, previous: null &#125;; // Insert the new callback into the list, sorted by its expiration. This is // almost the same as the code in `scheduleCallback`, except the callback // is inserted into the list *before* callbacks of equal expiration instead // of after. if (firstCallbackNode === null) &#123; // This is the first callback in the list. firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode; &#125; else &#123; var nextAfterContinuation = null; var node = firstCallbackNode; do &#123; if (node.expirationTime &gt;= expirationTime) &#123; // This callback expires at or after the continuation. We will insert // the continuation *before* this callback. nextAfterContinuation = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); if (nextAfterContinuation === null) &#123; // No equal or lower priority callback was found, which means the new // callback is the lowest priority callback in the list. nextAfterContinuation = firstCallbackNode; &#125; else if (nextAfterContinuation === firstCallbackNode) &#123; // The new callback is the highest priority callback in the list. firstCallbackNode = continuationNode; ensureHostCallbackIsScheduled(); &#125; var previous = nextAfterContinuation.previous; previous.next = nextAfterContinuation.previous = continuationNode; continuationNode.next = nextAfterContinuation; continuationNode.previous = previous; &#125; &#125; &#125; function flushImmediateWork() &#123; if ( // Confirm we've exited the outer most event handler currentEventStartTime === -1 &amp;&amp; firstCallbackNode !== null &amp;&amp; firstCallbackNode.priorityLevel === ImmediatePriority ) &#123; isExecutingCallback = true; try &#123; do &#123; flushFirstCallback(); &#125; while ( // Keep flushing until there are no more immediate callbacks firstCallbackNode !== null &amp;&amp; firstCallbackNode.priorityLevel === ImmediatePriority ); &#125; finally &#123; isExecutingCallback = false; if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(); &#125; else &#123; isHostCallbackScheduled = false; &#125; &#125; &#125; &#125; function flushWork(didTimeout) &#123; // Exit right away if we're currently paused if (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123; return; &#125; isExecutingCallback = true; var previousDidTimeout = currentDidTimeout; currentDidTimeout = didTimeout; try &#123; //如果是任务过期了 赶紧排队把过期的任务给执行了 if (didTimeout) &#123; // Flush all the expired callbacks without yielding. while ( firstCallbackNode !== null &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ) &#123; // TODO Wrap in feature flag // Read the current time. Flush all the callbacks that expire at or // earlier than that time. Then read the current time again and repeat. // This optimizes for as few performance.now calls as possible. var currentTime = exports.unstable_now(); if (firstCallbackNode.expirationTime &lt;= currentTime) &#123; do &#123; flushFirstCallback(); &#125; while ( firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ); continue; &#125; break; &#125; &#125; else &#123; //当前帧有富余时间，while的逻辑是只要有任务且当前帧没过期就去执行任务。 //执行队首任务，把队首任务从链表移除，并把第二个任务置为队首任务。执行任务可能产生新的任务，再把新任务插入到任务链表 // Keep flushing callbacks until we run out of time in the frame. if (firstCallbackNode !== null) &#123; do &#123; if (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123; break; &#125; flushFirstCallback(); //shouldYieldToHost代表当前帧过期了，取反的话就是没过期。 &#125; while (firstCallbackNode !== null &amp;&amp; !shouldYieldToHost()); &#125; &#125; &#125; finally &#123; isExecutingCallback = false; currentDidTimeout = previousDidTimeout; //最后，如果还有任务的话，再启动一轮新的任务执行调度 if (firstCallbackNode !== null) &#123; // There's still work remaining. Request another callback. ensureHostCallbackIsScheduled(); &#125; else &#123; isHostCallbackScheduled = false; &#125; // Before exiting, flush all the immediate work that was scheduled. //最最后，如果还有任务且有最高优先级的任务，就都执行一遍。 flushImmediateWork(); &#125; &#125; function unstable_runWithPriority(priorityLevel, eventHandler) &#123; switch (priorityLevel) &#123; case ImmediatePriority: case UserBlockingPriority: case NormalPriority: case LowPriority: case IdlePriority: break; default: priorityLevel = NormalPriority; &#125; var previousPriorityLevel = currentPriorityLevel; var previousEventStartTime = currentEventStartTime; currentPriorityLevel = priorityLevel; currentEventStartTime = exports.unstable_now(); try &#123; return eventHandler(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled. flushImmediateWork(); &#125; &#125; function unstable_next(eventHandler) &#123; var priorityLevel = void 0; switch (currentPriorityLevel) &#123; case ImmediatePriority: case UserBlockingPriority: case NormalPriority: // Shift down to normal priority priorityLevel = NormalPriority; break; default: // Anything lower than normal priority should remain at the current level. priorityLevel = currentPriorityLevel; break; &#125; var previousPriorityLevel = currentPriorityLevel; var previousEventStartTime = currentEventStartTime; currentPriorityLevel = priorityLevel; currentEventStartTime = exports.unstable_now(); try &#123; return eventHandler(); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled. flushImmediateWork(); &#125; &#125; function unstable_wrapCallback(callback) &#123; var parentPriorityLevel = currentPriorityLevel; return function() &#123; // This is a fork of runWithPriority, inlined for performance. var previousPriorityLevel = currentPriorityLevel; var previousEventStartTime = currentEventStartTime; currentPriorityLevel = parentPriorityLevel; currentEventStartTime = exports.unstable_now(); try &#123; return callback.apply(this, arguments); &#125; finally &#123; currentPriorityLevel = previousPriorityLevel; currentEventStartTime = previousEventStartTime; flushImmediateWork(); &#125; &#125;; &#125; //yideng 4.根据过期时间进行双向链表的排序 function unstable_scheduleCallback(callback, deprecated_options) &#123; var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now(); var expirationTime; if ( typeof deprecated_options === "object" &amp;&amp; deprecated_options !== null &amp;&amp; typeof deprecated_options.timeout === "number" ) &#123; // FIXME: Remove this branch once we lift expiration times out of React. //如果没有传递过去时间的话直接按照默认的传递 expirationTime = startTime + deprecated_options.timeout; &#125; else &#123; switch (currentPriorityLevel) &#123; case ImmediatePriority: expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT; break; case UserBlockingPriority: expirationTime = startTime + USER_BLOCKING_PRIORITY; break; case IdlePriority: expirationTime = startTime + IDLE_PRIORITY; break; case LowPriority: expirationTime = startTime + LOW_PRIORITY_TIMEOUT; break; case NormalPriority: default: expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT; &#125; &#125; //yideng 双向的链表 var newNode = &#123; callback: callback, //任务具体的内容 priorityLevel: currentPriorityLevel, //任务优先级 expirationTime: expirationTime, //任务的过期时间 next: null, //下一个节点 previous: null //上一个节点 &#125;; // Insert the new callback into the list, ordered first by expiration, then // by insertion. So the new callback is inserted any other callback with // equal expiration. //yideng仿照之前的双向节点的例子 插入指定节点 if (firstCallbackNode === null) &#123; // This is the first callback in the list. firstCallbackNode = newNode.next = newNode.previous = newNode; //排完顺序之后按照指定的规则执行任务 //那么什么是合适的时间呢？也就是之前讨论过的每一帧绘制完成之后的空闲时间 //5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled ensureHostCallbackIsScheduled(); &#125; else &#123; // 一直查找链表, 直至某个节点的next === firtNode var next = null; var node = firstCallbackNode; do &#123; // 对比过期时间 if (node.expirationTime &gt; expirationTime) &#123; // 如果当前节点的过期时间 比 新来的callback 过期时间要晚 , 则将next指向当前的节点 // The new callback expires before this one. next = node; break; &#125; node = node.next; &#125; while (node !== firstCallbackNode); // next === null 就表示始终未找到某个节点比新来的回调过期时间要晚, 这就表示他是最晚的, 他是链表的末尾, 所以把他的next指向首节点 if (next === null) &#123; // No callback with a later expiration was found, which means the new // callback has the latest expiration in the list. next = firstCallbackNode; // next === firstCallbackNode 表示找到符合条件的节点， 但是该节点是首节点， 这就表示 新的回调 比 firtCallbackNode 的优先级还要高的话， 就将他作为 &#125; else if (next === firstCallbackNode) &#123; // The new callback has the earliest expiration in the entire list. firstCallbackNode = newNode; ensureHostCallbackIsScheduled(); &#125; var previous = next.previous; previous.next = next.previous = newNode; newNode.next = next; newNode.previous = previous; &#125; return newNode; &#125; function unstable_pauseExecution() &#123; isSchedulerPaused = true; &#125; function unstable_continueExecution() &#123; isSchedulerPaused = false; if (firstCallbackNode !== null) &#123; ensureHostCallbackIsScheduled(); &#125; &#125; function unstable_getFirstCallbackNode() &#123; return firstCallbackNode; &#125; function unstable_cancelCallback(callbackNode) &#123; var next = callbackNode.next; if (next === null) &#123; // Already cancelled. return; &#125; if (next === callbackNode) &#123; // This is the only scheduled callback. Clear the list. firstCallbackNode = null; &#125; else &#123; // Remove the callback from its position in the list. if (callbackNode === firstCallbackNode) &#123; firstCallbackNode = next; &#125; var previous = callbackNode.previous; previous.next = next; next.previous = previous; &#125; callbackNode.next = callbackNode.previous = null; &#125; function unstable_getCurrentPriorityLevel() &#123; return currentPriorityLevel; &#125; function unstable_shouldYield() &#123; return ( !currentDidTimeout &amp;&amp; ((firstCallbackNode !== null &amp;&amp; firstCallbackNode.expirationTime &lt; currentExpirationTime) || shouldYieldToHost()) ); &#125; // The remaining code is essentially a polyfill for requestIdleCallback. It // works by scheduling a requestAnimationFrame, storing the time for the start // of the frame, then scheduling a postMessage which gets scheduled after paint. // Within the postMessage handler do as much work as possible until time + frame // rate. By separating the idle call into a separate event tick we ensure that // layout, paint and other browser work is counted against the available time. // The frame rate is dynamically adjusted. // We capture a local reference to any global, in case it gets polyfilled after // this module is initially evaluated. We want to be using a // consistent implementation. var localDate = Date; // This initialization code may run even on server environments if a component // just imports ReactDOM (e.g. for findDOMNode). Some environments might not // have setTimeout or clearTimeout. However, we always expect them to be defined // on the client. https://github.com/facebook/react/pull/13088 var localSetTimeout = typeof setTimeout === "function" ? setTimeout : undefined; var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined, but we will error // later if they are missing on the client. var localRequestAnimationFrame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : undefined; var localCancelAnimationFrame = typeof cancelAnimationFrame === "function" ? cancelAnimationFrame : undefined; // requestAnimationFrame does not run when the tab is in the background. If // we're backgrounded we prefer for that work to happen so that the page // continues to load in the background. So we also schedule a 'setTimeout' as // a fallback. // TODO: Need a better heuristic for backgrounded work. // ↑这句话表示，使用setTimeout 也是无奈之举， 之后会更优化， 当下是迫于浏览器不支持 var ANIMATION_FRAME_TIMEOUT = 100; var rAFID; var rAFTimeoutID; //yideng 如果tab不激活的话 使用SetTimeout进行处理 如果正常情况直接干掉timeout //6.按照每一帧之后的空闲开始进行更新requestAnimationFrameWithTimeout // // 这里又使用了 setTimeout 又使用了RequestAnimationFrame 并且还互相清除， // 是因为 RequestAnimationFrame 有一个落点， 就是当浏览器切到其他tab页的时候会暂停执行 var requestAnimationFrameWithTimeout = function(callback) &#123; // schedule rAF and also a setTimeout rAFID = localRequestAnimationFrame(function(timestamp) &#123; //每一次系统执行的performance.now 默认间隔是16.7 // cancel the setTimeout localClearTimeout(rAFTimeoutID); callback(timestamp); &#125;); rAFTimeoutID = localSetTimeout(function() &#123; // cancel the requestAnimationFrame localCancelAnimationFrame(rAFID); callback(exports.unstable_now()); &#125;, ANIMATION_FRAME_TIMEOUT); &#125;; if (hasNativePerformanceNow) &#123; var Performance = performance; exports.unstable_now = function() &#123; return Performance.now(); &#125;; &#125; else &#123; exports.unstable_now = function() &#123; return localDate.now(); &#125;; &#125; var requestHostCallback; var cancelHostCallback; var shouldYieldToHost; var globalValue = null; if (typeof window !== "undefined") &#123; globalValue = window; &#125; else if (typeof global !== "undefined") &#123; globalValue = global; &#125; if (globalValue &amp;&amp; globalValue._schedMock) &#123; // Dynamic injection, only for testing purposes. var globalImpl = globalValue._schedMock; requestHostCallback = globalImpl[0]; cancelHostCallback = globalImpl[1]; shouldYieldToHost = globalImpl[2]; exports.unstable_now = globalImpl[3]; &#125; else if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive // implementation using setTimeout. typeof window === "undefined" || // Check if MessageChannel is supported, too. typeof MessageChannel !== "function" ) &#123; // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore, // fallback to a naive implementation. var _callback = null; var _flushCallback = function(didTimeout) &#123; if (_callback !== null) &#123; try &#123; _callback(didTimeout); &#125; finally &#123; _callback = null; &#125; &#125; &#125;; requestHostCallback = function(cb, ms) &#123; if (_callback !== null) &#123; // Protect against re-entrancy. setTimeout(requestHostCallback, 0, cb); &#125; else &#123; _callback = cb; setTimeout(_flushCallback, 0, false); &#125; &#125;; cancelHostCallback = function() &#123; _callback = null; &#125;; shouldYieldToHost = function() &#123; return false; &#125;; &#125; else &#123; if (typeof console !== "undefined") &#123; // TODO: Remove fb.me link if (typeof localRequestAnimationFrame !== "function") &#123; console.error( "This browser doesn't support requestAnimationFrame. " + "Make sure that you load a " + "polyfill in older browsers. https://fb.me/react-polyfills" ); &#125; if (typeof localCancelAnimationFrame !== "function") &#123; console.error( "This browser doesn't support cancelAnimationFrame. " + "Make sure that you load a " + "polyfill in older browsers. https://fb.me/react-polyfills" ); &#125; &#125; var scheduledHostCallback = null; //代表任务链表的执行器 var isMessageEventScheduled = false; var timeoutTime = -1; //代表最高优先级任务firstCallbackNode的过期时间 var isAnimationFrameScheduled = false; var isFlushingHostCallback = false; var frameDeadline = 0; //代表一帧的过期时间，通过rAF回调入参t加上activeFrameTime来计算 // We start out assuming that we run at 30fps but then the heuristic tracking // will adjust this value to a faster fps if we get more frequent animation // frames. var previousFrameTime = 33; // 一帧的渲染时间33ms，这里假设 1s 30帧 var activeFrameTime = 33; shouldYieldToHost = function() &#123; return frameDeadline &lt;= exports.unstable_now(); &#125;; // We use the postMessage trick to defer idle work until after the repaint. //如下是整个的执行流程， //8.配合MessageChannel进行具体的调度任务 //8-1.在每一帧开始的rAF的回调里记录每一帧的开始时间，并计算每一帧的过期时间， //8-2.通过messageChannel发送消息。在帧末messageChannel的回调里接收消息， //8-3.根据当前帧的过期时间和当前时间进行比对来决定当前帧能否执行任务， //8-4.如果能的话会依次从任务链表里拿出队首任务来执行 //8-5.执行尽可能多的任务后如果还有任务，下一帧再重新调度。 var channel = new MessageChannel(); var port = channel.port2; //下面的代码逻辑决定当前帧要不要执行任务 // 1、如果当前帧没过期，说明当前帧有富余时间，可以执行任务 // 2、如果当前帧过期了，说明当前帧没有时间了，这里再看一下当前任务firstCallbackNode //是否过期，如果过期了也要执行任务；如果当前任务没过期，说明不着急，那就先不执行去 channel.port1.onmessage = function(event) &#123; isMessageEventScheduled = false; var prevScheduledCallback = scheduledHostCallback; var prevTimeoutTime = timeoutTime; scheduledHostCallback = null; timeoutTime = -1; var currentTime = exports.unstable_now(); var didTimeout = false; if (frameDeadline - currentTime &lt;= 0) &#123; // There's no time left in this idle period. Check if the callback has // a timeout and whether it's been exceeded. if (prevTimeoutTime !== -1 &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123; // Exceeded the timeout. Invoke the callback even though there's no // time left. //任务过期 didTimeout = true; &#125; else &#123; // No timeout. //当前帧由于浏览器渲染等原因过期了，那就去下一帧再处理 if (!isAnimationFrameScheduled) &#123; // Schedule another animation callback so we retry later. isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; // Exit without invoking the callback. scheduledHostCallback = prevScheduledCallback; timeoutTime = prevTimeoutTime; return; &#125; &#125; if (prevScheduledCallback !== null) &#123; isFlushingHostCallback = true; try &#123; prevScheduledCallback(didTimeout); &#125; finally &#123; isFlushingHostCallback = false; &#125; &#125; &#125;; //7.animationTick是线索 计算帧过期时间并压缩帧 var animationTick = function(rafTime) &#123; if (scheduledHostCallback !== null) &#123; //有任务再进行递归，没任务的话不需要工作 // Eagerly schedule the next animation callback at the beginning of the // frame. If the scheduler queue is not empty at the end of the frame, it // will continue flushing inside that callback. If the queue *is* empty, // then it will exit immediately. Posting the callback at the start of the // frame ensures it's fired within the earliest possible frame. If we // waited until the end of the frame to post the callback, we risk the // browser skipping a frame and not firing the callback until the frame // after that. requestAnimationFrameWithTimeout(animationTick); &#125; else &#123; // No pending work. Exit. isAnimationFrameScheduled = false; return; &#125; // rafTime 就是 requestAnimationFrame 回调接收的时间 var nextFrameTime = rafTime - frameDeadline + activeFrameTime; //用连续的两次时间 被不断的压缩activeFrameTime if ( nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime ) &#123; if (nextFrameTime &lt; 8) &#123; // Defensive coding. We don't support higher frame rates than 120hz. // If the calculated frame time gets lower than 8, it is probably a bug. nextFrameTime = 8; &#125; // If one frame goes long, then the next one can be short to catch up. // If two frames are short in a row, then that's an indication that we // actually have a higher frame rate than what we're currently optimizing. // We adjust our heuristic dynamically accordingly. For example, if we're // running on 120hz display or 90hz VR display. // Take the max of the two in case one of them was an anomaly due to // missed frame deadlines. activeFrameTime = nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime; &#125; else &#123; previousFrameTime = nextFrameTime; &#125; //计算当前帧的截止时间，用开始时间加上每一帧的渲染时间 frameDeadline = rafTime + activeFrameTime; if (!isMessageEventScheduled) &#123; isMessageEventScheduled = true; //port2 负责发送数据 //port2监听消息的回调来做任务调度的具体工作 port.postMessage(undefined); &#125; &#125;; // 接收两个参数， flushwork 和 过期时间 requestHostCallback = function(callback, absoluteTimeout) &#123; scheduledHostCallback = callback; // 过期时间 timeoutTime = absoluteTimeout; if (isFlushingHostCallback || absoluteTimeout &lt; 0) &#123; // Don't wait for the next frame. Continue working ASAP, in a new event. port.postMessage(undefined); &#125; else if (!isAnimationFrameScheduled) &#123; // If rAF didn't already schedule one, we need to schedule a frame. // TODO: If this rAF doesn't materialize because the browser throttles, we // might want to still have setTimeout trigger rIC as a backup to ensure // that we keep performing work. isAnimationFrameScheduled = true; requestAnimationFrameWithTimeout(animationTick); &#125; &#125;; cancelHostCallback = function() &#123; scheduledHostCallback = null; isMessageEventScheduled = false; timeoutTime = -1; &#125;; &#125; exports.unstable_ImmediatePriority = ImmediatePriority; exports.unstable_UserBlockingPriority = UserBlockingPriority; exports.unstable_NormalPriority = NormalPriority; exports.unstable_IdlePriority = IdlePriority; exports.unstable_LowPriority = LowPriority; exports.unstable_runWithPriority = unstable_runWithPriority; exports.unstable_next = unstable_next; exports.unstable_scheduleCallback = unstable_scheduleCallback; exports.unstable_cancelCallback = unstable_cancelCallback; exports.unstable_wrapCallback = unstable_wrapCallback; exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel; exports.unstable_shouldYield = unstable_shouldYield; exports.unstable_continueExecution = unstable_continueExecution; exports.unstable_pauseExecution = unstable_pauseExecution; exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode; &#125;)();&#125; 双向链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1.双向链表是指每个节点有previous和next两个属性来分别指向前后两个节点。// 2.循环的意思是，最后一个节点的next指向第一个节点，// 下面假设有一群人需要按照年龄进行排队，小孩站前边，大人站后边。// 在一个过程内会不断有人过来，我们需要把他插到正确的位置。删除的话只考虑每次把排头的人给去掉。//person的类型定义interface Person &#123; name: string; //姓名 age: number; //年龄，依赖这个属性排序 next: Person; //紧跟在后面的人,默认是null previous: Person; //前面相邻的那个人,默认是null&#125;var firstNode = null; //一开始链表里没有节点//插入的逻辑function insertByAge(newPerson: Person) &#123; if ((firstNode = null)) &#123; //如果 firstNode为空，说明newPerson是第一个人， //把它赋值给firstNode，并把next和previous属性指向自身，自成一个环。 firstNode = newPerson.next = newPerson.previous = newPerson; &#125; else &#123; //队伍里有人了，新来的人要找准自己的位置 var next = null; //记录newPerson插入到哪个人前边 var person = firstNode; // person 在下边的循环中会从第一个人开始往后找 do &#123; if (person.age &gt; newPerson.age) &#123; //如果person的年龄比新来的人大，说明新来的人找到位置了，他恰好要排在person的前边，结束 next = person; break; &#125; //继续找后面的人 node = node.next; &#125; while (node !== firstNode); //这里的while是为了防止无限循环，毕竟是环形的结构 if (next === null) &#123; //找了一圈发现 没有person的age比newPerson大，说明newPerson应该放到队伍的最后,也就是说newPerson的后面应该是firstNode。 next = firstNode; &#125; else if (next === firstNode) &#123; //找第一个的时候就找到next了，说明newPerson要放到firstNode前面，这时候firstNode就要更新为newPerson firstNode = newPerson; &#125; //下面是newPerson的插入操作，给next及previous两个人的前后链接都关联到newPerson var previous = next.previous; previous.next = next.previous = newPerson; newPerson.next = next; newPerson.previous = previous; &#125; //插入成功&#125;//删除第一个节点function deleteFirstPerson() &#123; if (firstNode === null) return; //队伍里没有人，返回 var next = firstNode.next; //第二个人 if (firstNode === next) &#123; //这时候只有一个人 firstNode = null; next = null; &#125; else &#123; var lastPerson = firstNode.previous; //找到最后一个人 firstNode = lastPerson.next = next; //更新新的第一人 next.previout = lastPerson; //并在新的第一人和最后一人之间建立连接 &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Fiber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】理解Dom-diff]]></title>
    <url>%2F2019%2F06%2F23%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%90%86%E8%A7%A3Dom-diff%2F</url>
    <content type="text"><![CDATA[算法复杂度比较两棵DOM树的差异是 Virtual Dom 算法最核心的部分， 这也是所谓的Virtual Dom的 diff算法。 两个树的完全的diff算法是一个时间复杂度为 O（n^3） 的问题。 但是在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 下面的div指挥和同一层级的div对比， 第二层级的智慧跟第二层级对比。 这样算法复杂度就可以达到O(n)。 对比方式实际的代码中， 会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记， 在深度优先遍历的时候， 每遍历到一个节点就把该节点和新的树进行对比。 如果有差异的话就记录到一个对象里面。 实践一下所谓的dom-diff 抛去具体的dom处理逻辑， 其核心思想还是比较简单的， 其实就是一个深度优先遍历。 我们就来尝试实现一下一个简单的dom-diff 首先 模拟dom结构以面向对象的编程方式， 构建出一个dom节点所必要的属性 1234567class Element &#123; constructor(type, props, children) &#123; this.type = type this.props = props this.children = children &#125;&#125; 然后我们再实现一个创建虚拟dom节点的快捷方式 123function createElement (type, props, children) &#123; return new Element(type, props, children)&#125; 既然有了创建方法， 那现在就可以试着创建几个dom了，123456789101112131415let virtualDom1 = createElement("ul", &#123; class: "list"&#125;, [ createElement("li", &#123; class: "item"&#125;, ["1"]), createElement("li", &#123; class: "item"&#125;, ["2"]), createElement("li", &#123; class: "item"&#125;, ["3"])])let virtualDom2 = createElement("ul", &#123; class: "list-new"&#125;, [ createElement("li", &#123; class: "item"&#125;, ["a"]), createElement("li", &#123; class: "item"&#125;, ["444"]), createElement("li", &#123; class: "item"&#125;, ["c"])]) 这是两串模拟ul &gt; li的代码， 相信聪明的你可以看的出来 对比差异既然构建好了简单的虚拟dom， 接下来要做的无非就是比对了 在对比差异的过程中， 我们还要记录最终的差异结果， 把当前修复批次记录下来， 用于之后同一处理 开始比对之前， 我们要先搞清楚整体的逻辑， 我们应该比对哪些差异？ 标签类型的差异， 有可能是p， 有可能是div， 还有可能是纯文本 dom的属性改变了 ， 有可能是class变了， 有可能是自定义属性变了 dom的内容改变了， 这就是最基本的变化了， dom的内容发生了改变 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import _ from './util.js'// 生成的补丁包let patchs = &#123;&#125;// 记录let globalIndex = 0// dom-diff的主要入口函数function diff(oldTree, newTree) &#123; dfswalk(oldTree, newTree, globalIndex) return patchs&#125;// 深度优先遍历 -- 递归function dfswalk(oldTree, newTree, globalIndex)&#123; // 记录当前批次的修改队列 let currentPatchs = [] // 如果旧节点是文本 if( _.isString(oldTree) ) &#123; // 如果新树也是字符串 并且 但是不和新树相同 if(_.isString(newTree) &amp;&amp; oldTree !== newTree) &#123; // 将当前的更改追加入当前需要修改的队列中 currentPatchs.push(&#123; type: "TEXT", text: newTree &#125;) &#125; // 如果类型相同的 &#125; else if( oldTree.type === newTree.type ) &#123; // 调用对比属性的函数 diffProps(oldTree.props, newTree.props) // 比节点 =&gt; 尾调用优化 diffChildren(oldTree.children, newTree.children) &#125; // 如果本次检测到了修改 把每一次diff的结果放到patchs if(currentPatchs.length &gt; 0) &#123; // 记录到对应的节点上sdcxz patchs[globalIndex] = currentPatchs &#125;&#125;// 对比两个dom的 属性function diffProps() &#123; // 对比props&#125;// 负责循环新旧domde的子节点， 以旧节点的索引去匹配去匹配相应位置的新节点function diffChildren(oldChildrens, newChildrens) &#123; // 遍历旧dom ,对比相同索引的新dom oldChildrens.forEach((child, index) =&gt; &#123; // 被循环后又去调用新旧dom的比对 dfswalk(child, newChildrens[index], ++globalIndex) &#125;)&#125;export &#123; diff&#125; Vue 对dom-diff的优化vue 在对比 oldTree 和 newTree 时会分别给新旧树的对比中会分配两个指针，分别是oldStart、oldEnd 、 newStart、newEnd ， 然后 start 指针和 end 指针都会在每次对比后相互靠近， 直至相遇， 具体对比规则如下 先对比头头、 尾尾是否一致 对比头尾、 尾头， 如果相同，则头尾先互相拷贝插入， 然后删除旧的 如果 newStart 和 oldStart 相对比， newStart有但oldStart没有此节点， 则将 newStart 对应的节点插入至 oldStart节点的前面， 并且将 newStart指针前进一格， 而oldStart指针不动， 直至找到匹配 如果oldEnd 和 newEnd 不同时， 则将oldEnd 的元素先打上删除标记， 然后前进一格， newEnd 元素则停留在原处，直至找到匹配 对比阶段， 对比类型， 如果类型不同就直接放弃没必要继续对比了 最终start 与 end 交汇后， 遍历一遍 oldTree ,将标记为删除的节点删除掉 Vue 为什么需要key首先， 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。 并且， diff算法就可以快速切正确的找到此节点， 找到正确的位置插入新的节点， 降低节点查找时间， 当有插入节点需要时， 有Key 的话就可以 类似于索引访问的形式直达目标节点， 而不是遍历一遍所有节点来查找目标节点 利用key的小技巧它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用: 完整地触发组件的生命周期钩子触发过渡 123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 总结 key是为了降低diff时的节点查找复杂度， 并且如果节点的key都不相同或者是说key都变了，那就直接判定为dom发生变化， 渲染新的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DomDiff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【英语学习】基础语法]]></title>
    <url>%2F2019%2F06%2F22%2F%E3%80%90%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[英语语法分为： 句法部分 语法部分 句法部分十大词类、 两大句型、八大句子成分、主从句单复词 词类 名词、 动词、形容词、副词、数词、代词、语气词、感叹词、 介词、 连词 名词 事物的名称叫名词 万事万物–实体， 非实体都有其名 动词 动作的名称就叫动词 表示事物之间的变化或自身内在的变化的词就是动词。 形容词 形容名词的词， 叫形容词 名词太单调了， 需要形容词围绕名词进行各种修饰， 如形状、色彩、大小、美丑等。 副词 形容动词的词， 就叫副词 动词太单调了， 需要副词围绕动词进行各种修饰， 如描绘动作的程度、 频率、 方式、 时间等 数次 给名词计数的词， 就叫数词 分为基数词， 1、2、3、4、5 第1、第2、第3、第4、第5等 代词 代替名词的词就叫代词 如： 你、我、她、它、你们的、 我们的、他们的等等 介词 表示两个名词之间时空关系的词， 就叫介词 如 “鸡蛋在(in)篮子里” “鸡蛋在(on)桌子上” “鸡蛋在(under)桌子下” 冠词 特指或泛指某一名词事物的就叫冠词 如： a/an不定冠词， the 定冠词 连词 连接两个性质相同的词、 短句、 句子的词叫连词 叹词语气助词叫叹词 这十大词类又可以分为 名词类， 即以名词为核心的词类。 如： 名词、 代词、 形容词、 数词、 冠词、介词 和动词类: 如: 动词、 副词 动词原形 动词原形是不含有时间信息也不含有状态信息的动词的本源， 是脱离了时空概念的动作本身。 下图中， 中间这个eat 就是动词原形 这就像一粒种子可以变换为4种状态 非谓语动词有状态但是没有时间 谓语动词有时间有状态 一句话解释: 如果以人作为比喻， 那么动词原形是受精卵， 非谓语动词是胎儿 动词原形只是个概念， 它不能出现于任何句子， 任何短语之中， 动词原形只能作为词典条目 动词有什么“态” 动词的“态”就是动作发展的“阶段” 动词原形穿上“态”这件衣服就成了非谓语动词 给非谓语动词穿上时态这件衣服 谓语动词英语的谓语动词， 第一个词一定表达时间， 最后一个词一定表达状态， 如:is eating， is就是时间， eating 就是状态 语法部分谓语动词的变化、 非谓语动词的变化 时态英语到底有多少种时态]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Node】了解koa源码]]></title>
    <url>%2F2019%2F06%2F16%2F%E3%80%90Node%E3%80%91%E4%BA%86%E8%A7%A3koa%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[想要查看源码， 首先我们1npm i Koa -S 打开node_modules， 找到koa目录下的application 文件， 我们可以看到平时使用的 app 及其相关方法就在这里, 删除了不必要的代码后， 我们看看简易版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798module.exports = class Application extends Emitter &#123; constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || 'development'; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125; listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args); &#125; toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]); &#125; inspect() &#123; return this.toJSON(); &#125; use(fn) &#123; this.middleware.push(fn); return this; &#125; callback() &#123; const fn = compose(this.middleware); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context; &#125; /** * Default error handler. * * @param &#123;Error&#125; err * @api private */ onerror(err) &#123; const msg = err.stack || err.toString(); console.error(msg.replace(/^/gm, ' ')); &#125;&#125;;function respond(ctx) &#123; const res = ctx.res; let body = ctx.body; const code = ctx.status; // body: json body = JSON.stringify(body); res.end(body);&#125; 灵魂部分12345678910111213141516171819202122232425262728293031function compose (middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') // 检测中间件类型 for (const fn of middleware) &#123; if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') &#125; return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) // 执行整这个函数 function dispatch (i) &#123; index = i // 取出当前中间件 let fn = middleware[i] // 如果索引跟中间件长度一样了,实际上就等于访问完了, fn是空, next 也是空, 这里应该是保证一下next 确实不存在 if (i === middleware.length) fn = next // 最后一个中间件没有 next 就熄火了 if (!fn) return Promise.resolve() try &#123; // fn 就是中间件, 中间件接收两个参数, context 和 Next return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; // 出错 return Promise.reject(err) &#125; &#125; &#125;&#125; 得出的一个整体结构就是1234567console.log(1) console.log(1) console.log(1) Promise.resolve() // 中间件全部执行完毕 console.log(1) console.log(1)console.log(1)]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>Koa</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】递归、尾递归与尾调用]]></title>
    <url>%2F2019%2F06%2F16%2F%E3%80%90JS%E3%80%91%E9%80%92%E5%BD%92%E3%80%81%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[尾调用所谓的尾调用， 尾调用是我们平时实现递归操作的一种方式, 通过在函数末尾调用另一个函数， 来抹除上一个函数的堆栈记录， 可以理解为是一种任务承接的方式 demo:12345678910function f(index, total) &#123; if(index-- === 1) &#123; return total &#125; g(index, total + index)&#125;function g( index, total ) &#123; f( index, total )&#125; 尾递归尾递归和普通递归的区别就是， 尾递归的递归方式是在函数最后一步操作调用自身， 并将本轮计算结果以参数形式传入 demo:12345678function loop(index, total) &#123; if(index-- === 1) &#123; return total &#125; return loop(index, total + index)&#125;loop(100, 0) 尾调用优化在ES6中， 我们将迎来尾递归优化， 通过尾递归优化， javascript代码在解释成机器码的时候， 将会向while看齐， 也就是说， 同时拥有数学表达能力和while的效能。 ES6的“尾调用优化”的原理就是覆盖掉自身的函数执行记录， 也就是将递归变为循环， 只保存一个调用记录，这样就不会发生爆栈的情况了 浏览器的实现情况虽然是ES6的规范， 浏览器也实现了， 但实际上平时使用时“尾调用优化”是默认关闭的。 为什么！因为浏览器不敢开哦。 因为一旦开了尾调用优化， 就等于放弃了存留函数的堆栈信息， 当开发者调错时会十分困难， 找不到正确的堆栈信息， 当然可以利用js的元编程强行开启 其他避免爆栈手段 使用蹦床函数， 将递归拉平 直接将递归改写成循环 使用元编程强行开启浏览器的“尾递归优化”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>尾递归</tag>
        <tag>尾调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】什么是AO-VO]]></title>
    <url>%2F2019%2F06%2F10%2F%E3%80%90JS%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFAO-VO-GO%2F</url>
    <content type="text"><![CDATA[GO glbal Context 全局执行上下文 首先在js执行的时候会创建一个GO， 被压入 ESC Stack 栈底 EC execution 执行上下文 在每个函数执行的时候会创建一个EC（执行上下文） 在函数执行上下文中， 还会有两个东西被创建出来： AO、VO AO Activation Object 活动对象 AO是在函数执行的阶段 arguments的callee length 内部定义的函数 绑定对应环境变量 内部定义的变量 AO的阶段又可以细分为: 定义阶段 执行阶段 浏览器解析阶段这就是浏览器解析js的时候， 当v8拿到函数的时候， 都给你先编译成比较慢的字节码， 然后对字节码进行优化， 接着经过静态分析进行本地替换那些频繁使用到的字节码段， 替换成优化后的字节码，为什么不都进行优化， 因为优化后的字节码体积会比较大。 初始化阶段创建作用域链（Scope Chain）创建变量，函数和参数。定义this但不确认 让我们通过这段代码看一下AO的具体情况:12345678function test(a, b) &#123; var c = 10 function d() &#123;&#125; var e = function _e()&#123;&#125;; (function x() &#123;&#125;)&#125;test(10) 那此时这个 test 函数的AO情况如下 1234567891011121314EC(test) = &#123; // 自己维护的scopeChain 作用域链 scopeChain: &#123; Scope &#125;, // 指向下面的Scope // 预解析的原理 AO(test): &#123; a: 10, b: undefind, c: undefind, e: undefind &#125;, this: '先定义但不确认', Scope: [AO, glbalContext.vo]&#125; 执行阶段123456789101112131415161718EC(test) = &#123; scopeChain: &#123; Scope &#125;, // 预解析的原理 AO(test): &#123; arguments: &#123; 0: 11, 1: 22, length: 3 &#125;, a: 10, b: undefind, c: undefind, e: undefind &#125;, this: 'this指向函数执行栈栈顶', Scope: [AO, glbalContext.vo]&#125; VO Variable object 变量对象 每个函数都有自己的VO对象， 存储着这些 函数声明（不包含函数表达式） 函数的形参 变量的声明 总的来说篇， VO要比AO的范围大得多， VO是负责把各个调用的函数串联起来的。 他是外部的， 而AO是函数自身内部的 距离， 当执行 fun1:1VO(fun1) = AO // 执行到fun1 时可以在VO中的fun1就是此时的AO 又或者再举个例子，有这样一段代码要执行123456var a = 10function test(x) &#123; var b = 20 &#125;test(30) 此时我们来看一下VO的状态 123456789101112// VO中的 GO VO(globalContext) = &#123; a: 1, test: '&lt;reference to function&gt;'&#125;;// VO 中的 test函数VO(test) = &#123; x: 30, // 传入的参数 b: 20&#125; 上面的这些也就构成了 ECS Stack 函数执行栈 ESC Stack executions statck 执行上下文栈 很多个函数存在一起的时候会存在一个ESC Stack 所谓的 stack 它就是一个栈， 先进入 当js开始运行时就创建一个 globalContext 压入栈底， 也就是单体内置对象Global, 在浏览器中通常是 window 被压入栈的情况大致如下123ECStatck = [ globalContext] 当一段代码执行了好多函数时， 比如这样一段代码:12345678910function fun3() &#123;&#125;function fun2() &#123; fun3()&#125;function fun1() &#123; fun2()&#125;fun1() 实际入栈过程是这样的:123456ECStatck = [ fun3, fun2, fun1, globalContext] 当一个函数入栈， 它所属的变量也随之入栈， 当函数出栈， 变量也就跟着出栈了， 每个函数都会拥有各自的 EC（函数执行上下文）， 也就有各自的 AO、VO, 你肯定会疑惑闭包呢， 函数出栈了， 那闭包去哪了其实，js的闭包是存在堆里的， 跟普通函数不一样， 所以不会跟着出栈函数一起被回收]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js执行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】递归算法]]></title>
    <url>%2F2019%2F06%2F08%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[核心思想：通过重复将问题分解为同类的子问题而解决问题的方法。 特点： 函数可以通过调用自身来进行递归 递归可以完全取代循环 递归由下面两部分组成： （1）递归主体，就是要循环解决问题的代码 （2）递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】枚举算法基本概念]]></title>
    <url>%2F2019%2F06%2F08%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[核心思想：枚举所有的可能。 本质：就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件 (1)可预先确定候选答案的数量； (2)候选答案的范围在求解之前必须有一个确定的集合。 特点： 枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有的方法。 速度可能很慢，却是我们最应该优先考虑的。 实现最简单，并且得到的结果总是正确的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】什么是算法]]></title>
    <url>%2F2019%2F06%2F08%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法是完成某个特定任务的过程。 通常数据结构作为工具来辅助进行算法， 所以有了一个流传甚广的公式： 程序 = 数据结构 + 算法 算法不是数学， 但是可以用数学来描述 我们要做一件事情， 整个过程本身就是算法 我们最常用的增删改查是算法的一部分 算法可以用自然语言、 流程图、 伪代码和计算机语言等手段来表示 在面向对象语言中， 算法通常通过类的方法实现 算法的特征算法的五大特征： 有穷性： 算法必须能在执行有限个步骤后终止 确切性： 每一步骤必须由确切的定义 输入项： 有0个或多个输入， 用来规定初始情况， 所谓0 个输入是指算法本身定出了初始条件 输出项： 有一个或多个输出， 是对输入数据处理后的结果。 没有输出的算法毫无意义 可行性： 算法执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成（也称之为有效性。） 如何衡量算法的好坏 算法的好坏主要通过算法复杂度来衡量 时间复杂度 空间复杂度 正确性 可读性 健壮性 常见的复杂度 常数阶 O(1) 对数阶 O(logN) 线性阶 O(n) 线性对数阶 O(nlogN) 平方阶 O(n^2) 立方阶 O(n^3) k次方阶 O(n ^ k) 指数阶O(2 ^ n) 计算复杂度 logN 就是类似循环操作的逆运算，每次计算都将计算量减少一半 随着问题规模 n 的不断增加， 时间复杂度不断增大， 算法的执行效率越低 一般做算法复杂度分析的时候， 遵循下面的技巧: 有几重循环， 一般来说就是O(n), 两重就是O（n^2）, 依此类推 如果有二分， 则为O（logN） 保留最高项， 去除常数项 计算例子]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】什么是图]]></title>
    <url>%2F2019%2F06%2F08%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[由顶点的集合（不能是空集） 和边的集合组成的结构， 表现的是多对多的关系 数学基础是： 图论 几个基本概念： 顶点（在树里叫节点） 边 权 有向图和无向图]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】什么是树]]></title>
    <url>%2F2019%2F06%2F02%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树是由若干个有限节点组成的一个具有层次关系的集合 树的特点 数学基础是: 图论 一棵树中每两个点之间都有且只有一条路 一颗有N个点的树有N-1条边 结构与名称 像图中的圈我们称之为“节点”， 节点与节点之间的线称之为“边”， 最起始的节点叫“根” 一个节点下面的节点成为该节点的子节点， 该节点是其子节点的父节点 节点的层级用“深”来表示， 并且以0开始计数 当节点不再分叉时， 末尾的节点称为“叶子节点” 一个节点的子节点数量称为“度”， 如果一个节点有3个子节点， 那么它的度为3， 当度为0时就是叶子节点 一个节点到另一个节点之间的连线 称为“路径” 树和非树的典型 空树是指，有了树的结构， 但是还没有填充节点 树的遍历 树的遍历分为，两大类， 四小类 按照某种规则， 不重复地访问某种树的所有节点 先序遍历(深度优先) 中序遍历(深度优先) 后续遍历(深度优先) 层序遍历(广度优先) 先、 中、后都是针对的根节点来说的， 并且树是一种自相似的结构， 可以采用递归， 所以比较好记忆 1.先序遍历 左、中、右 优先访问根节点， 然后访问其左子树， 如果左子节点还有其左子节点， 再继续往下访问其左子节点， 直至没有， 然后访问其节点的父节点， 最后访问其父节点的右子节点， 就这样一层一层向上，直至根节点的整个左子树遍历完， 去对右子树做同样的操作 2. 中序遍历 中、左、右 优先访问左子树， 然后访问根节点， 最后访问右节点 3. 后序遍历 左、 右、 中 优先访问左子树、 然后访问右子树， 最后访问根节点 4. 层序遍历广度优先逐层访问节点， 直至该层没有， 然后再往下扎 树的衍生无序树: 树中任意节点的子节点之间没有顺序关系， 这种树称为无序树， 也称为自由树 有序树： 树中任意节点的子结点之间有顺序关系 二叉树： 每个节点最多含有两个子树的树称为二叉树 完全二叉树： 除了最后一层， 其他各层节点数都达到最大 满二叉树： 每一层上的节点数都是最大节点数 霍夫曼树： 带权路径最短的二叉树， 也叫最优二叉树 排序算法的复杂度与稳定性 关于查找算法]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】线性表之'串']]></title>
    <url>%2F2019%2F06%2F02%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[比如： 字符串、 字节流 串的概念字符串简称串，是一种特殊的线性表，它的数据元素仅由一个字符组成。 串的定义串(String)是由零个或多个字符组成的有限序列，又称字符串。 串的特殊在于， 在一个大的线性表中对一个小线性表操作]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【canvas】如何处理Retina屏模糊问题]]></title>
    <url>%2F2019%2F05%2F21%2F%E3%80%90canvas%E3%80%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Retina%E5%B1%8F%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[什么是Retina屏？所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto Aura上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。 canvas在Retina 屏幕模糊怎么办 DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。 利用获取设备的dpi, 将canvas 画布扩大至dpi的倍数， 然后将其缩小， 就可以得到清晰的canvas 效果]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】如何测试Js代码性能]]></title>
    <url>%2F2019%2F05%2F11%2F%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95Js%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[使用 benchmark.js 进行前端代码基准测试]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JS】V8引擎里for和forEach]]></title>
    <url>%2F2019%2F05%2F11%2F%E3%80%90JS%E3%80%91V8%E5%BC%95%E6%93%8E%E9%87%8Cfor%E5%92%8CforEach%2F</url>
    <content type="text"><![CDATA[一般是for 循环比较快, 但是V8中每个数组自带的方法一定程度上是对数组数量级的优化, 在一定数量的数据下, forEach 要优于 for 循环, 所以看场景选择吧, 具体请看v8源码]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】webpack + ts + antd 按需加载无效处理]]></title>
    <url>%2F2019%2F05%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91webpack-ts-antd-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%A0%E6%95%88%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[webpack加 babel 本来搭配 babel-plugin-import 可以实现插件的按需引入， 但是时代在变化啊， 现在流行ts 了， 你一定会想在你的项目中加入它， 你也一定会搜索到 ‘ts-loader’ 的种种， 但效果不尽如人意， 使用了’ts-loader’ 之后， 你会发现， 按需引入怎么配置都失败了， 于是你一定会尝试这样12345678&#123; test: /\.tsx?$/, exclude: /node_modules/, use: [ loader: &apos;babel-loader&apos;, loader: &apos;ts-loader&apos;, ]&#125; 先把ts 转成 es6, 然后用babel把ES6 转为 es5 但现在不是那种上古洪荒时代了， babel 统一添加， 让我们可以不需要在编译两轮了 在 babel 7 中，我们使用新的 @babel/preset-typescript (其集成了 @babel/plugin-transform-typescript) 我们的 .babelrc 配置将变成这样： 1234567&#123; &quot;presets&quot;: [ &quot;@babel/env&quot;, &quot;@babel/react&quot;, &quot;@babel/typescript&quot; ]&#125; 参考地址: https://github.com/frontend9/fe9-library/issues/23 https://www.jishuwen.com/d/2MbR/zh-tw]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】线性表之顺序表]]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[顺序表优点顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针 缺点但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的 并且当你需要在顺序表中插入数据时， 需要将插入目标位置后面的数据全部向后挪动， 这非常的耗费性能， 链表则不用， 只需要切换一下指针即可]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】线性表之链表]]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表如果按存储结构来分， 是属于链式存储结构 链表的每一项数据元素之间有衔接关系(圈起来要考) 链表的优势在于灵活，不受申请时的内存大小约束，链表插入数据， 只需要切换一下指针即可 链表链表分为： 单向链表 双向链表 单向链表链表在每一个数据元素中分为两个部分， 一个用来存储自身的数据， 另一部分存储下一项的指针（称为后继指针） 双向链表双向链表顾名思义， 就是支持两个方向的链表（前驱和后继）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】线性表之队列]]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列是一种被限制操作的线性表。 FIFO（First In First Out）， 遵循选入先出 用途：消息队列、视频弹幕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】什么是线性表]]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个地排列。 用来存放特定的某一个类型的元素 物理结构为顺序表和链表（链式结构） 关于存放特定类型元素的解释: Java等语言的泛型实际上也是在遵守这一规则， 因为他们的基类相同JS也是如此， 因为js万物皆对象， 存储时都会被一个容器给包裹了， 所以类型相同 顺序表与链表对比 顺序表: 不灵活，省内存 链表： 灵活， 多耗一点内存 顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针 但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的 线性表的衍生结构 可在本站中搜索 栈 队列 串]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】什么是集合]]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合数据结构中的集合关系就类似于数学中的集合。 集合中的数据成员是无序的。 每个数据成员在集合中不能重复，仅且只出现一次。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】线性表之'栈']]></title>
    <url>%2F2019%2F05%2F01%2F%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B'%E6%A0%88'%2F</url>
    <content type="text"><![CDATA[栈是一种被限制操作的线性表。 LIFO（Last In First Out），后入先出 用途： 解决括号匹配检查 浏览器的后退或编辑器的undo功能]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法基础学习笔记]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本概念 数据只要能被数字化就可以称为数据 数据对象可以完整的描述一件东西，通常是产生在内存中的文件， 链表、队列等都算数据对象 数据元素存在于数据对象中的一份一份的数据，就是数据元素 数据项用来描述某一特征的， 可以参考对象的属性， 但不完全相同 浅析数据结构数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的 逻辑结构：反映数据元素之间的逻辑关系。 存储结构：数据结构在计算机中的表示。 算法：对数据的操作 基本逻辑结构 内存与存储结构按照在内存中存储的方式来区分， 简单了解计一些算机中内存相关的知识： 内存的原理与构造。 地址、指针与引用。 存储结构与内存管理]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学基础入门]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【算法】二叉树学习笔记]]></title>
    <url>%2F2019%2F04%2F24%2F%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[树由边和节点组成 概念和用途 树是一种非线性的数据结构， 分层存储。 树被用来存储具有层级关系的数据， 还被用来存储有序列表。 二叉树进行查找特别快， 为二叉树添加或删除元素也也别快 集合中不允许相同成员存在。 关键概念定义 树由一组以边连接的节点组成 一棵树最上面的节点称为根节点， 如果一个节点下面连接多个节点， 那么该节点称为父节点， 它下面的节点被称为子节点。 一个节点可以有0个、 1个或多个子节点。 没有任何子节点的节点称为叶子节点。 二叉树是一种特殊的树， 子节点个属不超过两个。 从一个节点走到另一个节点的这一组称为路径 以某种特定顺序访问树中的所有节点称为树的遍历 树分为几个层次， 根节点是第0层， 它的子节点是第一层， 一次类推。 我们定义树的层数就是树的深度 。 每个节点都有一个与之相关的值， 该值有时被称为键。 一个父节点的两个子节点分别称为左节点和右节点。 二叉查找树是一种特殊的二叉树， 相对较小的值保存在左节点， 较大的值保存在右节点， 这一特性使得查找效率很高。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuecli3脚手架环境变量]]></title>
    <url>%2F2019%2F04%2F24%2Fvuecli3%E8%84%9A%E6%89%8B%E6%9E%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境变量 环境变量, 在开发和生产环境中会经常使用到 举一个例子 在开发过程中我们使用一个本地的接口但是在我们打包上线的时候, 我们会使用线上的接口这时候我们就可以通过环境变量来配置 如何创建环境变量 进入脚手架根目录 , 新建一个 .env 文件 , 这就是一个环境变量文件 .env 优先级最低的配置文件, 两种环境都可以用.env.development 开发环境, 时优先使用的环境变量.env.production 生产环节, 打包时使用的环境变量 环境变量语法 VUE_APP_衔接上一个名字=’你的变量’ 如: VUE_APP_URL=’https://baidu.com&#39; 如何在组件中获取环境变量 process.env.VUE_APP_URL然后挂载到当前组件的data 上 ,如下 12345data()&#123; return &#123; url: process.env.VUE_APP_URL &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的add命令与npm的小区别]]></title>
    <url>%2F2019%2F04%2F24%2Fvue%E7%9A%84add%E5%91%BD%E4%BB%A4%E4%B8%8Enpm%E7%9A%84%E5%B0%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[add如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响, 那就选择 vue add xxx npm如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件那就选择 npm install xxx 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3脚手架配置px2rem适配方案]]></title>
    <url>%2F2019%2F04%2F24%2Fvue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AEpx2rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[安装12npm i lib-flexible --savenpm install px2rem-loader 引入 main.js 1import &apos;lib-flexible/flexible&apos; index.html 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 根目录新建 vue.config.js 文件 复制如下代码， 重启， 搞定 123456789101112131415// vue.config.jsmodule.exports = &#123; chainWebpack: config =&gt; &#123; config.module .rule(&apos;css&apos;) .test(/\.css$/) .oneOf(&apos;vue&apos;) .resourceQuery(/\?vue/) .use(&apos;px2rem&apos;) .loader(&apos;px2rem-loader&apos;) .options(&#123; remUnit: 75 &#125;) &#125;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】Flux架构是什么]]></title>
    <url>%2F2019%2F04%2F16%2F%E3%80%90React%E3%80%91Flux%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[为了避免React的state混乱， 让React专注于ui, Flux就应运而生了 Flux是一种架构思想， 专门解决软件的结构问题。他跟MVC架构是同一类东西， 但是更加简单和清晰。 Flux构成 View视图层 Action(动作): 视图层发出的消息(比如mouseClick) Dispatcher(派发器): 用来接收Actions, 执行回调函数 Store(数据层): 用来存放应用的状态， 一旦发生变动， 就提醒Views要更新页面 Flux 的最大特点，就是数据的”单向流动”。 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。 Flux与Redux因为Flux的不好理解， 所以社区做出了很多的努力， 常用的Redux就是Flux的其中一种实现 优质文献 阮一峰的flux]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】fiber带来的API]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90React%E3%80%91%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84fiber%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[github地址↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ React Fiber异步渲染unstable_ConcurrentModeReact.unstable_ConcurrentMode 是一个使子组件中的更新异步的组件，这意味着更新被视为低优先级。1234const ConcurrentMode = React.unstable_ConcurrentMode;&lt;ConcurrentMode&gt; &lt;App /&gt; // Low Priority by default&lt;/ConcurrentMode&gt; flushSync如果您想在组件内部使用同步更新，则可以使用ReactDOM.flushSync(cb)。在ReactDOM.flushSync回调内部，更新被视为同步优先级，这是v16的默认优先级。12345flushSync(() =&gt; &#123; this.setState(&#123; num: newNum, &#125;)&#125;)]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】拥抱函数组件的Hooks]]></title>
    <url>%2F2019%2F04%2F14%2F%E3%80%90React%E3%80%91%E6%8B%A5%E6%8A%B1%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84Hooks%2F</url>
    <content type="text"><![CDATA[React16带来了惊人的改变， amazing~ hooks带来的好处和特点 只能在函数组件中使用 函数组件后期的业务变更无需修改为class组件 告别了麻烦this 和难记的生命周期 合并了生命周期componentDidMount、componentDidUpdate和componentWillUnmount的作用 可以包装自己的hooks，基于纯命令式的API 更好的完成状态之间的共享， 解决原来class组件内部封装问题。 也解决高阶组件嵌套过深 useReducer集成redux useEffect接受脏操作等到react更新了dom后， 它再依次执行我们定义的副作用函数。 这里就是一个io且是异步的 起步先来看看最常用的两个hooks： useState, useEffect useState 传入一个初始值， 返回 count、setCount,count用来读， setCount用来写 12345678910export default () =&gt; &#123; const [ count, setCount ] = useState(0) return ( &lt;div&gt; count: &#123; count &#125; &#123;/* 点击事件触发setCount方法 */&#125; &lt;button onclick=&#123; setCount &#125;&gt;增加Count&lt;/button&gt; &lt;/div&gt; )&#125; 此时页面就是这个样子的 然后我点击一次按钮 此时count就发生了变化变为了1， 就好像我们使用了setState方法一样神奇 useEffect 副作用， 如果你对函数式编程有一定的了解， 那应该能明白这个词 它主要用来承担componentDidMount、componentDidUpdate和componentWillUnmount的作用 它传入一个函数，用于在组件render时触发， 其中需要返回一个函数，返回的函数在组件卸载时被触发1234567useEffect(() =&gt; &#123; console.log("更新渲染阶段") document.title = `标题-$&#123;count&#125; times` return () =&gt; &#123; console.log("卸载阶段") &#125;&#125;) 在useState例子基础上我们添加了useEffect后， 效果如下： 我们可以看到， 刷新页面后首先出现的是”更新渲染阶段”，当我们点击了按钮后， 立即出现了“卸载阶段”， 然后出现了”更新渲染阶段” 这就证明该副作用是在每次组件更新时都会被触发的。 自定义触发useEffect不仅能够替代那些个老生命周期， 还能够自定义根据某个值来触发 useEffect的能接收两个参数， 第一个就是刚刚我们尝试的回调， 第二个参数可传可不传， 他是一个数组， 如果你不传，就和上面的例子一样， 默认全部触发，如果你传入的是一个空数组[]，那就只在第一次渲染时触发如果你数组里制定了值， 那就只在这些值变化时触发 比如我要指定只有 count变化时才会触发1234567useEffect(() =&gt; &#123; console.log("更新渲染阶段") document.title = `标题-$&#123;count&#125; times` return () =&gt; &#123; console.log("卸载阶段") &#125;&#125;, [count]) api ability state 返回有状态值, 以及更新这个状态值的函数 useEffect 接收包含命令式， 可能有副作用代码的函数 useContext 接受上下文对象（从React.createContext返回的值） useReducer useState的替代方案 useCallback 返回一个回忆的memoized版本， useMemo 纯的一个记忆函数 useRef 返回一个可变的ref对象 useImperativeMethods 自定义使用ref时公开给父组件的实例值之前 useMutationEffect 更新兄弟组件之前， 它dom改变前执行 useLayoutEffect Dom改变后同步触发]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】react生命周期的变化]]></title>
    <url>%2F2019%2F04%2F13%2F%E3%80%90React%E3%80%91react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[React16带来了新的生命周期， 为了更好的贴合fiber架构， 移除了几个旧的生命周期， 这几个生命周期也确实不太常用 我们先来看看老的生命周期 react15生命周期 光看没用呀，记不住，我们来实际看一下它的打印顺序。初次加载时： 点击按钮更新组件，使得传入Props发生改变，触发子组件的生命周期 react16生命周期 废弃的三个生命周期： componentWillMount componentWillReceiveProps componentWillUpdate 如果你在react16中还继续使用这几个什么周期， 他就会提示你这是不安全的 新增的两个生命周期: 为了配合fiber getDerivedStateFromProps getSnapshotBeforeUpdate 我这个人说话比较简单， 我就简介的说一下这两个生命周期主要的功能及解决的问题， 具体的长篇大论不好描述，也不是我擅长的事情， 我在下面给出了两份不错的文章， 方便自己回忆细节， 也方便大家理解 getDerivedStateFromProps 用来取代componentWillReceiveProps, 是一个静态方法 接收两个参数 nextProps, preProps是一个将接收到的props映射到state的方法具体映射规则根据该方法的返回值， 比如，如果这样，返回一个name123static getDerivedStateFromProps(nextProps, prevProps) &#123; return &#123; name: "张三" &#125;&#125; 随即我们打印一下state我们发现，返回的name 确实出现在了state, 尽管这是我创造出来的， 而不是props上传入的 如果我们不想它映射到state, 我们可以返回一个null 根据这个特性利用传入的nextProps, prevProps两个参数， 我们就可以做类似 shouldComponentUpdate的操作 getSnapshotBeforeUpdate 该方法获取上一次render时的镜像 接收 prevProps, prevState 两个参数 新的getSnapshotBeforeUpdate生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。） 与componentDidUpdate一起，这个新的生命周期将覆盖旧版componentWillUpdate的所有用例。 来看一下每次的打印结果12345getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log(`---第$&#123;times++&#125;次renders---`) console.log('prevProps', prevProps) console.log('prevState', prevState)&#125; 关于这两个生命周期， 有两个个比较好的文章： 理论型文章 使用型文章 参考文献: https://www.jianshu.com/p/50fe3fb9f7c3https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoizationhttps://www.zcfy.cc/article/update-on-async-rendering]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】react16新增错误处理生命周期]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90React%E3%80%91react16%E6%96%B0%E5%A2%9E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React16新增了一个用于错误处理的生命周期， 有了这个法宝，我们就能针对组件的错误做很多事情啦， 来看看怎么用 使用示例1234567891011121314151617181920export default class Errorfun extends Component &#123; constructor( props) &#123; super(props) this.state = &#123; hasError: false &#125; &#125; // 捕捉错误和错误上报程序库一起使用 componentDidCatch(err, info) &#123; this.setState(&#123; hasError: true &#125;) &#125; render() &#123; if ( this.state.hasError ) &#123; return &lt;div&gt;Somthing error &lt;/div&gt; &#125; return ( &lt;div&gt; Hello React &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】react16中如何使用ref]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90React%E3%80%91react16%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ref%2F</url>
    <content type="text"><![CDATA[在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。 新版的ref内部使用Symbol来作为标识， 可以猜测出，React的用意是想避免string ref可能引起重复的问题 关联ref使用新版本的ref12345678910111213141516export default class Reftest extends Component &#123; constructor(props) &#123; super(props); // 创建ref this.myRef = React.createRef(); &#125; componentDidMount() &#123; // 打印ref console.log(this.myRef) this.myRef.current.focus(); &#125; render() &#123; // 挂载 ref return &lt;input ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; 传递和转发ref利用 React.forwardRef 传递复用 ref 123456789101112131415161718192021import React, &#123; Component &#125; from 'react'const TargetComponent = React.forwardRef((props, ref) =&gt; &#123; return &lt;input type="text" ref=&#123;ref&#125; /&gt;&#125;)export default class Reftest extends Component &#123; constructor(props) &#123; super(props); // 创建ref this.myRef = React.createRef(); &#125; componentDidMount() &#123; // 改变value this.myRef.current.value = "传递ref成功" &#125; render() &#123; // 挂载 ref, 让组件也保持ref写法 return &lt;TargetComponent ref=&#123;this.myRef&#125; /&gt; &#125;&#125; 结果如下: 参考文献: https://blog.csdn.net/qq_24147051/article/details/81218688]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】使用Context避免多层嵌套]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90React%E3%80%91%E4%BD%BF%E7%94%A8Context%E9%81%BF%E5%85%8D%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[用过redux + react-redux的同学，应该会觉得新的Context API很眼熟。而有看过react-redux源码的同学就知道，react-redux本身就是基于旧版本的Context API实现的。 既然已经有了现成的解决方案，为什么还会有新的Context API呢？ 现有Context API的实现存在一定问题：比如当父组件的shouldComponentUpdate性能优化，可能会导致消费了context数据的子组件不更新。 降低复杂度：类似redux全家桶这样的解决方案，给项目引入了一定的复杂度，尤其是对方案了解不足的同学，遇到问题可能一筹莫展。新Context API的引入，一定程度上可以减少不少项目对redux全家桶的依赖。 解决多层组件嵌套 创建一个上下文利用新的API创建一个上下文， 接收返回的Provider, Consumer12import React, &#123; Component &#125; from 'react'const &#123; Provider, Consumer &#125; = React.createContext("default") 定义父容器在此父容器内部使用Provider包裹住插槽传入的子组件， 传入Provider的值和state挂钩， 并且我将两个值都实现了双向绑定，以便于查看使用context方法传递的变量能否及时刷新 12345678910111213141516171819202122class Parent extends Component &#123; state = &#123; name: "张三", age: 12 &#125; render() &#123; const &#123; name, age &#125; = this.state return ( &lt;div&gt; 姓名： &lt;input onChange=&#123; e=&gt; this.setState(&#123; name: e.target.value &#125;)&#125; value=&#123;name&#125; /&gt; 年龄: &lt;input onChange=&#123; e=&gt; this.setState(&#123; age: e.target.value &#125;)&#125; value=&#123;age&#125; /&gt; &lt;Provider value=&#123;&#123; name, age &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/Provider&gt; &lt;/div&gt; ) &#125;&#125; 创建两个子组件两个子组件分别用接收一个参数， 当然你也可以接收多个的123456789101112131415161718192021222324// 我用来展示namefunction Child01() &#123; return ( &lt;Consumer&gt; &#123; value =&gt; ( &lt;div&gt;&#123;value.name&#125;&lt;/div&gt; ) &#125; &lt;/Consumer&gt; )&#125;// 我用来展示agefunction Child02() &#123; return ( &lt;Consumer&gt; &#123; value =&gt; ( &lt;div&gt;&#123;value.age&#125;&lt;/div&gt; ) &#125; &lt;/Consumer&gt; )&#125; 组件整合用Parent组件将两个Child包裹， 也就是上面说的插槽123456export default () =&gt; ( &lt;Parent &gt; &lt;Child01 /&gt; &lt;Child02 /&gt; &lt;/Parent&gt;) 最终效果: 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from 'react'const &#123; Provider, Consumer &#125; = React.createContext("default")class Parent extends Component &#123; state = &#123; name: "张三", age: 12 &#125; render() &#123; const &#123; name, age &#125; = this.state return ( &lt;div&gt; 姓名： &lt;input onChange=&#123; e=&gt; this.setState(&#123; name: e.target.value &#125;)&#125; value=&#123;name&#125; /&gt; 年龄: &lt;input onChange=&#123; e=&gt; this.setState(&#123; age: e.target.value &#125;)&#125; value=&#123;age&#125; /&gt; &lt;Provider value=&#123;&#123; name, age &#125;&#125;&gt; &#123;this.props.children&#125; &lt;/Provider&gt; &lt;/div&gt; ) &#125;&#125;function Child01() &#123; return ( &lt;Consumer&gt; &#123; value =&gt; ( &lt;div&gt;&#123;value.name&#125;&lt;/div&gt; ) &#125; &lt;/Consumer&gt; )&#125;function Child02() &#123; return ( &lt;Consumer&gt; &#123; value =&gt; ( &lt;div&gt;&#123;value.age&#125;&lt;/div&gt; ) &#125; &lt;/Consumer&gt; )&#125;export default () =&gt; ( &lt;Parent &gt; &lt;Child01 /&gt; &lt;Child02 /&gt; &lt;/Parent&gt;)]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】memo为函数组件创造shouldComponentUpdate]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90React%E3%80%91memo%E4%B8%BA%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%88%9B%E9%80%A0shouldComponentUpdate%2F</url>
    <content type="text"><![CDATA[React v16.6.0出了一些新的包装函数(wrapped functions)，一种用于函数组件PureComponent / shouldComponentUpdate形式的React.memo() React.memo()是一个高阶函数，它与 React.PureComponent类似，但是一个函数组件而非一个类。 利用memo我们就能函数组件创造为Purecomponent 总之就是， 在今天，我们也能为函数组件做性能优化了， 就让我们来演示下具体如何使用 先创建一个普通的函数组件这是一个最普通的函数组件， 接收一个name的props参数12345// 创建一个函数组件function Child(&#123; name &#125;) &#123; console.log('I am rendering') return &lt;div&gt;Memo组件 name =&gt; &#123; name &#125;&lt;/div&gt;&#125; 显式地shouldComponentUpdate然后我们为其量身定制一个shouldComponentUpdate1234567function areEqual(prevProps, nextProps) &#123; if( prevProps.name == nextProps.name ) &#123; return true &#125; else &#123; return false &#125;&#125; 产生出一个新组件利用memo这个高阶函数，我们创造出一个新的组件，这将会是个拥有shouldComponentUpdate的函数组件12import React, &#123; memo, Component &#125; from 'react'const DemoComponent = memo(Child, areEqual) 查看结果最后我们将其放入render函数， 让它渲染出来， 并传入刚刚设定的name参数1234567891011export default class Menotest extends Component &#123; render() &#123; return ( &lt;div&gt; &#123;/* seconds作为Props传入 */&#125; &lt;DemoComponent name="小明" /&gt; &lt;/div&gt; ) &#125;&#125; 结果如下: 完整代码123456789101112131415161718192021222324252627import React, &#123; memo, Component &#125; from 'react'// 创建一个函数组件function Child(&#123; name &#125;) &#123; console.log('I am rendering') return &lt;div&gt;Memo组件 name =&gt; &#123; name &#125;&lt;/div&gt;&#125;// 注意 函数组件没有state , 显式的shouldComponentUpdatefunction areEqual(prevProps, nextProps) &#123; if( prevProps.name == nextProps.name ) &#123; return true &#125; else &#123; return false &#125;&#125;const DemoComponent = memo(Child, areEqual)export default class Menotest extends Component &#123; render() &#123; return ( &lt;div&gt; &#123;/* seconds作为Props传入 */&#125; &lt;DemoComponent name="小明" /&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】react16.6中如何处理异步&&按需加载]]></title>
    <url>%2F2019%2F04%2F11%2F%E3%80%90React%E3%80%91react16.6%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%26%26%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[当前大部分 React 应用需要使用 code splitting 的时候，都选择使用优秀的 react-loadable 来处理检测代码段是否已加载。然而，随着React v16.6 的发布，我们有一个非常难得的机会 ，可以删除我们的第三方依赖！ React.Suspense是一个新添加到核心React库中的功能，他的功能基本和 react-loadable 一致，所以不用多说，让我们来看看用 React.Suspense 替换 react-loadable。 Suspense 的好处是不一定只能处理组件的按需加载， 也能用来处理其他的异步事件 处理异步 自己实现流程 首先创建一个Promise ， 模拟一个异步请求12345678function fetchApi() &#123; const promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('data resolved') &#125;, 3000) &#125;) return promise&#125; 实现处理promise异步的逻辑12345678910111213141516171819202122232425262728import React, &#123; Suspense, Component &#125; from 'react'// 创建Fetcher var cached = &#123;&#125;// 接收一个为promise 的参数const createFetcher = promiseTask =&gt; &#123; // 将ref 复制为 cached let ref = cached return () =&gt; &#123; // 返回一个 promise const task = promiseTask() // task task.then(res =&gt; &#123; // ref 复制为 res, 也就是promise 的返回结果 ref = res &#125;) // ------注意此处的 console -------- console.log('进入ref === cached的判断') // 如果 ref 没有发生改变， 仍旧和cached相等 if (ref === cached) &#123; // 抛出 task throw task &#125; // 得到结果输出 console.log('🍎', ref) // 正常返回 ref ， 此时已是promise 的结果 return ref &#125;&#125; 我们将异步事件传入刚刚定义的createFtecher1const requestData = createFetcher(fetchApi) 创建一个函数组件， 用于显示处理好的异步结果1234function SuspenseComp() &#123; const data = requestData() return &lt;p className="name"&gt;&#123;data&#125;&lt;/p&gt;&#125; 重点来了， 使用Suspense组件包裹住， 使用fallback参数传入未加载完成的时候的样式, 我们这里传入一个loading的文字意思意思123456789class Test extends Component &#123; render() &#123; return ( &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125; &gt; &lt;SuspenseComp /&gt; &lt;/Suspense&gt; ) &#125;&#125; 来看一下效果， 在经过一段事件的Loading 后成功的显示除了我们在setTimeout中返回的文字 原理分析仔细观看上面的效果图 我们看到进入ref === cached的判断 这条语句出现了二次， 继而才出现了最终结果data resolved，还记得在createFetcher函数中抛出的task吗， 它就是利用这样一种方法， 抛出错误，让Suspense 来接收， 如果抛出了错误， 就隔一会继续来一次， 其实就可以理解为轮询 处理组件组件就比上面简单多了, React就提供了一个 lazy方法 我们只需要这样即可， 非常的快捷1lazy(() =&gt; import("./xxx")) 来看看实际如何使用123456789101112131415161718192021222324252627282930// 引入`lazy` 和 `Suspense`import React, &#123; Suspense, Component, lazy &#125; from 'react'// 加载异步组件const LazyComp = lazy(() =&gt; import("./lazy"))class Test extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125; &gt; &#123; /* lazy 组件 */ &#125; &lt;LazyComp /&gt; &lt;/Suspense&gt; &lt;/div&gt; ) &#125;&#125;// 被加载的lazy组件class Lazy extends Component &#123; render() &#123; return ( &lt;div&gt; my name lazy &lt;/div&gt; ) &#125;&#125; 来， 让我们看一下效果 加载顺序那上面两个例子中的组件SuspenseComp 和 LazyComp 都放在Suspense 里面呢，到底是各管各的还是一起完成呢？ 让我们实践一下12345678910class Test extends Component &#123; render() &#123; return ( &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125; &gt; &lt;SuspenseComp /&gt; &lt;LazyComp /&gt; &lt;/Suspense&gt; ) &#125;&#125; 效果如下: 我们可以看到,尽管SuspenseComp 和LazyComp 加载速度不同, 但是它仍旧是等待Suspense 中的所有组件都加载完成后才显示出来 处理异步-Hooks版本Hooks 处理异步只需要短短的几行，就有了相同的效果12345678import &#123; useFetch &#125; from 'react-hooks-fetch'function SuspenseComp() &#123; const &#123;error, data&#125; = useFetch("a.php") if( error ) return &lt;span&gt;出错了🙂&lt;/span&gt; if( !data ) return null return &lt;span&gt;result&#123;data.title&#125;&lt;/span&gt;&#125; 真香 非Hooks版本全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123; Suspense, Component, lazy &#125; from 'react'// React 自带的lazy组件，自己会编译 （避免被webpack打包成js）const LazyComp = lazy(() =&gt; import("./lazy"))function fetchApi() &#123; const promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('data resolved') &#125;, 3000) &#125;) return promise&#125;// 创建Fetcher var cached = &#123;&#125;const createFetcher = promiseTask =&gt; &#123; let ref = cached return () =&gt; &#123; // 返回一个promise const task = promiseTask() task.then(res =&gt; &#123; ref = res &#125;) console.log('进入ref === cached的判断') if (ref === cached) &#123; throw task &#125; // 得到结果输出 console.log('🍎', ref) return ref &#125;&#125;const requestData = createFetcher(fetchApi)function SuspenseComp() &#123; const data = requestData() return &lt;p className="name"&gt;&#123;data&#125;&lt;/p&gt;&#125;class Test extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125; &gt; &lt;SuspenseComp /&gt; &lt;LazyComp /&gt; &lt;/Suspense&gt; &lt;/div&gt; ) &#125;&#125;export default Test]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生实现一个ajax]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAajax%2F</url>
    <content type="text"><![CDATA[原生 AJAX什么是AJAX Asynchronous JavaScript &amp; XML 请求XML的异步技术 web开发的一种技术 异步发送 &amp; 请求数据 不需要重新刷新当前页面 目前 JSON 数据格式以及占据市场 请求码 和 状态码readyState 请求码 0 : 请求未初始化 ( 没有 XHR 对象 ) 1 : 服务器连接已建立 2 : 请求已接受 3 : 请求处理中 4 : 请求已完成, 且相应已就绪 HTTP 状态码 200 - 服务器成功返回网页 300 - 请求地址错误,重定向 400 - 请求错误 404 - 请求的网页不存在 500 - 服务端错误 503 - 服务器暂时不可用 创建 XMLHttpRequest 对象1var xhr = new XMLHttpRequest() open() 请求部署阶段 xhr.open( type 请求类型 , url/filename 路径或文件名 , async是否要使用异步) GET 请求 参数写在 URL 中1xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true) 两种方式请求 onload 和 onreadystatechange 请求成功后会返回服务器 返还的相应内容 responseText onload 只有请求码为 4 时才会进入 onload123xhr.onload = function()&#123; console.log(this.responseText)&#125; onprogress 捕获 为3 的请求码123xhr.onprogress =function()&#123; console.log(this.readyState)&#125; onreadystatechange 需要判断返回的请求码 , 直接输出会返回两次数据 123xhr.onreadystatechange = function()&#123; console.log(this.responseText)&#125; readyState 返回请求码的位置与顺序12345678var xhr = new XMLHttpRequest()console.log(xhr.readyState) // 0xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true)console.log(xhr.readyState) // 1xhr.onreadystatechange = function()&#123; console.log('readyState:',xhr.readyState) // 2 , 3 , 4&#125;xhr.send() status 状态码 每次都和请求码一同被返回 根据 请求码 和 状态码 来操作数据一个完整的 GET 请求12345678var xhr = new XMLHttpRequest() xhr.open('GET', 'http://jsonplaceholder.typicode.com/users', true) xhr.onreadystatechange = function()&#123; if(this.status == 200 &amp;&amp; this.readyState == 4)&#123; console.log(this.responseText) &#125; &#125; xhr.send() 发送请求 GET 直接发送 POST 需要带上要发送的 请求体 数据1xhr.send()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【imooc】HTML5&CSS3]]></title>
    <url>%2F2019%2F04%2F10%2F%E3%80%90imooc%E3%80%91HTML5-CSS3%2F</url>
    <content type="text"><![CDATA[HTML5 + CSS3语义化标签 标签名 作用 nav 导航 header 页眉 footer 文档或者页的页脚 main 主要内容 article 文章或热点区 aside 主题内容之外 语义化标签的兼容性 IE9: 行级元素在设置宽度的时候失效, 解决方法: display : block IE8: 完全不支持语义标签( 不支持html5 ) ,解决方法: document.createElement(&#39;header&#39;) 或引入第三方插件 html5shiv form 新增的属性 autofocus 浏览器打开自动获得焦点 autocomplete=”on” 表单内容自动完成,前提: 必须成功提交过 , 该标签必须有name 属性 required 必须输入 pattern=” “ 正则表达式验证 multiple 对于file 标签使用, 同时选择多个文件, 对于email 标签使用, 可以同时输入多个邮箱 form=”表单form 的 id “ 可以让在form 表单外部的 表单数据也参与提交 oninvalid 当验证不通过时触发的事件 this.setCustomValidity(“ 请输入合法的手机号 “) 这个js api 可以修改默认的h5表单 提示内容 dom.dataset[ &quot;myTest&quot; ] 获取自定义的data-my-Test的值 ,获取时要变成驼峰命名 form 新增的元素 datalist 可以输入的下拉列表 ( firfox 中不支持 ) 需要通过 list=”datalist的id” 建立联系 如果 input 的type 类型是url ,那么value值必须添加 http:// ,因为不加的话识别为不合法123456&lt;!-- 建立关联 list=&quot;datalist的id&quot; --&gt;&lt;input type=&quot;text&quot; list=&quot;dt&quot;&gt;&lt;datalist id=&quot;dt&quot;&gt; &lt;option value=&quot;哈哈&quot; label=&quot;10人&quot;&gt;哈哈哈&lt;/option&gt; &lt;option value=&quot;前端牛逼&quot; label=&quot;18人&quot;&gt;前端牛逼&lt;/option&gt;&lt;/datalist&gt; keygen标签 h5 提供的加密 , 部分浏览器不支持 , 将表单信息进的是非对称加密, 生成公钥和私钥, 提交数据的时候 信息+私钥 =&gt; 二次加密 然后发送给服务器, 服务器用接收到的 公钥进行解密数据 output 显示输出信息, 只能显示不能修改 语义性更强 值需要你去设置, 不能自动计算 多媒体标签 embed 直接插入视频文件， 它的本质是调用本机上已经安装的软件 有兼容性 flash插件 安装flash 1.学习flash,增加使用成本 2.苹果设备不支持flash audio 音频 src : 播放音频文件的路径 controls: 音频播放器的控制面板 autoplay: 自动播放 loop: 循环 video 视频 src : 播放音频文件的路径 controls: 音频播放器的控制面板 autoplay: 自动播放 loop: 循环 width:宽度 height:高度 poster: 当视频还没完全下载， 或者用户还没点击播放前的默认显示的封面， 默认是显示当前视频文件的第一帧 设置宽高的时候，一般情况下只会设置宽度或者高度 让其自动等比缩放， 如果同时设置宽度和高度，那么视频不会真正的调整到设置的高度，除非设置刚好等比例 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 123456&lt;video autoplay controls width=&quot;600px&quot;&gt; &lt;!-- 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 --&gt; &lt;source src=&quot;http://www.baidu.com&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;http://wxhboy.com/login/movies/w.mp4&quot; type=&quot;video/mp4&quot;&gt; 您的浏览器不支持当前的视频播放 &lt;/video&gt; 操作class的API dom.classList.add(&#39;bg&#39;) 增加class obj.classList.remove(&#39;bg&#39;) 删除class obj.classList.toggle(&#39;bg&#39;) 切换class 如果存在就删除,如果不存在就增加该class obj.classList.contains(&#39;bg&#39;) 判断是否存在某个class , 返回布尔型 H5新增的接口 API ononline 网络连通时触发这个事件 ，只在window上 onoffline 网络断开时触发事件 element.requestFullscreen 开启全屏 ，需要加浏览器前缀 需要加兼容浏览器的前缀 chrome:webkit firefox:moz ie: ms opera: o document.cancelFullScreen 取消全屏，只能是document对象 需要加兼容浏览器的前缀 chrome:webkit firefox:moz ie: ms opera: o document.fullscreenElement 取消全屏，只能是document对象 需要加兼容浏览器的前缀 chrome:webkit firefox:moz ie: ms opera: o var reader = new FileReader() reader.readAsDataURL(file[0])读取文件斌转为base64 没有返回值,但是它会将读取的结果存储在文件读取对象的result中 FileReader 提供一个完整的事件模型, 用来捕获读取文件时的状态 onabort: 读取文件中断片时触发 onerror: 读取文件错误时触发 onload: 文件读取成功完成时触发 * onloadend: 读取完成时触发,无论成功还是失败 * onloadstart: 开始读取文件时触发 * onprogress: 读取文件过程中持续触发 CSS3 选择器属性选择器 属性时相对于标签而言的就是根据指定名称的属性的值来查找元素 li[style] 查找只要拥有 style 属性的标签 li[class = red ] 严格匹配 拥有class 样式并且等于某值 li[class*= red ] 查找class 中包含 red 的标签 li[class^= red ] 查找class 中以red 开头的li标签 li[class$= red ] 查找class 中以red 结尾的li标签 伪类选择器兄弟伪类 + 获取当前元素相邻的满足条件的元素，必须是相邻的 ~ 获取当前元素的满足条件的兄弟元素 可以不相邻 ，所有兄弟元素 相对于父级选择器 ul&gt; li:first-child 查找ul下第一个元素，如果第一个不是li 那就不生效 ul&gt; li:last-child 查找ul下最后一个元素 li:first-of-type 查找的时候指挥查找满足类型条件的第一个元素，过滤掉其他类型的元素 li:last-of-type 查找的时候指挥查找满足类型条件的最后一个元素 li:nth-child() 指定索引位置 nth-child(从1开始的所以||关键字||表达式) / 该方法同样 &gt; 如果第一个不是li 那就不生效 even 偶数 odd 奇数 li:nth-of-type(even) 指定类型的 所有偶数 li li:nth-of-type(-n+5) 只选择前5个li li:nth-last-of-type(-n+5) 只选择最后5个li li:empty 选择内容为空的li 伪类样式 h2:target 可以为锚点目标元素添加样式，当目标元素被触发为当前锚链接的目标时，调用此伪类样式 伪元素 是一个行内元素， 如果想设置宽高需要转换成block|| float || postition必须添加 content, 哪怕不设置内容， 也要 content:”” e::before e::after e::first-letter 文本的第一个字母或字(不是词组) 依靠float 实现首字下沉 e::first-line 文本第一行 ， 如果第一个字设置了::first-letter 这些样式都对它无效 e::selection 可改变选中文本的样式，只能设置显示的样式，而不能设置内容的大小 渐变 shape : 渐变的形状 ellipse 表示椭圆形（适配当前的形状），circle 表示正圆形 如果宽 高不一样 默认效果切换到 ellipse 多列布局 固定列数时可以使用有点类似表格布局比较适合文字 只需再父容器上 加上 column-count: 3 想要几列就写几 column-rule:dashed 3px red; 设置边框样式，这是虚线边框 column-gap: 0px; 设置列与列之间的间距 , 为0时是没有边框的 column-width: 500px; 取大优先，看看是自动计算的宽度大还是你设置的大 但是会填充整个屏幕 ，意味最终的宽度可能会大于设置的宽度– ​ 填充满整个屏幕 如果人为设置宽度更小，使用自动计算的宽度 column-span: all; 使某文字或某元素占满一整行]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和CSS巩固]]></title>
    <url>%2F2019%2F04%2F10%2F%E3%80%90imooc%E3%80%91HTML%E5%92%8CCSS%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[HTML 如何理解HTMLhtml “文档”描述文档的”结构”有区块和大纲 &lt;base href=&quot;/&quot;&gt; 指定基础路径 ,只有所有的链接都是以该路径为基准来进行计算 label 中 for = 表单项的id 可以和表单项关联, 你点击这个label就好比点击这个表单项本身 button tyle=&quot;reset&quot;&gt; 初始化表单 jQurey 的 $(&quot;form&quot;).serialize() 的方法可以批量获得表单的属性 了解下html 5的 内容模型 分类规则 https://www.w3.org/TR/html5/text-level-semantics.html#the-a-element 块级元素不一定能包含块级元素 如: p 中不能包含div ,强行包裹渲染时浏览器会进行容错模式会以为你写错了, p的开始标签会被当成一个标签,div 还是div ,p 的结束标签又会被当成一个独立的标签 行内元素一般不能包含块级元素 , 但也有例外, 比如: a 但在html4中是不合法的,,h5中计算时会将其透明化,也就是说计算合法性时会不考虑 a , 但比如 a&gt;div 这样包裹,还是要取决于 它们外部时什么元素才能决定是否合法 a 中同样不能包含 a 强行包裹渲染时会被分离 html 元素默认样式 默认样式的意义在于, 你可以直接书写代码就会在页面上出现效果,而不是每创建一个元素都要去临时给他 宽高颜色之类的 才会在页面上出现\但也会带来一些问题, 有时会导致和我预期想要实现效果截然不同的情况所以需要适当清除默认样式 叫做 css Reset 可以去百度下著名的写法,比如 : 雅虎 YUI 的 css reset 写法 或者是 Normalize.css 让默认样式有效化 面试题 doctype的意义是什么 让浏览器以标准模式渲染 让浏览器知道元素的合法性 html、xhtml、html5之间的关系 HTML属于SGML XHTML 属于XML, 是XTML进行xml严格化的结果 HTML5不属于SGML或XML,比XHTML宽松 HTML 5 有什么变化 新的语义化元素 表单增强 新的API (离线、音视频、实时通信、本地存储、设备能力 ) 分类和嵌套变更 em 和 i 有什么区别 em是语义化的标签, 表强调 i 是纯样式的标签, 表示斜体 HTML5中 i 不推荐使用, 一般用作图标 语义化的意义是什么 开发者容易理解 机器容易理解结构 (搜索、读屏软件) ,比如 大纲算法 有助于 SEO semantic microdata 增强语义化 , 详细的需要去百度 哪些元素可以自闭和 ( 就是在该标签内部不能再带其他东西了 ) 表单元素 Input 图片 img br hr meta link HTML 和 DOM 的关系 HTML是 “ 死 “ 的 DOM 由HTML解析而来, 是活的 js 可以维护DOM property 和 attribute 的区别 attribute 是 “死” 的 , 是你写在HTML上的属性 property 是 “ 活 “ 的 , 是dom 解析后获得的 form的作用有哪些 直接提交表单 使用submit / reset 按钮 便于浏览器保存表单 第三库可以整体提取值 如: JQuery 第三方库可以进行表单验证, 比如 angular css基础 全称 Cascading Style Sheet 层叠样式表 id选择器 样式的权重优先级最高 class选择器 其次 解析方式, body div a { } 这样的一个css 浏览器是先找到a标签,再找到它父级有没有 div ,再去找 body ,总结就是: 从右往左解析,目的就是加快 浏览器对css 的解析速度,更快确定是哪些元素 伪类和伪元素的区别 选择器选择器分类 元素选择器 a{} 伪元素选择器 ::before{} 类选择器 .link{} 属性选择器 [type = radio] {} 伪类选择器 :hover{} id选择器 #id{} 组合选择器 [type=checkbox] + label{} 否定选择器 :not(.link){} 通用选择器 * {} 选择器权重 必须遵守的是 只要有id 选择器 永远比 class 选择器要大, 并不能通过选择器数量盖过 id 选择器的权重, 官大一级压死人 , class再多 权重 也无法 从 十位 进到 百位, 因为权重不进位 ID 选择器 #id{} +100 类 属性 伪类 选择器 +10 元素 伪元素 +1 其他选择器 +0 还有一些需要注意的 !important 优先级最高 ( 不管你出现在哪,不管是谁写的 ,永远最高 ) 元素属性 优先级高 ==&gt; 比ID 选择器还要高 ( 元素属性上写style 比外联和内嵌样式表优先级高 ) 相同权重 后写的生效 行高 line-hight 会撑起 block 元素, inline 则本身无变化,但实际占用高度会被影响 图片下方会出现空隙的原因 : 因为图片是 按inline 来排版, 参照的是基线 ( base-line ), 而基线和底线又有一定的距离,这个距离视字体大小而定 , 例如当12px时 ,这个距离大约是3px css Hack 在一部分浏览器上生效的写法 Hack 即不合法但生效的写法 主要用于区分不同浏览器 缺点: 难理解 难维护 易失效 替代方案: 特性检测 替代方案: 针对性加 class 取色方式 RGB 方式 (方便,但是人眼对rgb不是很敏感) #fff rgb rgba hsl ( 色相, 饱和度, 亮度) hsl hsla( 色相, 饱和度, 亮度, 透明度) 字体载入自定义字体1234567@font-face&#123; font-family:"IF"; src: url("./IndieFlower.ttf")&#125;.test&#123; font-family: IF;&#125; 面试题 css 样式 ( 选择器 ) 的优先级 计算权重确定 !important 内联样式 后写的优先级高 雪碧图的作用 减少http请求次数 提高加载性能 有些情况下可以减少图片大小 自定义字体的使用场景 1.宣传 / 品牌 / Banner等固定文案 2.字体图标 base64 的使用 减少http请求 适用于小图片 base64的体积约为原图 4 / 3 伪类和伪元素的区别 伪类表状态 伪元素是真的有元素 前者单冒号, 后者双冒号 如何梅花checkbox label [ for ] 和 id 隐藏原生 Input :checked + label postcss npm install postcss -g文件输出命令postcss src/aa.css -o bb.css autoprefixer 自动加前缀 npm install autoprefixer psostcss-import 模块化css npm install postcss-import cssnano 压缩css代码 npm install cssnano cssnext 使用浏览器未支持的css npm install postcss-cssnext precss 用预处理的语法写css /循环/变量123456789101112const autoprefixer = require(&apos;autoprefixer&apos;)const atImport = require(&apos;postcss-import&apos;)module.exports = &#123; plugins: [ atImport, autoprefixer( &#123; browsers:[&apos;&gt;0%&apos;] &#125; ) ]&#125; webpackwebpack 打包后js 与 css 分离 npm install extract-text-webpack-plugin loader 配置 文件输出 css布局面试题 实现两栏 ( 三栏 ) 布局 表格布局 float + margin 布局 inline-block布局 flexbox布局 position:absolute / fixed 有什么区别 前者相对最近的absolute / relative 进行定位 后者相对屏幕 或 移动端的 viewport 进行定位 display:inline-block 的间隙 原因: 字符间距 解决: 消灭字符或者消灭间距 如何清楚浮动 让盒子负责自己的布局 overflow:hidden( auto ) ::after{ clear:both } 如何适配移动端页面 viewport rem / viewport / media query 设计上: 隐藏 折行 自适应 浏览器小技巧 $0 获取当前选中的元素DOM]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Node】mongose基本使用]]></title>
    <url>%2F2019%2F04%2F10%2F%E3%80%90Node%E3%80%91mongose%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NodeJS 与 MongooDB 在NodeJs 中推荐使用 Mongoose来对mongoDB 进行操作mongoose 官网 http://mongoosejs.com/ mongoDB 的特点 JSON 格式的数据存储 非关系型数据库 不需要和 MYSQL 之类的关系型数据库一样简表, 使用时若没有该集合会自动创建 集合 =&gt; 文档 =&gt; 记录/数据字段 缺点就是数据操作太灵活, 容易混入脏数据 如何安装 mongoose1npm install mongoose 导入Mongooes 在 Node 中 需要先使用 require 导入mongoose 模块1const mongoose = require(&apos;mongoose&apos;) 连接MongoDB 这里拿连接本地的mongoDB 示范1mongoose.connect(&apos;mongod://localhost/test&apos;) 引入数据库模型骨架 Schema Schema 在导入的 mongoose 对象中, 建议先将其的引用存入一个变量 Schema 是一种以文件形式存储的数据库模型骨架, 它不具备对数据库的操作能力 它可以弥补 mongoDB 对数据格式控制的不足1const Schema = mongoose.Schema 实例化 Schema 既然是模型骨架, 那我们就需要 将它的骨架搭建起来 以下举例 一个用户注册使用的 骨架模型 type (数据类型) 如: String ,Number required ( 是否允许为空 )12345678910111213let userSchema = new Schema(&#123; name:&#123; type: String, required: true &#125;, email: &#123; type: String &#125;, pwd:&#123; type: String, required: true &#125;&#125;) 发布模型 Model 由搭建好的模型骨架 Schema 发布生成的模型, 具有抽象属性和数据库操作的能力 Model 第一个参数 单数形式开头大写 , Mongoose 会自动将其转换为小写的负数形式作为文档名称 如: User =&gt; users 接下来你就可以对 User 为所欲为了, CURD1const User = mongoose.model(&apos;Use&apos;,userSchema) Sava 方法 保存数据12User.save() .then(() =&gt; console.log(&apos;保存成功&apos;)); Remove 删除数据123User.remove(&#123; 删除条件 &#125;).then(res=&gt;&#123; &#125;).catch(err=&gt;&#123; &#125;) FindOne 返回匹配到的第一条数据 如果用 Find 查找是返回的数组, FindOne 返回的就是个单独的对象 注意返回的 的查询结果可以经过修改之后为所欲为12345User.findOne( &#123; 查询条件 &#125; ) .then(data=&gt;&#123; //you can // data.save() &#125;) Find 查找满足条件的所有 和 FinOne 不同的是 无论结果有多少条,它返回的始终是一个数组12345User.find( &#123; 查询条件 &#125; ) .then(data=&gt;&#123; //you can // data.save() &#125;)]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【win10】解决经常性内存爆满100%]]></title>
    <url>%2F2019%2F04%2F10%2F%E3%80%90win10%E3%80%91%E8%A7%A3%E5%86%B3%E7%BB%8F%E5%B8%B8%E6%80%A7%E5%86%85%E5%AD%98%E7%88%86%E6%BB%A1100%2F</url>
    <content type="text"><![CDATA[问题解决，killer网卡驱动与ndu网络驱动冲突，导致wfpn与ndnb标签池有内存泄漏。解决方法：管理员运行cmd，然后 1sc config Ndu start=disabled 参考文献: http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1737577&amp;highlight=]]></content>
  </entry>
  <entry>
    <title><![CDATA[【记录】记一次优化时间线卡顿处理思路]]></title>
    <url>%2F2019%2F04%2F10%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E5%8D%A1%E9%A1%BF%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[公司有这样的应用场景， 需要按时间段来分类图片， 然后各个分类之间还有联系， 因为有可能上一个分段的后面一部分图片和下一个分段的钱一部分图片在同一个分页。 打开某一分类： 在这种场景下， 我们需要考虑: 如何把归类的图片同时保持相应的顺序成一组 当我打开并不是连续的分段时， 中间的分段如何空出来， 以便于后续插入， 同时插入后还要保证 1 打开一个分类时会加载大量图片， 此时加载资源会阻塞网络， 图片归类计算会阻塞进程， 图片量大的时候性能会出问题 当用户滚动时， 需要加载分页 滚动时分页加载的数据， 不能和用户主动打开时的数据冲突重复 解决思路 首先可以创建一个数组或是字典， 存储已加载的页码， 用来过滤重复加载的情况 以用户展开指定操作为优先， 滚动加载数据为次要， 当用户滚动时 ， 我们不要立即加载， 先存在一个队列里， 设置一个延迟时间， 在这段时间内， 用户有任何和加载相关的操作就将 分页的请求无限期延后， 直到在一段时间内都无任何操作后， 才开始从队列中取出需要加载的分页， 挨个加载（注意不要一起加载， 加载图片会阻塞网络）。 大图索引问题， 维护一个二为数组 和一个一维数组， 一维数组用来给大图使用，因为大图需要连续的滑动下一页操作， 二位数组用来渲染页面]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】从高阶函数到理解高阶组件]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%90React%E3%80%91%E4%BB%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%88%B0%E7%90%86%E8%A7%A3%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[高阶组件其实就是高阶函数 高阶函数的概念千万别和普通回调搞混， 高阶函数的必要条件： 一定要返回一个新函数 非入侵 一句话理解高阶函数本来我没有的，我很垃圾， 通过把我交给别人， 在我身上装了额外的东西， 使我变的拥有了某种能力 举个例子: 人和坦克， 本来人是不能发射炮弹的， 但是人钻进了坦克， 就可以发射炮弹了， 人还是人（自身未变）， 只是在坦克里了 一个例子理解高阶函数一个简单的不能再简单的高阶函数1234567function hoc(fn) &#123; return () =&gt; &#123; console.log('start') fn() console.log('end') &#125;&#125; 一个例子理解高阶组件在不修改原有组件的情况下， 为其添加一个生命周期 123456789101112131415161718// 接收一个组件参数const MyContainer = (WrappedComponent) =&gt; &#123; return class extends Component &#123; // 新增的生命周期 componentwillmount() &#123; console.log('增加一个生命周期') &#125; render() &#123; return ( // 传入的组件 &lt;WrappedComponent /&gt; ) &#125; &#125;&#125;export default MyContainer; 随处可见的高阶函数node的express框架中, 你的app.use就是典型的高阶组件]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s学习笔记]]></title>
    <url>%2F2019%2F04%2F09%2Fk8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是K8s Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。 K8s 是底层资源与容器间的一个抽象层，如果和单机架构类比，可以算作是一个分布式时代的 Linux。 K8s 是 Google 开源的容器集群管理系统。在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。 K8S的特点 k8s是一个管理容器的工具，也是管理应用整个生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，而且可以做到故障自愈。 可移植：支持公有云，私有云，混合云； 可扩展：模块化，热插拨，可组合； 自愈：自动替换，自动重启，自动复制，自动扩展。 故障自愈场景比如机房工作人员误操作将某一排服务器断电了， k8s就会认为是故障， 自动扩充备用服务器 K8S的管理步骤在k8s进行管理应用的时候，基本步骤是： 创建集群 部署应用 发布应用 扩展应用 更新应用 K8S的架构结构 生态系统 外部生态（k8s运行过程中产出的来判断，如：日志、监控、配置功能、自动化发布、工作流） 内部生态（系统本身所依赖的东西， 如：镜像管理、镜像仓库、集群配置管理） 接口层 用于开发和管理生态系统层 管理层 系统层面的调度，比如：自动扩展， 监视、资源状态 应用层 部署及路由 处理有状态应用和无状态应用 路由根据内部的dns服务器 核心层 k8s的核心功能， 提供程序内部接口 核心模块及插件 k8s是和TCP/IP协议很像都是不允许跨层的， 当生态系统层的功能不够使用时， 你只能通过接口层来开发，不能使用更下层的东西了 k8s相关概念 主机（Master）：用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。 节点（Node）：执行请求和分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。 容器集（Pod）：部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。 复制控制器（Replication controller）： 用于控制应在集群某处运行的完全相同的容器集副本数量。 服务（Service）：服务可将工作定义与容器集分离。Kubernetes 服务代理会自动将服务请求分配到正确的容器集——无论这个容器集会移到集群中的哪个位置，即使它已被替换。 Kubelet： 这是一个在节点上运行的服务，可读取容器清单，确保指定的容器启动并运行。 kubectl： Kubernetes 的命令行配置工具 如果数据库安装于容器内部， 则在数据膨胀后，想要升级数据库就变得十分的困难， 容器集将他从容器中抽象出来便于移动管理容器 k8s整体流程 容器间都由Master统一管理， 一个容器想知道另一个容器的服务， 就必须询问master, 由master引导调度 Linux 的etc相当于window的注册表, Linux中的配置文件和window不一样， window是集中管理 ，Linux是分散管理, etcd就是为了解决多集群时配置文件难以维护的问题 安装K8S在Linux下安装单机版的集群环境以root身份执行以下操作： 1. 关闭Linux防火墙 如果不关闭可能会在SELinux 安全模块上出问题 123systemctl stop firewalldsystemctl disable firewalld 2. 安装Kubernetes和依赖组件etcd1yum install -y etcd kubernetes 3. 修改配置 docker 中的 SElinux安全模块也要关闭 Docker配置文件/etc/sysconfig/docker, OPTIONS=’–selinux-enabled=false –insecure-registry gcr.io’ Kubernetes apiservce配置文件/etc/kubernetes/apiserver,把–admission-control参数中的ServiceAccount删除 4. 按顺序启动所有的服务 提供配置存储: systemctl start etcd k8s node的重要服务: systemctl start docker 提供客户端接口: systemctl start kube-apiserver systemctl start kube-controller-manager 提供管理功能： systemctl start kube-scheduler 提供pod功能: systemctl start kubelet 提供路由请求: systemctl start kube-proxy K8S相关资源1、官网 https://kubernetes.io 2、Chart 应用仓库 https://hub.kubeapps.com/ 3、中文手册 https://www.kubernetes.org.cn/docs]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】为什么要使用immutableJs]]></title>
    <url>%2F2019%2F04%2F08%2F%E3%80%90React%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8immutableJs%2F</url>
    <content type="text"><![CDATA[React自身的一些Bug在开发中对React应用做性能优化时， 我们通常会使用shouldComponentUpdate 这个生命周期钩子来决定该组件是否需要更新， 来过滤掉没有意义的更新修改。 并且，官方也贴心的为我们提供了 PureComponent 用来省去我们繁琐的判断， 自动生成shouldComponentUpdate 但现实往往不是那么的完美， PureComponent 也有解决不了问题的时候， 为了更好的理解， 我们先来显示的使用shouldComponentUpdate操作一遍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 父组件class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; todoList: [ '喝可乐', '打游戏' ] &#125; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if( this.state.todoList != nextState.todoList ) &#123; console.log('两次不一致， 同意更新') return true &#125; console.log('更新前后todolist 一致， 所以不更新') return false &#125; // 数组concat操作， 会返回新数组 concatHandle() &#123; let todoList = this.state.todoList const rd = Math.random() * 30 todoList = todoList.concat([ `搞事情:$&#123;rd&#125;` ]) this.setState(() =&gt; (&#123; todoList &#125;)) &#125; // 数组Push操作， 未改变原数组 pushHandle() &#123; let todoList = this.state.todoList const rd = Math.random() * 30 todoList.push( `搞事情:$&#123;rd&#125;` ) this.setState(() =&gt; (&#123; todoList &#125;)) &#125; render() &#123; const &#123; todoList &#125; = this.state return ( &lt;div className="wrap"&gt; &lt;button onClick=&#123;() =&gt; this.pushHandle()&#125;&gt;Push操作&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.concatHandle()&#125;&gt;concat操作&lt;/button&gt; &#123; todoList.map( (item,index) =&gt; &lt;TodoItem key=&#123;index&#125; thing=&#123;item&#125; /&gt; ) &#125; &lt;/div&gt; ) &#125;&#125;// 子组件class TodoItem extends Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; return ( &lt;div&gt; &#123; this.props.thing &#125; &lt;/div&gt; ) &#125;&#125; 我们在shouldComponentUpdate 进行了简单的判断， 但是可悲的是这只在对比普通类型时比较的奏效， 因为JavaScript中存在这引用类型的概念， 所以对于引用类型来说== 会变成判断该变量地址的操作 口说无凭，我们来看看实际的情况。 我的天，这是怎么回事， 实际情况好像要更复杂一些！点击了两次Push没有反应， 然而在点击concat的时候， 一瞬间多出了3条 冷静分析对于这种种非正常现象， 我们有必要保持清新的头脑去分析一下 我们可以看到， 第一次点击push操作， 页面没有任何反应， 只是在控制台打印了更新前后todolist 一致， 所以不更新, 哦~， 看到这个我们知道了， 此次组件的更新被shouldComponentUpdate拦截了， 这怎么行呢， 我要更新的你给我拦截了， 我数组明明变化了啊， 我数组新增了内容， 你就该给我正常变化， 这不是坑人吗 PureComponent看到这，你可能会说， 官方不是提供了PureComponent吗， 官方给的还能跟你一样这么龊？ 该更新的不更新？ 您还别不信， 它就这么龊， PureComponent 其实是很傻的， 他也只是单纯的帮我们做了上面我们那样的操作， 虽然这样针对基本类型来说已经非常够用了， 能够解决问题了， 但是一旦遇上了引用类型， 它可就歇菜了， 还会引起你页面的奇妙Bug 不信咱们来测试下， 我们修改下父组件代码， 子组件保持一致:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 替换为 PureComponentclass TodoList extends PureComponent &#123; constructor(props) &#123; super(props) this.state = &#123; todoList: [ '喝可乐', '打游戏' ] &#125; &#125; // ------------ 删除掉 shouldComponentUpdate ------------------------ // shouldComponentUpdate(nextProps, nextState) &#123; // if( this.state.todoList != nextState.todoList ) &#123; // console.log('两次不一致， 同意更新') // return true // &#125; // console.log('更新前后todolist 一致， 所以不更新') // return false // &#125; concatHandle() &#123; let todoList = this.state.todoList const rd = Math.random() * 30 todoList = todoList.concat([ `concat操作: $&#123;rd&#125;` ]) this.setState(() =&gt; (&#123; todoList &#125;)) &#125; pushHandle() &#123; let todoList = this.state.todoList const rd = Math.random() * 30 todoList.push( `push操作:$&#123;rd&#125;` ) this.setState(() =&gt; (&#123; todoList &#125;)) &#125; render() &#123; const &#123; todoList &#125; = this.state return ( &lt;div className="wrap"&gt; &lt;button onClick=&#123;() =&gt; this.pushHandle()&#125;&gt;Push操作&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.concatHandle()&#125;&gt;concat操作&lt;/button&gt; &#123; todoList.map( (item,index) =&gt; &lt;TodoItem key=&#123;index&#125; thing=&#123;item&#125; /&gt; ) &#125; &lt;/div&gt; ) &#125;&#125; 来看看结果 哎， 还是一样的坑 那这个Bug怎么办， 这时候就请本文的主角immutableJs登场吧 immutableJs Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 使用 immutableJs 避免这个副作用的一种实现是按值传递，也就是拷贝一份再传递过去，有深层结构就深拷贝。深拷贝在只做局部修改的时候做了很多无用功，于是ImmutableJs做了性能优化。 使用它带来的好处网上找了个图，假如我们要修改左图中黄色节点的子节点4，那么Immutable.js只需要更新右图中的绿色节点，其余节点不需拷贝，继续复用。也就是说，Immutable.js会更新从根节点到所修改节点路径上的所有节点，由于修改了根节点，所以返回一个新对象，这也解释了为什么能控制副作用。 假如你在组件state中保存了一份有深层结构的引用类型的数据，如果没有Immutable.js，你需要深拷贝一份再做修改。而用Immutable.js将state中的数据包装一下，不需深拷贝就可以直接修改。 由于修改后返回的是新对象，React.js只需要在oldState.obj === newState.obj这一层就能判断出obj产生了变化，不需要深入obj的深层结构。 带来几种操作方便的数据结构和API]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js光源入门之环境光]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E5%85%89%2F</url>
    <content type="text"><![CDATA[环境光是环境整体的光照效果， 是场景内若干光源的多次反射形成的一种亮度一致的效果 环境光 AmbientLight 它是一种基础光源， 影响整个场景的光源 环境光没有明确的光源位置， 在各处形成的亮度也是一致的。 它不会影响阴影的产生。 不能将环境光作为场景中唯一的光源。 在Three中使用 THREE.AmbientLight(hex) add(color) 添加到当前颜色上 clone 复制当前颜色 如果只有环境光没有物同样是看不见东西的， 所以想测试环境光， 得先创建物体， 看一下下面两幅图: 这是正常环境光情况下的物体 然后我们把环境光调暗一点: 可以看到， 两张图中鲜艳的绿色明显的暗淡了 环境光换色刚刚我们只是调整了亮度明暗， 现在我们试试给环境光换个颜色， 就换个红色吧， 红色的灯感觉蛮吓人的 我们发现， 立方体好像少了一个， 这是因为一个不透明的物体 ， 我们所看到的颜色其实是他反射出来的颜色， 而绿色立方体无法反射红色通道的颜色， 所以， 绿色立方体在我们看上去就像是隐藏了一样， 实际上是黑了， 而我们的白色， 他能反射所有颜色， 所以是他就变红了 如何添加1scene.add(new THREE.AmbientLight(0xff0000)) 实际操作一下大体思路， 我们创建一个面，和一个立方体， 先不投射任何的光，看看是什么效果， 然后我们最后放上环境光，看一下效果 第一步-创建好立方体和面123456789101112131415161718var commonObj = common() var cubeGeometry = new THREE.BoxGeometry(5,5,5) var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;) var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 打开立方体的阴影 cube.castShadow = true cube.position.set(-4, 2.5, 0) commonObj.scene.add(cube) // 调整相机位置 commonObj.camera.position.set(-25, 20, 25) // 镜头朝向舞台中央 commonObj.camera.lookAt(commonObj.scene.position) document.body.appendChild(commonObj.renderer.domElement) commonObj.renderer.render(commonObj.scene, commonObj.camera) 此时浏览器中的效果 可以看到， 此时尽管我们给物体设定了他的颜色， 但我们看到的不管是面还是立方体都依旧是黑色。 第二步-添加光源上帝说要有光， 我们给添加一个环境光试试 12// 环境光commonObj.scene.add(new THREE.AmbientLight()) // 默认白光 好， 就这行代码，就算是加上了 第三步-改变环境光颜色环境光默认是白色， 那我们可不可以试着改变一下， 把环境光改为红色？ 是不是会很吓人 12// 环境光commonObj.scene.add(new THREE.AmbientLight(0xff0000)) // 设置红色 此时原本白色的面，也变为了红色， 感觉好刺眼， 吓得我赶紧关了 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script src="../SceneUtils.js"&gt;&lt;/script&gt;&lt;script src="../common/common.js"&gt;&lt;/script&gt;&lt;script&gt; // 公共的方法 function common() &#123; var scene = new THREE.Scene() var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0)) renderer.setSize(window.innerWidth, window.innerHeight) renderer.shadowMapEnabled = true // 创建面 var planeGeometry = new THREE.PlaneGeometry(60, 30) // 材质 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xffffff&#125;) var plane = new THREE.Mesh(planeGeometry, planeMaterial) plane.rotation.x = -0.5 * Math.PI plane.position.set(15, 0, 10) scene.add(plane) var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000) return &#123; scene, renderer, plane, camera &#125; &#125; // 开始创建 var commonObj = common() var cubeGeometry = new THREE.BoxGeometry(5,5,5) var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;) var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 打开立方体的阴影 cube.castShadow = true cube.position.set(-4, 2.5, 0) commonObj.scene.add(cube) // 调整相机位置 commonObj.camera.position.set(-25, 20, 25) // 镜头朝向舞台中央 commonObj.camera.lookAt(commonObj.scene.position) // 环境光 commonObj.scene.add(new THREE.AmbientLight()) document.body.appendChild(commonObj.renderer.domElement) commonObj.renderer.render(commonObj.scene, commonObj.camera)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之光源]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E5%85%89%E6%BA%90%2F</url>
    <content type="text"><![CDATA[光源也分为很多种 AmbientLight —- 环境光 PonitLight —- 点光源 SpotLight —- 聚光灯 DirectionalLight —- 平行光 然后还有各种高级的光照效果 光源种类描述 具体内容在站内搜索光源的关键字， 如：环境光， 篇幅太长不在此处描述 环境光 AmbientLight 基础光源， 影响整个场景的光源 点光源 PonitLight 空间中的一个点， 朝所有方向发射光源 聚光灯 SpotLight 具有锥形效果的聚光灯光源 平行光无限光， 模拟远处太阳的光辉 高级光照效果 半球光 平面光 镜头眩光]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js光源入门之聚光灯]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E8%81%9A%E5%85%89%E7%81%AF%2F</url>
    <content type="text"><![CDATA[聚光灯是一特殊的光源， 聚光灯能朝一个方向投射出锥形的光线。 基础特性 具有锥形效果的光源， 能够朝着一个方向投射光线 最常用到的光源， 它可以产生阴影 锥形效果， 类似电筒光照效果 光照效果样例 使用方式 THREE.SpotLight(hex, intensity, distance, angle, exponent) castShadow —- 如果设置为true, 这个光源就会产生阴影。target —- 决定光照方向。angle —- 光照的角度， 默认值是 Math.PI / 3 实践一下按照惯例， 我们测试灯光需要有几何物体才能体现出来， 因为聚光灯是中心最亮， 逐渐向外变暗， 所以我们创建几个立方体， 然后想办法摆动一下聚光灯的位置和角度看看具体效果 第一步-创建立方体12345678// 立方体var cubeGeometry = new THREE.BoxGeometry(5,5,5)var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;)var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)// 打开立方体的阴影cube.castShadow = truecube.position.set(-4, 2.5, 0)commonObj.scene.add(cube) // 调整相机位置 第二步-创建球体123456// 圆球var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)var sphreMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;)var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)sphere.position.set(20, 6, 0)commonObj.scene.add(sphere) 第三步-创建聚光灯创建聚光灯并将聚光灯的目标调整为刚才创建的 球体 123456789 // 聚光灯光源var spotLight = new THREE.SpotLight('#ffffff')spotLight.position.x = -40spotLight.position.y = 60spotLight.position.z = -12// 选择照射目标sphere.target = sphere// 加入场景commonObj.scene.add(spotLight) 第四步-用键盘控制聚光灯的角度及位置键盘方向的上下键控制聚光灯的角度，左右键控制聚光灯的位置 123456789101112131415161718192021222324// 设置初始角度var angleNUM = 3document.onkeydown = function (e) &#123; // 上键 控制聚光灯角度 switch(e.keyCode) &#123; case 38: angleNUM += 1 break; // 下键 case 40: angleNUM -= 1 if( angleNUM &lt; 1 ) &#123; angleNUM = 1 &#125; break // 左右键控制聚光灯位移 case 37: spotLight.position.x += 2 break case 39: spotLight.position.x -= 2 break &#125;&#125; 第五步-实时渲染在每一帧时根据当前的情况调整聚光灯的角度 12345function render() &#123; window.requestAnimationFrame(render) commonObj.renderer.render(commonObj.scene, commonObj.camera) spotLight.angle = Math.PI / angleNUM&#125; 最终效果该图中， 前半段我先按了上下键来调整聚光灯角度， 后半段我按了左右键来控制聚光灯位置 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;script src="../common/common.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script src="../SceneUtils.js"&gt;&lt;/script&gt;&lt;script src="../common/common.js"&gt;&lt;/script&gt;&lt;script&gt; var commonObj = common() // 立方体 var cubeGeometry = new THREE.BoxGeometry(5,5,5) var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;) var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 打开立方体的阴影 cube.castShadow = true cube.position.set(-4, 2.5, 0) commonObj.scene.add(cube) // 调整相机位置 // 圆球 var sphereGeometry = new THREE.SphereGeometry(4, 20, 30) var sphreMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;) var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial) sphere.position.set(20, 6, 0) commonObj.scene.add(sphere) commonObj.camera.position.set(-25, 20, 25) // 镜头朝向舞台中央 commonObj.camera.lookAt(commonObj.scene.position) // 聚光灯光源 var spotLight = new THREE.SpotLight('#ffffff') spotLight.position.x = -40 spotLight.position.y = 60 spotLight.position.z = -12 // 选择照射目标 sphere.target = sphere commonObj.scene.add(spotLight) function render() &#123; window.requestAnimationFrame(render) commonObj.renderer.render(commonObj.scene, commonObj.camera) spotLight.angle = Math.PI / angleNUM &#125; // 设置初始角度 var angleNUM = 3 document.onkeydown = function (e) &#123; // 上键 控制聚光灯角度 switch(e.keyCode) &#123; case 38: angleNUM += 1 break; // 下键 case 40: angleNUM -= 1 if( angleNUM &lt; 1 ) &#123; angleNUM = 1 &#125; break // 聚光灯位移 case 37: spotLight.position.x += 2 break case 39: spotLight.position.x -= 2 break &#125; &#125; render() document.body.appendChild(commonObj.renderer.domElement)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js光源入门之点光源]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E7%82%B9%E5%85%89%E6%BA%90%2F</url>
    <content type="text"><![CDATA[点光源是一种单点发光照亮物体的光源 基础介绍 照射所有方向的光源，例如照明弹 点光源是单点发光方式 点光源不会产生阴影， 减少GPU 的负担 调用方法1THREE.PointLight(hex, intensity, distance) clone() —- 复制当前颜色。 color 光源颜色 intensity —- 光照强度 distance —- 光源照射的距离 position —- 光源所在位置 测试点光源测试方法和大体上和环境光是一样的， 但是点光源和环境光不同的是， 他有个特点， 它能产生阴影 那我们就创建一个点光源和几个几何物体， 顺便移动一下点光源， 看看阴影是如何变化的 创建立方体1234567// 立方体var cubeGeomtry = new THREE.BoxGeometry(5,5,5)var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;)var cube = new THREE.Mesh(cubeGeomtry, cubeMaterial)cube.position.set(0, 6, 0)commonObj.scene.add(cube) 创建球体123456// 球体var sphereGeometry = new THREE.SphereGeometry(4, 20, 30)var sphreMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;)var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial)sphere.position.set(20, 6, 0)commonObj.scene.add(sphere) 创建点光源1234// 添加点光源var pointLight = new THREE.PointLight(0xffffff)pointLight.position.set(-40, 60, -10)commonObj.scene.add(pointLight) 让点光源动起来1234567function render() &#123; requestAnimationFrame(render) pointLight.position.z += 0.2 commonObj.renderer.render(commonObj.scene, commonObj.camera)&#125;render() 最终效果我们可以看到， 随着点光源的不断发生位置变动， 我们可以看到阴影发生逐渐的发生变化 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;script src="../common/common.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script src="../SceneUtils.js"&gt;&lt;/script&gt;&lt;script src="../common/common.js"&gt;&lt;/script&gt;&lt;script&gt; var commonObj = common() // 立方体 var cubeGeomtry = new THREE.BoxGeometry(5,5,5) var cubeMaterial = new THREE.MeshLambertMaterial(&#123; color: 0xff0000 &#125;) var cube = new THREE.Mesh(cubeGeomtry, cubeMaterial) cube.position.set(0, 6, 0) commonObj.scene.add(cube) // 球体 var sphereGeometry = new THREE.SphereGeometry(4, 20, 30) var sphreMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;) var sphere = new THREE.Mesh(sphereGeometry, sphreMaterial) sphere.position.set(20, 6, 0) commonObj.scene.add(sphere) commonObj.camera.position.set(-25, 30, 25) commonObj.camera.lookAt(commonObj.scene.position) // 添加点光源 var pointLight = new THREE.PointLight(0xffffff) pointLight.position.set(-40, 60, -10) commonObj.scene.add(pointLight) function render() &#123; requestAnimationFrame(render) pointLight.position.z += 0.2 commonObj.renderer.render(commonObj.scene, commonObj.camera) &#125; render() document.body.appendChild(commonObj.renderer.domElement)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】PureComponent解决了什么问题]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%90React%E3%80%91PureComponent%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[PureComponent 是和 shouldComponentUpdate这个生命周期息息相关的 React 重新渲染问题React中，当父组件中触发setState， 尽管未修改任何 state 中的值也会引起所有子组件的重新渲染， 更何况是修改了某个state 还有， 当父组件传给子组件的props 发生改变， 不管该props是否被子组件用到， 都会去重新渲染子组件。 其实我们也可以想得到， setState 会去触发 render， 所以父组件render函数中的子组件都会被重新渲染， 因此也就无关 state 与 props了 针对这个问题我实现了个例子， 来看一下下面这个例子 实现下问题 setState但未修改任何state 父组件触发 setState 方法, 但未更新任何state 123456789101112131415161718192021222324252627282930313233343536373839import TodoItem from './components/todoItem/todoItem'// 父组件代码class TodoList extends Component &#123; noChange() &#123; console.log('触发setState') this.setState(() =&gt; (&#123; &#125;)) &#125; render() &#123; const &#123; todoList &#125; = this.state return ( &lt;div className="wrap"&gt; &lt;button onClick=&#123;() =&gt; this.noChange()&#125;&gt;没有变化的setState&lt;/button&gt; &#123; todoList.map( (item,index) =&gt; &lt;TodoItem key=&#123;index&#125; data=&#123;item&#125; /&gt; ) &#125; &lt;/div&gt; ) &#125;&#125;// 子组件代码class TodoItem extends Component &#123; constructor(props) &#123; super(props) &#125; componentWillUpdate() &#123; console.log('我被更新了') &#125; render() &#123; return ( &lt;div&gt; &#123; this.props.data.thing &#125; &lt;/div&gt; ) &#125;&#125; 我们在子组件中预留了componentWillUpdate 方法， 用来监测子组件是否被跟新 123componentWillUpdate() &#123; console.log('我被更新了')&#125; 实验结果: 我们可以看到, 每一次的点击都引起了子组件的update 冷静分析问题无故的重复update, 这会导致业务规模扩大后十分的影响性能. 为此我监测了一下页面的重绘事件: 绿色区域是浏览器发成重绘的地方 可以看到todoList其实并没有引起浏览器的repaint , 因此可以推测, 实际dom并没有更新这在渲染页面前被dom diff给排除掉了, 因此性能损耗在了转换成Virtual DOM的过程中 shouldComponentUpdate shouldComponentUpdate(nextProps, nextState)， 默认返回true shouldComponentUpdate 是 React 中做性能优化的重要手段， 看这个英文翻译我们大概也能猜出个一二来 — ‘组件是否跟新？’ React 会根据 shouldComponentUpdate 的返回结果来决定该组件是否重新渲染， 如果返回True就渲染， 如果返回False就重新渲染 基于这个特性, 我们来修改一下上面问题中的代码 123456789101112131415// 父组件无变化, 因此省略// 子组件代码class TodoItem extends Component &#123; // ...省略其他原有的代码 // --------- 新增代码 ------------- shouldComponentUpdate(nextProps, nextState) &#123; // 判断下 当前 props传入的data.thing 是否和新传入的 data.thing 相同 return this.props.data.thing !== nextProps.data.thing &#125; // --------- 新增代码 -------------&#125; 实验结果: 我们可以看到update事件确实消失了 PureComponent看了shouldComponentUpdate函数的作用, 就能够理解PureComponent了? 它其实就是在帮我们做这样一件事: 自动的帮我们编写 shouldComponentUpdate 方法, 避免我们为每个组件都编写一次的麻烦 我们只需要这样, 就可以一步到位123import React, &#123; PureComponent &#125; from 'react'class TodoItem extends PureComponent &#123;&#125; 是不是感觉PureComponent很强大, 但PureComponent并不完美, 其实它还有一些潜藏的问题, 如果您想要继续了解, 请在站内搜索 immutable]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之相机]]></title>
    <url>%2F2019%2F04%2F03%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E7%9B%B8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[有两种相机 近交投影 正交投影 近交投影和真实世界中我们所看到的物体一样， 近大远小 透视投影照相机 THREE.PerspectiveCamera(fov, aspect, near, far) fov —- 视野宽度 aspect —- 长宽比， 推荐使用 window.innerWidth / window.innerHeight near —- 近裁面， 推荐值 0.1 far —- 远裁面， 推荐值 1000， 值太大影响性能， 值太小场景显示不全 正交投影 建模类软件使用的比较多 正交投影就像老师在黑板上画的立方体，保证三维世界平行的线到了二维世界也是平行的， 不存在近大远小的概念， 正交投影相机 THREE.OrthographicCamera(left, right, top, bottom, near, far) // near far决定远近范围 left —- 左边界 right —- 右边界 top —- 上边界 bottom —- 下边界 near —- 近裁面 far —- 远裁面 camera.lookAt —- 设置目标点 在Three中， 创建正交投影相机的参数决定了所看到的视景体, 视景体内部的物体才能显示在屏幕上，视景体外部的就会被裁剪掉 图中灰色区域就是视景体 摄影机效果比对说概念总是比较抽象， 我们来实际操作一下， 大概思路就是， 首先将立方体铺满平面， 然后我们使用定时器来切换相机类型 ， 以此来区别出两种相机的效果 第一步—-将立方体铺满平面利用我们之前设定的面的宽高， 计算出一列应该有多少立方体， 一行应该有多少立方体， 然后将其排列好， 添加入场景 1234567891011121314151617181920// 将立方体铺满屏幕var cubeGeometry = new THREE.BoxGeometry(4,4,4)for ( var j=0; j &lt; planeGeometry.parameters.height / 5 ;j++) &#123; // 面高 50 for ( var i=0; i &lt; planeGeometry.parameters.width / 5 ; i++) &#123; // 面宽 70 // 随机生成 var rnd = Math.random() * 0.75 + 0.25 // 添加材质 var cubeMaterial = new THREE.MeshLambertMaterial() // 添加颜色 cubeMaterial.color = new THREE.Color(rnd, 0, 0) // 创建立方体 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置立方体的位置 cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5) cube.position.y = 2 cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5) // 立方体加入场景 scene.add(cube) &#125;&#125; 第二步—-用键盘控制相机角度每当按下左右键时， 就调整相机的y 轴方向的旋转角度， 然后重新绘制场景 1234567891011121314151617// 绑定键盘事件document.onkeydown = function(e) &#123; switch(e.keyCode) &#123; case 37: camera.rotation.y += 0.02 render() break; case 39: camera.rotation.y -= 0.02 render() break; &#125;&#125;function render() &#123; renderer.render(scene, camera)&#125;render() 第三步—-利用定时器切换摄像机的模式利用定时器切换 相机的模式，然后就会在下次一用户按下键盘时被渲染出来 12345678910111213141516171819202122232425262728293031323334// 用于切换相机模式var controls = new function () &#123; this.perspective = "Perspective" this.switchCamera = function () &#123; if( camera instanceof THREE.PerspectiveCamera ) &#123; console.log('Orthographic') this.perspective = 'Orthographic' camera = new THREE.OrthographicCamera ( window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / -16, window.innerHeight / 16, -200, 500 ) camera.position.x = -20 camera.position.y = 60 camera.position.z = 50 camera.lookAt(scene.position) &#125;else &#123; console.log('Perspective') this.perspective = "Perspective" camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -20 camera.position.y = 60 camera.position.z = 50 camera.lookAt(scene.position) &#125; &#125;&#125;// 切换相机模式setInterval(() =&gt; &#123; controls.switchCamera()&#125;, 2000) 查看效果随着我不断地按下键盘的方向键， 画布被重新渲染， 我们可以看到两种相机的不同效果在来回切换 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script src="../SceneUtils.js"&gt;&lt;/script&gt;&lt;script&gt; // 设置场景, var scene = new THREE.Scene(); // 设置相机 视角, 宽度/高度, 近距离点, 远距点 var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -30 camera.position.y = 40 camera.position.z = 10 camera.lookAt(scene.position) // 看向场景的中央 // 设置绘制对象---基于Webgl的渲染器 var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xeeeeee)); // 控制渲染尺寸 renderer.setSize(window.innerWidth, window.innerHeight) // 打开阴影 renderer.shadowMapEnabled = true // 设置辅助测试工具 var axes = new THREE.AxisHelper(20) scene.add(axes) // 设置平面 var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色 var plane = new THREE.Mesh(planeGeometry, planeMaterial) // 设置旋转角度 plane.rotation.x = -0.5 * Math.PI; // 设置坐标 plane.position.x = 15 plane.position.y = 0 plane.position.z = 0 plane.receiveShadow = true // 加入场景 scene.add(plane) /* * * 添加材质和灯光 * * */ // 设置点光源 var spotLight = new THREE.SpotLight(0xffffff); // 设置位置 spotLight.position.set(-40, 60, -10) spotLight.castShadow = true // 添加进点光源 scene.add(spotLight) // --------------------------关键区域----------------------------------------- // 将立方体铺满屏幕 var cubeGeometry = new THREE.BoxGeometry(4,4,4) for ( var j=0; j &lt; planeGeometry.parameters.height / 5 ;j++) &#123; // 面高 50 for ( var i=0; i &lt; planeGeometry.parameters.width / 5 ; i++) &#123; // 面宽 70 // 随机生成 var rnd = Math.random() * 0.75 + 0.25 // 添加材质 var cubeMaterial = new THREE.MeshLambertMaterial() // 添加颜色 cubeMaterial.color = new THREE.Color(rnd, 0, 0) // 创建立方体 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置立方体的位置 cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5) cube.position.y = 2 cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5) // 立方体加入场景 scene.add(cube) &#125; &#125; // 用于切换相机模式 var controls = new function () &#123; this.perspective = "Perspective" this.switchCamera = function () &#123; if( camera instanceof THREE.PerspectiveCamera ) &#123; console.log('Orthographic') this.perspective = 'Orthographic' camera = new THREE.OrthographicCamera ( window.innerWidth / -16, window.innerWidth / 16, window.innerHeight / -16, window.innerHeight / 16, -200, 500 ) camera.position.x = -20 camera.position.y = 60 camera.position.z = 50 camera.lookAt(scene.position) &#125;else &#123; console.log('Perspective') this.perspective = "Perspective" camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -20 camera.position.y = 60 camera.position.z = 50 camera.lookAt(scene.position) &#125; &#125; &#125; // 切换相机模式 setInterval(() =&gt; &#123; controls.switchCamera() &#125;, 2000) // 绑定键盘事件 document.onkeydown = function(e) &#123; switch(e.keyCode) &#123; case 37: camera.rotation.y += 0.02 render() break; case 39: camera.rotation.y -= 0.02 render() break; &#125; &#125; function render() &#123; renderer.render(scene, camera) &#125; render() // --------------------------关键区域----------------------------------------- // 将renderer的输出挂到 body document.body.appendChild(renderer.domElement)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之几何和网格对象]]></title>
    <url>%2F2019%2F04%2F03%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E5%87%A0%E4%BD%95%E5%92%8C%E7%BD%91%E6%A0%BC%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[GeometryThree.js 中自带了很多的几何体， 我们可以直接使用他们的方法就可以轻松的创造出一个几何体， 比如: 创建一个面1new THREE.PlaneGeometry() 创建一个立方体1new THREE.CubeGeometry() 我们可以看到都带有Geometry 这个单词， 翻译过来也是“几何体”的意思其实这个THREE.Geometry是所有几何对象的基类( 简称 geom ) vertices顶点数组 翻译： 顶点 一个集合体我们可以看成是由几个顶点构成的， 比如一个立方体， 他就是由8个在空间中的顶点构成的。 在Three中， geom.vertices表示几何体的顶点， 它是一个数组 所以我们不但可以利用Three已有的几何体， 还可以自己提供顶点， 自己来创建一个集合体 faces 侧面 翻译: 面 geom.faces 表示几何体的侧面 动手创建一个立方体上面我们说了， 一个立方体， 由8个顶点 和 6个面构成， 如果让我们自己来实现， 我们就需要手动来创建下 定义8个顶点12345678910var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1)] 定义6个面因为在Three 中，可以理解为万物都由 三角形构成， 所以要想有正方形， 需要通过三角形创建( 以前支持直接创建正方形， 后来被删除 ) 123456789101112131415161718192021// 增加 6个面var faces = [ // 一个正方形由两个三角形构成 new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 5, 6), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 4, 4),] 生成几何物体刚刚我们配置的只是所需的数据， 现在我们要做的是将他合并成一个完整的几何体 12345// 创建几何体var geom = new THREE.Geometry()geom.vertices = verticesgeom.faces = facesgeom.computeFaceNormals() 添加材质如果控制带出现这个错误， 说明SceneUtils 已经被Three 独立拆除去了， 所以要想使用需要单独引入 123456789101112131415161718192021// 增加材质var materials = [ new THREE.MeshLambertMaterial(&#123; opacity: 0.5, color: 0x44ff44, transparent: true &#125;), new THREE.MeshBasicMaterial(&#123; color: 0x000000, wireframe: true &#125;)]// 构成物体var mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials)mesh.children.forEach( (e) =&gt; &#123; e.castShadow = true &#125;) 渲染场景加入到场景渲染一下我们刚刚创建的立方体12scene.add(mesh)renderer.render(scene, camera) 此时，我们可以看到画布上真的出现了一个立方体 网格对象的属性和函数 position 决定该对象相对于父对象的位置。 rotation 设置对象绕任何一个轴的旋转弧度 scale沿 x, y 和 z轴缩放对象 translateX x轴平移 translateY y轴平移 translateZ z轴平移 使用这些api移动一下我们刚刚创建的立方体吧 移动一下立方体123456// 平移mesh.position.x = 10mesh.position.y = 10mesh.position.z = 1// // 等同于// mesh.position.set(10, 10, 1) 此时效果 再旋转一下立方体1234// // 旋转mesh.rotation.x = 2mesh.rotation.y = 2mesh.rotation.z = 2 此时效果 缩放一下立方体我们可以针对某一个轴进行缩放， 这里我们缩放x轴， 其他轴同理 12// x 轴方向放大4倍mesh.scale.x = 4 此时效果 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script src="../SceneUtils.js"&gt;&lt;/script&gt;&lt;script&gt; // 设置场景, var scene = new THREE.Scene(); // 设置相机 视角, 宽度/高度, 近距离点, 远距点 var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -30 camera.position.y = 40 camera.position.z = 10 camera.lookAt(scene.position) // 看向场景的中央 // 设置绘制对象---基于Webgl的渲染器 var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xeeeeee)); // 控制渲染尺寸 renderer.setSize(window.innerWidth, window.innerHeight) // 打开阴影 renderer.shadowMapEnabled = true // 设置辅助测试工具 var axes = new THREE.AxisHelper(20) scene.add(axes) // 设置平面 var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色 var plane = new THREE.Mesh(planeGeometry, planeMaterial) // 设置旋转角度 plane.rotation.x = -0.5 * Math.PI; // 设置坐标 plane.position.x = 15 plane.position.y = 0 plane.position.z = 0 plane.receiveShadow = true // 加入场景 scene.add(plane) /* * * 添加材质和灯光 * * */ // 设置点光源 var spotLight = new THREE.SpotLight(0xffffff); // 设置位置 spotLight.position.set(-40, 60, -10) spotLight.castShadow = true // 添加进点光源 scene.add(spotLight) // 将renderer的输出挂到 body document.body.appendChild(renderer.domElement) renderer.render(scene, camera) // 定义一个方块 // 1.定义8个顶点 // 2. 6个面 var vertices = [ new THREE.Vector3(1, 3, 1), new THREE.Vector3(1, 3, -1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 3, -1), new THREE.Vector3(-1, 3, 1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, -1, 1) ] // 增加 6个面 var faces = [ // 一个正方形由两个三角形构成 new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 5, 6), new THREE.Face3(6, 7, 5), new THREE.Face3(4, 5, 1), new THREE.Face3(5, 0, 1), new THREE.Face3(7, 6, 2), new THREE.Face3(6, 3, 2), new THREE.Face3(5, 7, 0), new THREE.Face3(7, 2, 0), new THREE.Face3(1, 3, 4), new THREE.Face3(3, 4, 4), ] // 创建几何体 var geom = new THREE.Geometry() geom.vertices = vertices geom.faces = faces geom.computeFaceNormals() // 增加材质 var materials = [ new THREE.MeshLambertMaterial(&#123; opacity: 0.5, color: 0x44ff44, transparent: true &#125;), new THREE.MeshLambertMaterial(&#123; color: 0x000000, wireframe: true &#125;) ] // 构成物体 var mesh = new THREE.SceneUtils.createMultiMaterialObject(geom, materials) mesh.children.forEach( (e) =&gt; &#123; e.castShadow = true &#125; ) // 平移 mesh.position.x = 10 mesh.position.y = 10 mesh.position.z = 1 // // 等同于 // mesh.position.set(10, 10, 1) // // 旋转 mesh.rotation.x = 2 mesh.rotation.y = 2 mesh.rotation.z = 2 // // x 轴方向放大4倍 mesh.scale.x = 4 scene.add(mesh) renderer.render(scene, camera)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之添加动画]]></title>
    <url>%2F2019%2F04%2F03%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[本文基于”Three.js入门之添加材质和灯光” 文章之后 帧率辅助库 在官网下载到的three文件中的 /examples/js/libs/stats.min.js 可以找到 这个是一个three 开发者之一写的库， 可以给我提供检测动画流畅度的数据， 引入方式和three一样 如何使用呢， 创建一个dom我们给他预留一个dom123&lt;body&gt; &lt;div id="stats-output"&gt;&lt;/div&gt;&lt;/body&gt; 初始化统计对象1234567891011121314// 初始化统计对象function initStats() &#123; // 创建实例 var stats = new Stats() // 设置模式， 0 显示 fps, 1 检测渲染时间 stats.setMode(0) // 样式设置 stats.domElement.style.position = 'absolute' stats.domElement.style.left = "0px" stats.domElement.style.top = "0px" // 加入刚才的dom document.getElementById('stats-output').appendChild(stats.domElement) return stats&#125; 在每一帧动画期间更新因为这里我们的动画使用的是requestAnimationFrame, 所以我们在每次调用该方法时， 去更新一下统计对象即可 123456789function render() &#123; // 更新统计对象 stats.update() // 主循环 requestAnimationFrame(render) // 渲染当前的场景 renderer.render(scene, camera)&#125; 查看一下结果这些都做好以后，打开浏览器， 左上角就可以看到我们刚刚创建的统计对象了 创建动画因为js定时器的种种问题， 计时不准确， 无法预估浏览器算力等等问题， 所以requestAnimationFrame是我们做动画时的首选， 它可以根据浏览器的具体繁忙情况自动控制帧率 创建主循环先把之前的最后一步的渲染操作放入requestAnimationFrame 这个主循环， 1234567891011function render() &#123; stats.update() // 上面👆使用的帧率统计 // 回调传入自身 requestAnimationFrame(render) renderer.render(scene, camera)&#125; // 将renderer的输出挂到bodydocument.body.appendChild(renderer.domElement)render() 这样，我们的主循环就创建好了， 但是还不够， 如果你刷新浏览器， 你看到的依旧是静止的， 因为你的代码没有任何变化， 所以， 我们就尝试着让他发生一些变化 让正方体动起来我们让正方体旋转起来， 我们在每一帧都修改一下这个正方体的 x,y,z 坐标位置 123456789101112function render() &#123; stats.update() // 上面👆使用的帧率统计 // -------转动方块-------- cube.rotation.x += 0.02 cube.rotation.y += 0.02 cube.rotation.z += 0.02 // ---------------------- requestAnimationFrame(render) renderer.render(scene, camera)&#125; 就这三行代码就可以了， 让我们看看现在的效果 我们可以看到， 立方体运动行径诡异啊， 但是很cool 让球动起来让球动起来也很简单， 但是我们想让他动的稍微炫酷一点， 让他跳来跳去， 这就需要用到一点数学知识了， 利用三角函数我们实现一下球的弹跳 我们在函数外记录了一个 Step 用来每次增长， 然后球的x, y 就会每次都根据三角函数的曲线规律来造成一高一低的效果， 而且是抛物线 1234567891011121314151617var step = 0;function render() &#123; stats.update() // 转动方块 cube.rotation.x += 0.02 cube.rotation.y += 0.02 cube.rotation.z += 0.02 // --------球体跳跃------------ step += 0.04; sphere.position.x = 20 + ( 10 * Math.cos( step )) sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) )) // --------------------------- requestAnimationFrame(render) renderer.render(scene, camera)&#125; 看一下现在的效果图 全部代码 git地址: https://0x9.me/ohetH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="stats-output"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;!-- 游戏帧率辅助库 --&gt;&lt;script src="../stats.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 增加统计功能 var stats = initStats() // 设置场景, var scene = new THREE.Scene(); // 设置相机 视角, 宽度/高度, 近距离点, 远距点 var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -30 camera.position.y = 40 camera.position.z = 30 camera.lookAt(scene.position) // 看向场景的中央 // 设置绘制对象---基于Webgl的渲染器 var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xeeeeee)); // 控制渲染尺寸 renderer.setSize(window.innerWidth, window.innerHeight) // 打开阴影 renderer.shadowMapEnabled = true // 设置辅助测试工具 var axes = new THREE.AxisHelper(20) scene.add(axes) // 设置平面 var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色 var plane = new THREE.Mesh(planeGeometry, planeMaterial) // 设置旋转角度 plane.rotation.x = -0.5 * Math.PI; // 设置坐标 plane.position.x = 15 plane.position.y = 0 plane.position.z = 0 plane.receiveShadow = true // 加入场景 scene.add(plane) // 设置立方体 var cubeGeometry = new THREE.CubeGeometry(4, 4, 4) //设置宽高和段度 // 设置基础材质 var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;) // 设置颜色和打开线框 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置坐标 cube.position.x = 4 cube.position.y = 3 cube.position.z = 0 cube.castShadow = true // 加入场景 scene.add(cube) // 设置球面体 var sphereGemometry = new THREE.SphereGeometry(4, 20, 20) var sphereMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;) var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial) sphere.position.x = 20 sphere.position.y = 4 sphere.position.z = -2 sphere.castShadow = true scene.add(sphere) /* * * 添加材质和灯光 * * */ // 设置点光源 var spotLight = new THREE.SpotLight(0xffffff); // 设置位置 spotLight.position.set(-40, 60, -10) spotLight.castShadow = true // 添加进点光源 scene.add(spotLight) /* * * 引入动画 * * */ var step = 0; function render() &#123; stats.update() // 转动方块 cube.rotation.x += 0.02 cube.rotation.y += 0.02 cube.rotation.z += 0.02 // 球体跳跃 step += 0.04; sphere.position.x = 20 + ( 10 * Math.cos( step )) sphere.position.y = 2 + ( 10 * Math.abs( Math.sin(step) )) requestAnimationFrame(render) renderer.render(scene, camera) &#125; /* * * 输出 * * */ // 初始化统计对象 function initStats() &#123; var stats = new Stats() stats.setMode(0) // 0 显示fps, 1 检测渲染时间 stats.domElement.style.position = 'absolute' stats.domElement.style.left = "0px" stats.domElement.style.top = "0px" document.getElementById('stats-output').appendChild(stats.domElement) return stats &#125; // 将renderer的输出挂到body document.body.appendChild(renderer.domElement) render()&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之添加材质和灯光]]></title>
    <url>%2F2019%2F04%2F03%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B7%BB%E5%8A%A0%E6%9D%90%E8%B4%A8%E5%92%8C%E7%81%AF%E5%85%89%2F</url>
    <content type="text"><![CDATA[本文基于”Three.js入门之绘制三维对象” 文章之后 材质与光源可以对光产生反应的材质 MeshLamberMaterial 材质 MeshPhongMaterial 材质 加入阴影效果 添加灯光12345var spotLight = new THREE.SpootLight(0xffffff);// 设置位置spotLight.position.set(-40, 60, -10)// 将光源添加进场景scene.add(spotLight) 当我们将三维物体的所有材质都替换为MeshLamberMaterial 时, 效果如下 我们看到这些三维物体上确实都有了些反光的效果 但是， 有反光还不够， 既然有光那肯定要有阴影， 但是绘制阴影是比较耗费性能的，所以Three.js 默认不会打开， 但是我们想绘制也是比较容易的 给各个物体打开阴影首先给绘制对象打开阴影设置1renderer.shadowMapEnabled = true 然后将几个三维对象分别打开123456789101112// 打开面的阴影plane.receiveShadow = true//........// 打开立方体的阴影cube.castShadow = true//........// 打开球面体的阴影sphere.castShadow = true 最后还需要给光源定义一下阴影， 让他可以生成阴影 1spotLight.castShadow = true 最终效果添加完阴影后，我们刷新一下浏览器， 阴影出来了， 只是有些粗糙 完整代码 git地址: https://0x9.me/ohetH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;script&gt; // 设置场景, var scene = new THREE.Scene(); // 设置相机 视角, 宽度/高度, 近距离点, 远距点 var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -30 camera.position.y = 40 camera.position.z = 30 camera.lookAt(scene.position) // 看向场景的中央 // 设置绘制对象---基于Webgl的渲染器 var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xeeeeee)); // 控制渲染尺寸 renderer.setSize(window.innerWidth, window.innerHeight) // 打开阴影 renderer.shadowMapEnabled = true // 设置辅助测试工具 var axes = new THREE.AxisHelper(20) scene.add(axes) // 设置平面 var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色 var plane = new THREE.Mesh(planeGeometry, planeMaterial) // 设置旋转角度 plane.rotation.x = -0.5 * Math.PI; // 设置坐标 plane.position.x = 15 plane.position.y = 0 plane.position.z = 0 plane.receiveShadow = true // 加入场景 scene.add(plane) // 设置立方体 var cubeGeometry = new THREE.CubeGeometry(4, 4, 4) //设置宽高和段度 // 设置基础材质 var cubeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xff0000&#125;) // 设置颜色和打开线框 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置坐标 cube.position.x = 4 cube.position.y = 3 cube.position.z = 0 cube.castShadow = true // 加入场景 scene.add(cube) // 设置球面体 var sphereGemometry = new THREE.SphereGeometry(4, 20, 20) var sphereMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x7777ff &#125;) var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial) sphere.position.x = 20 sphere.position.y = 4 sphere.position.z = -2 sphere.castShadow = true scene.add(sphere) /* * * 添加材质和灯光 * * */ // 设置点光源 var spotLight = new THREE.SpotLight(0xffffff); // 设置位置 spotLight.position.set(-40, 60, -10) spotLight.castShadow = true // 添加进点光源 scene.add(spotLight) /* * * 输出 * * */ // 将renderer的输出挂到body document.body.appendChild(renderer.domElement) renderer.render(scene, camera)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】命令手册]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90Linux%E3%80%91%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[linux 只有区的概念 终端快捷键 命令 功能 ctrl + c 结束正在运行的程序 【 ping 、 teInet等】 ctrl + d 结束输入或退出shell ctrl + s 暂停屏幕输出 ctrl + q 恢复屏幕输出 ctrl + l 清屏， 等同于Clear ctrl + a / ctrl + e 快速移动光标到行首 / 行尾 身份命令 命令 功能 sudo 暂时以root 用户身份运行命令 su 切换用户身份, root身份切换不需要密码 exit 退出当前身份或退出连接 w 查看正在登录用户 路径知识 Linux下文件前带.表示隐藏文件 一个.代表当前目录, 两个..代表上级目录 资源目录相关命令 a是显示隐藏文件, l是显示长列表格 命令 说明 ls 或 dir 查看当前目录内容 ls -l 显示长格式目录, 有创建时间,修改信息, 文件大小 ls -a 显示隐藏文件 ls -al 查看目录所有对应的权限( ) pwd 宣誓当前目录的全部路径 cd ~ 进入到当前分配home目录下的用户区域, 比如/home/nxl cd / 进入系统的根目录 文件命令 [old] 表示旧文件 [new] 表示操作后的文件 [target] 目标文件 [targetDir] 目标目录 命令 说明 mkdir 创建文件夹 rmdir 删除文件 touch [new] 创建文件 rm [target] 删除文件 rm -r [targetDir] 删除文件夹 rm -rf * 删除所有内容(r递归, f强制) cp [old] [test/new] 复制文件 cp [old] -R [test/new] 复制目录 ln -s old new 建立软链 界面切换命令 init [number] 命令 说明 0 关机 1 单用户 2 多用户状态没有网络服务 3 多用户状态有网络服务(就是平时的小黑窗) 4 系统未使用保留给用户 5 图形界面 6 系统重启 服务 / 进程管理命令 命令 说明 systemctl 查看进程 ststemctl [ status , start , stop , restart ] nginx 如对 nginx 执行相关命令 top 进程资源实时状态 ps [aux] 进程快照 kill [-9] pid 杀死进程 pkill [name] 根据进程名杀死进程 网络管理命令 命令 说明 ifconfig 查看网络接口（ interface） ip 网络配置工具箱 route 诊断网络 ipdown eth0 关闭eth0网卡 ipup eth0 开启eth0网卡 ss -anp , grep :22 查找占用端口情况 netstat -anp , grep :22 查找占用端口情况 命令行下载命令 命令 说明 curl 查看网络接口（ interface） wget 网络配置工具箱 wget -c 断点续传 vi / vim 行编辑器 vim是vi的增强版 命令 说明 vi [target] 编辑目标文件 cat [target] 查看文件内容 i (insert) 在当前光标所在字符的前面，转为编辑模式； a (append) 在当前光标所在字符的后面，转为编辑模式； o 在当前光标所在行的下方，新建一行，并转为输入模式； I 在当前光标所在行的行首，转换为输入模式 A 在当前光标所在行的行尾，转换为输入模式 O 在当前光标所在行的上方，新建一行，并转为输入模式； esc 退出编辑, ubuntu 需要 esc + : :q 退出编辑 :q! 强制退出 :wq 退出并保存 系统操作命令 命令 说明 ！ 强制执行命令 shutdown -h now 立刻关机 shutdown -r now /reboot 立刻重启计算机 su - root 先用普通账户登录再切换 sudo临时已管理员操作 logout 用户注销 帮助命令 命令 说明 –help 查看命令帮助 man xxx 查看详细手册 辅助命令 命令 说明 0 关机]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SSR】nuxt.js服务端渲染体验笔记]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90SSR%E3%80%91nuxt-js%E4%BD%93%E9%AA%8C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[官网: https://zh.nuxtjs.org/ 这段时间公司招了个专门搞seo优化的, 经过他的建议我们需要整改一系列之前没有注意的细节来提升SEO的优化 给我们提出了大致以下的建议 对非必要跟踪的页面的a标签添加 noffollow属性 需要对首页的meta的title,keyword, description进行设置, 而且要避免大写 网页静态化, 使用 /路由参数, 而不是query形式的参数(?) 去掉无关页面的keyword和 description标签 必须要有404页面 提供一个专门给爬虫爬取的新闻栏目, 并且入口对用户不可见 生成sitemap.html和sitemap.xml文件, 并在网站底部”链接”的地方以”网站地图”和”XML”添加 配置robots.txt文件 需要SSR 最后一点也就是工程量最大的一点–SSR, 就是使用Nuxt.js的目的 怎么起步就不说了, 官网写的很好, 这里就记录一下本次尝试中花了比较多的时间去理解的地方, 以及坑 compoents 和 pages目录顾名思义, Pages 文件夹应该存放的是页面, components应该是组件, 这其实在最开始是比较容易混淆的, 在我们平时习惯性的使用vue的时候, 一个vue文件既可以作为组件也可以作为页面, 但在 Nuxt 中是类似但不完全相同, pages 中的页面组件具有被强化的几个方法 而components 则确实是组件的定义, 它就是最普通的vue组件 可选与必选动态路由Nuxt.js 的路由按照pages 文件夹的具体目录结构自动划分, 动态路由也是如此, 但动态路由可被分为可选和必选, 可选路由, 访问路径demo: people/12312345pages/--| people/-----| _id.vue--| _.vue--| index.vue 这样的结构是 必选路由, 访问路径demo: people/123/456 同时可接收 123 和 456 两个参数, 并且 123 参数必须有1234567pages/--| people/-----| _id/---------| _id.vue---------| index.vue--| _.vue--| index.vue 404页面_.vue 可以用来充当路由未被匹配上的情况, 所以我们需要的404页面就可以使用_.vue来编写, 放在pages目录下 123pages/--| _.vue--| index.vue 使用axios必须要在nuxt.config.js中添加关于axios的配置, 才能使用this.$axios访问到1234567891011121314axios: &#123; proxy: true, prefix: 'http://jsonplaceholder.typicode.com', // baseURL credentials: true,&#125;,proxy: &#123; '/api/': &#123; target: 'http://127.0.0.1:2001', // 代理地址 changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125;, &#125;,&#125;, 使用axios不需要创建 vuex实例只需要把你的 state,getters等等导出即可, 命名空间的方式也是如此,只需要多建一个文件即可 如下:store/index.js1234567891011121314export const state = () =&gt; (&#123; userInfo: 0&#125;)export const getters = &#123; getUserInfo (state) &#123; return state.userInfo &#125;&#125;export const mutations = &#123; setUserInfo (state, data) &#123; state.userInfo = data &#125;&#125; fetch.js1234567891011121314export const state = () =&gt; (&#123; posts: null&#125;)export const getters = &#123; getPosts (state) &#123; return state.posts &#125;&#125;export const mutations = &#123; setPosts (state, data) &#123; state.posts = data &#125;&#125; 使用fetch中的state时:12345// 写数据this.$store.commit('fetch/setPosts', res.data)// 取数据this.posts = this.$store.getters['fetch/getPosts'] 服务端与客户端数据传递利用vuex里提供的nuxtServerInit, Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟） 举个例子，假设我们服务端的会话状态树里可以通过 req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下：1234567actions: &#123; nuxtServerInit (&#123; commit &#125;, &#123; req &#125;) &#123; if (req.session.user) &#123; commit('user', req.session.user) &#125; &#125;&#125; 如果你使用状态树模块化的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。 生命周期的调用环境在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。]]></content>
      <categories>
        <category>SEO</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>SSR</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【React】高阶用法]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90React%E3%80%91%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[默认参数 当未传入props时使用预设的默认值 使用静态属性defaultProps来定义props的默认值, 避免未传props报错的情况123static defaultProps = &#123; thing: "这是默认的props参数"&#125; demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546// todoList.jsxclass TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; todoList: [ &#123; thing: '喝可乐' &#125;, &#123; thing: '打游戏' &#125;, // 故意留空一个 &#123; &#125;, &#123; thing: '看电影' &#125;, &#123; thing: '看剧' &#125;, &#123; thing: '刷抖音' &#125;, &#123; thing: '吃饭' &#125; ] &#125; &#125; render() &#123; const &#123; todoList &#125; = this.state return ( &lt;div className="wrap"&gt; &#123; todoList.map( item =&gt; &lt;TodoItem thing=&#123;item.thing&#125; /&gt;) &#125; &lt;/div&gt; ) &#125;&#125;// todoItem.jsxclass TodoItem extends Component &#123; constructor(props) &#123; super(props) &#125; static defaultProps = &#123; thing: "这是默认的props参数" &#125; render() &#123; return ( &lt;div&gt; &#123; this.props.thing &#125; &lt;/div&gt; ) &#125;&#125; 实际显示: 自由的render返回值类型 render函数的要求没有以前严格了， 不用固定返回dom 以及 免除必须使用()包裹 返回dom12345class Demo extends Component &#123; render() &#123; return &lt;div&gt;Hello React&lt;/div&gt; &#125;&#125; 返回字符串12345class Demo extends Component &#123; render() &#123; return 'Hello React' &#125;&#125; 返回数组123456789class Demo extends Component &#123; render() &#123; return [ &lt;li&gt;1111&lt;/li&gt;, &lt;li&gt;2222&lt;/li&gt;, &lt;li&gt;3333&lt;/li&gt;, ] &#125;&#125; 空的根节点 避免了无故地嵌套 写法一：123456789class Demo extends Component &#123; render() &#123; return &lt;&gt; &lt;li&gt;hello world1&lt;/li&gt; &lt;li&gt;hello world2&lt;/li&gt; &lt;li&gt;hello world3&lt;/li&gt; &lt;/&gt; &#125;&#125; 写法二 ：123456789101112// 使用文档片段import React, &#123; Component, Fragment &#125; from 'react'class Demo extends Component &#123; render() &#123; return &lt;Fragment&gt; &lt;li&gt;hello world1&lt;/li&gt; &lt;li&gt;hello world2&lt;/li&gt; &lt;li&gt;hello world3&lt;/li&gt; &lt;/Fragment&gt; &#125;&#125; 两种写法的效果是一样的： PureComponent 自动为状态组件添加shouldComponentUpdate函数 1234import React, &#123; PureComponent &#125; from 'react'class TodoItem extends PureComponent &#123; &#125; 更安全的数据类型使用immutableJs 处理异步任务及组件站内搜索 react16.6中如何处理异步 为函数组件做性能优化站内搜索 memo 新版ref用法站内搜索 react16中如何使用ref]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门之绘制三维对象]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Plane ( 平面 ) 二维矩形，渲染结果是在屏幕中央有个灰色矩形 Cube (方块) 三维立方体。 Sphere ( 球体 ) 三维球体。 Camera ( 相机 ) 决定视点的位置， 和最终观察结果 Axes ( 轴 ) 辅助测试工具 第一步-设置场景变量Scene是一个容器， 它用来保存并且跟踪我们想渲染的物体1var scene = new THREE.Scene(); 具体内容我们后续会添加到 scene中 第二步-设置相机camera用来控制我们所看到的方向角度12345678// 设置相机 视角, 宽度/高度, 近距离点, 远距点var camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000)// 设置坐标camera.position.x = -30camera.position.y = 40camera.position.z = 30// 设置朝向camera.lookAt(scene.position) // 看向场景的中央 第三步-设置绘制对象我们创建一个基于webgl的渲染器, 当然还有其他的渲染器( canvas ,svg渲染器等)12345var renderer = new THREE.WebGLRenderer()// 设置背景颜色renderer.setClearColor(new THREE.Color(0xeeeeee));// 控制渲染尺寸renderer.setSize(window.innerWidth, window.innerHeight) 第四步-设置辅助测试工具123// 设置辅助测试工具var axes = new THREE.AxisHelper(20)scene.add(axes) 第五步-创建集合体创建一个平面123456789101112// 设置平面var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色var plane = new THREE.Mesh(planeGeometry, planeMaterial)// 设置旋转角度plane.rotation.x = -0.5 * Math.PI;// 设置坐标plane.position.x = 15plane.position.y = 0plane.position.z = 0// 加入场景scene.add(plane) 创建一个立方体1234567891011// 设置立方体var cubeGeometry = new THREE.CubeGeometry(4, 4, 4) //设置宽高和段度// 设置基础材质var cubeMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, wireframe: true&#125;) // 设置颜色和打开线框var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)// 设置坐标cube.position.x = 4cube.position.y = 3cube.position.z = 0// 加入场景scene.add(cube) 创建一个球体12345678// 设置球面体var sphereGemometry = new THREE.SphereGeometry(4, 20, 20)var sphereMaterial = new THREE.MeshBasicMaterial(&#123; color: 0x7777ff, wireframe: true &#125;)var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial)sphere.position.x = 20sphere.position.y = 4sphere.position.z = -2scene.add(sphere) 最后一步-输出到body123// 将renderer的输出挂到bodydocument.body.appendChild(renderer.domElement)renderer.render(scene, camera) 最终效果 完整代码 git地址: https://0x9.me/ohetH 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;第一个ThreeJs&lt;/title&gt;&lt;/head&gt;&lt;style&gt; body &#123; margin: 0; overflow: hidden; &#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;script src="../three.js"&gt;&lt;/script&gt;&lt;script&gt; // 设置场景, var scene = new THREE.Scene(); // 设置相机 视角, 宽度/高度, 近距离点, 远距点 var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000) camera.position.x = -30 camera.position.y = 40 camera.position.z = 30 camera.lookAt(scene.position) // 看向场景的中央 // 设置绘制对象---基于Webgl的渲染器 var renderer = new THREE.WebGLRenderer() renderer.setClearColor(new THREE.Color(0xeeeeee)); // 控制渲染尺寸 renderer.setSize(window.innerWidth, window.innerHeight) // 设置辅助测试工具 var axes = new THREE.AxisHelper(20) scene.add(axes) // 设置平面 var planeGeometry = new THREE.PlaneGeometry(70, 50, 1, 1) //设置宽高和段度 var planeMaterial = new THREE.MeshLambertMaterial(&#123;color: 0xcccccc&#125;) // 设置颜色 var plane = new THREE.Mesh(planeGeometry, planeMaterial) // 设置旋转角度 plane.rotation.x = -0.5 * Math.PI; // 设置坐标 plane.position.x = 15 plane.position.y = 0 plane.position.z = 0 // 加入场景 scene.add(plane) // 设置立方体 var cubeGeometry = new THREE.CubeGeometry(4, 4, 4) //设置宽高和段度 // 设置基础材质 var cubeMaterial = new THREE.MeshBasicMaterial(&#123;color: 0xff0000, wireframe: true&#125;) // 设置颜色和打开线框 var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // 设置坐标 cube.position.x = 4 cube.position.y = 3 cube.position.z = 0 // 加入场景 scene.add(cube) // 设置球面体 var sphereGemometry = new THREE.SphereGeometry(4, 20, 20) var sphereMaterial = new THREE.MeshBasicMaterial(&#123; color: 0x7777ff, wireframe: true &#125;) var sphere = new THREE.Mesh(sphereGemometry, sphereMaterial) sphere.position.x = 20 sphere.position.y = 4 sphere.position.z = -2 scene.add(sphere) // 将renderer的输出挂到body document.body.appendChild(renderer.domElement) renderer.render(scene, camera)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Three】Three.js入门学习笔记]]></title>
    <url>%2F2019%2F04%2F02%2F%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介WebGL是基于OpenGl ES 2.0的Web标准， 可以通过HTML5 Canvas 元素作为Dom接口访问。 WebGl 灵活且复杂。 Three.js 是一个3D JavaScript 库， Three.js 库可简化 WebGL 开发。 Three.js 封装了底层的图形接口， 能够在无需掌握繁冗的图形学知识的情况下， 也能用简单的代码实现三位场景的渲染 Three.js用途 创建三维图形 在三维场景中生成动画 在物体上应用纹理和材质。 从三维建模软件中加载图形 创建基于样条曲线的二维图形 其他web3D引擎插件式: Flash O3D Unity3d 原生: GLGE X3DOM PhiloGL CopperLicht 优势 浏览器原生支持， 不需要安装插件 对操作系统、 浏览器兼容性高， 支持移动平台 基于HTML5/WebGL, 是 Web开发的主流； 开发维护非常活跃 组件及案例丰富， 易于学习掌握； 设计优雅、 灵活， 方便以及增加新的特性 基于 WebGL/OpenGL ES 2.0 使用熟悉的HTML/JavaScript 对底层的WebGl的高级封装 保留底层开发的特性 结构严谨灵活、 易于扩展]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解CPU工作原理]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BA%86%E8%A7%A3CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机在被发明出来之后， 结构基本上没有怎么改变， 目前使用最广泛的结构是“冯诺依曼结构” 冯诺依曼结构 维基百科传送门 简单而言的冯诺依曼结构处理器具有以下几个特点: 必须有一个存储器； 必须有一个控制器； 必须有一个运算器，用于完成算术运算和逻辑运算； 必须有输入和输出设备，用于进行人机通信。 并且还有和冯诺依曼不一样的另一种结构: 哈佛结构 CPU的指令集指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序 说人话:指令集就是你驱动CPU运算发送的指令 x86/x64指令集这两种是我们目前最普遍的台式机和笔记本的CPU种类， ARM指令集在我们的移动设备上、 智能手表上、只能音响上 MIPS指令集一般用在服务器上， 并且是大型的服务器 RISC指令集这属于一种精简指令， 也可以认为是一种开源的指令集 中国曾经自己研发的芯片 龙芯， 还有中国的超级计算机也是使用的这个指令集 🌗如何兼容各指令集指令集是CPU原生支持的语言，不同的指令集之间是不能互换的， 所以C语言在编译的时候有一种方式叫交叉编译： 你在X64系列的CPU上去给ARM的CPU去编译程序，这就是交叉编译。 这也是做嵌入式的就比较常用这些东西。 CPU的组成 控制器 运算器 存储器 存储器存储器的主要功能是存储程序和各种数据，并能在计算机运行过程中高速、自动地完成程序或数据的存取。 他是CPU上的缓存， 它相当于是我们考试时的草稿纸, 在上面写的只是运算过程， 而最终答案是写到答题纸上的(内存) 运算器算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。 控制器控制单元又分为： 指令计数器、 指令寄存器 控制负责协调运算器和存储器之间的工作 总之，控制器相当于指挥官, 运算单元相当于士兵， 存储器相当于仓库， 指挥官指挥士兵在存库中搬弹药，做工作 CPU如何与内存沟通计算机中的数据分为两种 代码段 —- 指令数据（我们写的代码） 数据段 —- 纯粹的数据（比如电影文件） 代码段和数据段一般是分开存放的， 一定要放一起也不是不可以， 但是很有可能回引起很严重的安全问题– 缓冲区溢出，看下面的安全问题区域 👇 指令计数器从代码段中找出一段指令， 放到指令寄存器中(指令寄存器可以理解为CPU中一块特殊的内存, 但是它只能放指令， 如果存数据就会宕机)， 放到指令寄存器中后， 控制器就开始根据这个指令具体的内容，把数据送入运算器， 数据从哪里来， 控制器通过数据总线从内存中拿到数据然后送入存储单元，供运算器使用 🔥安全问题🌊 缓冲区溢出在代码段插入一些数据， 或是插入一些异常的跳转指令， 本来程序中的跳转是体现在if`else或者是for循环， 这些跳转语句在计算机底层会被转换成jmp`指令，从这个地方跳转到另一个地方去执行， 当你跳到另一段代码那， 这段代码就开始执行了， 也就是如果代码是经过精心设计的， 跳转到的目标代码段不是你原本想要的代码段， 而目标代码段要做危险操作， 那就危险大了， 这就是缓冲区溢出。 比如前两年的漏洞： 心脏滴血 经典的8086CPU结构体系8086是一种比较早的商业化处理器芯片]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待学书籍]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%BE%85%E5%AD%A6%E4%B9%A6%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[图形学 《高中数学必修123》 线性代数 离散数学]]></content>
      <categories>
        <category>目录</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现一个bind]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind%2F</url>
    <content type="text"><![CDATA[bind方法用来保留JavaScript的this指向， 和apply、call这两个方法不同的是，bind不会立即执行 如何模拟实现一个bind方法 初始函数，我们将对整个函数修改this指向12345function fn( name ) &#123; this.name = name&#125;var obj = &#123; age: 18 &#125; 最普通的实现创建一个函数1234567function mybind(func ,context, ...args) &#123; return () =&gt; &#123; return func.apply(context, args ) &#125;&#125;var bindFn = mybind(fn, obj, '小明') 原型实现创建一个函数12345678Function.prototype.mybind = function(context, ...args) &#123; const _this = this return (...args2) =&gt; &#123; return _this.apply( context, [ ...args, ...args2] ) &#125; &#125;var bindFn = fn.mybind(obj, '小明' ) 实现很简单， 但是还差一步，就是bind后的函数， 拿来作为构造函数new时， this指向会出问题 处理new 的指向123456789Function.prototype.mybind = function(context, ...args) &#123; const _this = this function cbFn (...tempArgs) &#123; return this instanceof cbFn ? _this.apply(this, [ ...args, ...tempArgs]) : _this.apply( context, [ ...args, ...tempArgs] ) &#125; return cbFn&#125;var BindFn = fn.mybind(obj, '小明' )var bfn = new BindFn() 参考文献 https://github.com/mqyqingfeng/Blog/issues/13]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的软绑定和硬绑定]]></title>
    <url>%2F2019%2F03%2F30%2Fthis%E7%9A%84%E8%BD%AF%E7%BB%91%E5%AE%9A%E5%92%8C%E7%A1%AC%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[被调用的函数示例1234function fn() &#123; // 如果严格模式， "use strict"加在此处 console.log(this)&#125; 软绑定1fn() // window “use strict” 严格模式的软绑定 1fn() // undefined 硬绑定1fn.apply(&#123;&#125;,['a']) // &#123;&#125; 忽略硬绑定， 使用软绑定1fn.apply(null,['a']) // window “use strict” 严格模式12fn.apply(&#123;&#125;,['a']) // &#123;&#125;fn.apply(null,['a']) // null]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Iaas、PaaS、SaaS的区别]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%90%86%E8%A7%A3Iaas%E3%80%81PaaS%E3%80%81SaaS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。 😦Iaas 比如: 普通的云服务器 现在你追随潮流，采用流行的云计算，如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件。 😧PaaS 比如: 阿里云的虚拟机 而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序 😨SaaS 如淘宝对于商家 如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。 参考文献 https://www.zhihu.com/question/20387284]]></content>
      <categories>
        <category>专业术语</category>
      </categories>
      <tags>
        <tag>专业术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【容器】搭建第一个docker环境]]></title>
    <url>%2F2019%2F03%2F28%2F%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[初始化一个NodeJs程序以下操作必须已经安装了了NodeJS。首先创建一个空文件夹。并创建以下⽂文件： server.js package.json Dockerfile .dockerignore 123456mkdir docker_democd docker_demotouch server.jstouch package.jsontouch Dockerfiletouch .dockerignore 然后在server.js写⼊入 123456const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello docker';&#125;);app.listen(3000); 在package.json中写入 1234567891011&#123; "name": "docker_demo", "version": "0.1.0", "private": true, "scripts": &#123; "start": "node server.js" &#125;, "dependencies": &#123; "koa": "^2.5.0" &#125;&#125; 测试程序。控制台输⼊1npm start 浏览器打开本地测试,如果如图所示。表示demo创建成功。请继续往下。 创建dockerfile文件Dockerfile是由一系列命令和参数构成的脚本，一个Dockerfile⾥里里⾯面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列列命令自动构建image. 在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore 1234567891011121314151617181920212223242526272829303132# Logslogs*.lognpm-debug.log*# Runtime datapids*.pid*.seed# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov# Coverage directory used by tools like istanbulcoverage# nyc test coverage.nyc_output# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt# node-waf configuration.lock-wscript# Compiled binary addons (http://nodejs.org/api/addons.html)build/Release# Dependency directoriesnode_modulesjspm_packages# Optional npm cache directory.npm# Optional REPL history.node_repl_history.idea.node_modulesnode_modules.vscode 在Dockerfile文件中写入以下代码：1234567891011121314#制定node镜像的版本FROM node:8.9-alpine#声明作者MAINTAINER evilboy#移动当前⽬目录下⾯面的⽂文件到app⽬目录下ADD . /app/#进⼊入到app⽬目录下⾯面，类似cdWORKDIR /app#安装依赖RUN npm install#对外暴暴露露的端⼝口EXPOSE 3000#程序启动脚本CMD ["npm", "start"] 构建镜像 使用build命令构造镜像,注意后⾯面那个“.”不不能少。 1234567891011121314151617181920212223242526272829[root@Sandbox-N ~]# docker build -t docker_demo .Sending build context to Docker daemon 39.94kBStep 1/7 : FROM node:8.9-alpine---&gt; 406f227b21f5Step 2/7 : MAINTAINER robin---&gt; Using cache---&gt; 78d6cdbcfee2Step 3/7 : ADD . /app/---&gt; 2cb30678612dStep 4/7 : WORKDIR /appRemoving intermediate container e51377081039---&gt; c2b7d0f37d2dStep 5/7 : RUN npm install---&gt; Running in da0c3946ca8dnpm notice created a lockfile as package-lock.json. You should committhis file.added 38 packages in 3.323sRemoving intermediate container da0c3946ca8d---&gt; eecee87f10e2Step 6/7 : EXPOSE 3000---&gt; Running in f3973cc168a4Removing intermediate container f3973cc168a4---&gt; 2671a4c6deb4Step 7/7 : CMD ["npm", "start"]---&gt; Running in dec529f754aaRemoving intermediate container dec529f754aa---&gt; 6ec73793d353Successfully built 6ec73793d353Successfully tagged docker_demo:latest 等待镜像构造完成。然后使用 images命令查看镜像。 此时可以看到images已经构造完成。现在开始启动images，并测试。 12345#启动镜像 -d表示后台执⾏行行，-p 9000:3000表示指定本地的9000端⼝口隐射到容器器内的3000端⼝口，docker_demo为镜像名称docker run -d -p 9000:3000 docker_demo#查看容器器docker ps 此时浏览器打开http://localhost:9000/,如果如图所示。表示容器运行正常。 如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单理解破解与脱壳]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%A0%B4%E8%A7%A3%E4%B8%8E%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[什么是壳想要破解别人的程序， 必然要对别人代码进行分析， 分析手段无非两种: 静态分析 动态分析 利用动态分析就可以绕过类似注册码的步骤 如何避免别人通过分析绕过注册码等步骤呢， 就需要对程序加一层壳， 当你程序在载入到内存的时候， 要先去检查一下环境，看看自身是否跑在调试器的环境里， 如果在调试器的环境，就要把调试器的环境破坏掉，不让你进行动态分析， 这就是加壳的一种手段 或者还有其他的手段， 例如，把真正的程序压缩到其他地方， 当启动exe程序时再将真正的程序解压缩， 用来防止动态分析 脱壳就是扒掉这层防护 静态分析静态分析就是直接去看别人的源代码， 当然别人写的C的源代码你是看不到的， 必须进行反编译， 但是反编译也不是那么的完美， 无法恢复回原来的样子， 会非常难以理解。 动态分析类似于debugger, 借助调试器， 可以看到代码的当前执行状况， 跳转地址、内存当中的状态]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript事件机制]]></title>
    <url>%2F2019%2F03%2F26%2FJavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了Web-Worker, 但JavaScript本质上还是一门单线程的语言， 这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的 所以JavaScript 放弃了多线程 事件机制单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？为了应对这些问题， JavaScript将事件分为了 同步任务 异步任务 所有的事件任务都被加入到栈内, 栈的特点是先入后出， 如下图 看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈 当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是爆栈 微任务与宏任务的区别我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， 当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务 能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队 在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的， 就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后， 柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。 所以在当前的微任务没有执行完成时，是不会执行下一个宏任务的 优先级不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， 既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢 因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看: 浏览器渲染 &gt; 微任务 &gt; 宏任务 微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后 看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列， 宏任务会延迟加入 理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程 EventLoop每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。（检查还有没有微任务需要处理）而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。（结束本次宏任务、检查还有没有宏任务需要处理）这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。(这是个非常简易的描述了，实际上会复杂很多) 而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑： 宏任务例子 API 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤 requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行 微任务例子 API 浏览器 Node process.nextTick ❌ ✅ MutationObserver ✅ ❌ Promise.then catch finally ✅ ✅ MessageChannel 消息队列 浏览器中的情况在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤） I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 假设有这样的一些DOM结构：123456789101112131415&lt;style&gt; #outer &#123; padding: 20px; background: #616161; &#125; #inner &#123; width: 100px; height: 100px; background: #757575; &#125;&lt;/style&gt;&lt;div id="outer"&gt; &lt;div id="inner"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223const $inner = document.querySelector('#inner')const $outer = document.querySelector('#outer')function handler () &#123; console.log('click') // 直接输出 Promise.resolve().then(_ =&gt; console.log('promise')) // 注册微任务 setTimeout(_ =&gt; console.log('timeout')) // 注册宏任务 requestAnimationFrame(_ =&gt; console.log('animationFrame')) // 注册宏任务 $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务&#125;new MutationObserver(_ =&gt; &#123; console.log('observer')&#125;).observe($outer, &#123; attributes: true&#125;)$inner.addEventListener('click', handler)$outer.addEventListener('click', handler) 如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(一次在inner、一次在outer)，所以会优先执行冒泡的事件(早于其他的宏任务)，也就是说会重复上述的逻辑。在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。 Node Js中的情况Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是Node官方文档的地址。 就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。 几个特殊的API SetTimeout和SetInterval 线程池不参与 process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。 setImmediate();比process.nextTick()优先级低 来看看这段代码 1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)setImmediate(() =&gt; &#123; console.log(2)&#125;)process.nextTick(() =&gt; &#123; console.log(3)&#125;)new Promise((resolve, reject) =&gt; &#123; console.log(4) resolve(4)&#125;).then(() =&gt; &#123; console.log(5)&#125;)console.log(6) 这道题目的答案是 463512 这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间 我们都知道 then 比 setTimeout 优先级高 然后就是 setTimeout 和 setImmediate 的问题了， setImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。 但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后, 所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行 参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解) https://segmentfault.com/a/1190000016022069]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NodeJs】异步IO与EventLoop]]></title>
    <url>%2F2019%2F03%2F26%2F%E3%80%90NodeJs%E3%80%91%E5%BC%82%E6%AD%A5IO%E4%B8%8EEventLoop%2F</url>
    <content type="text"><![CDATA[IO密集型就是需要频繁请求的程序，高访问量， CPU密集型就是需要进行大量计算的 异步IO的好处 前端通过异步IO可以消除UI堵塞。 假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。 随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+…和Max(M,N…)，这会放大同步和异步之间的差异。 I/O是昂贵的，分布式I/O是更昂贵的。 分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了 NodeJS 适用于IO密集型不适用CPU密集型 Node对异步IO的实现 完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。 Node.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管， Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询 Node.js 依靠v8运行javascript, 并且绑定了底层的操作系统 当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数 常用的Node控制异步技术手段 Promise 是一个语法， 规范， js只是实现了这个规范， Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑 Step、wind（提供等待的异步库）、Bigpipe、Q.js Async、Await Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效 由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。 底层的知识 CPU时钟周期：1/cpu主频 -&gt; 1s/3.1 GHz 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【架构】简单理解微服务架构]]></title>
    <url>%2F2019%2F03%2F26%2F%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.1 单体应用与微服务 微服务对应的是传统架构， 传统的软件架构是把所有都打在一个包里面， 也就是单体应用。 单体应用在部署上和后期管理维护上会愈来愈越庞大和难以管理， 而且约束开发成员使用的技术栈， JAVA的程序必须使用JAVA, 但是可能团队里有的擅长PHP，有的擅长Go。 针对这些问题就有人提出了微服务的概念， 可以让适合的语言干适合的事情。 单体应用想要增加服务器只能把整个项目都丢到一台新的服务器上，但每个模块对并发的要求不一样， 比如产品服务模块是需求较多的，压力比较大， 但是订单模块需求就比较少，你也无法拆开， 而微服务不一样， 可以单独对产品服务 这个需求比较大的微服务进行增加服务器， 并且在功能升级时可以实现部分升级， 让用户感觉不到什么异样。 2.1 微服务到底是什么 微服务只是业务层面上的架构， 技术层面的架构属于你选用某框架 ✅微服务属于架构层面的设计模式【结构层面的设计模式】 ✅微服务的设计概念以业务功能为主 ✅微服务独立提供对应的业务功能 ✅微服务不拘泥于具体的实现语言 ✅微服务架构 ≈ 模块化开发 + 分布式计算 2.1 易于扩展的分布式微服务的架构不管是横向扩展还是纵向扩展都比较的友好 2.1.1 横向扩展针对业务进行扩展， 当需要新增业务时只需要增加一个微服务即可 2.1.2 纵向扩展纵向扩展是对计算压力上的扩展， 针对某一块增加服务器，增强其计算能力， 然后使用Nginx进行反向代理 3.1 微服务的特点 小, 且专注于做⼀件事情 处于独立的进程中 轻量级的通信机制 松耦合、独立部署 4.1 合理使用微服务微服务不是灵丹妙药，并不能适应所有的情况。 微服务需要在范围内被合理的使用。 业务复杂度高 团队规模大 业务需要长期演进 最后——没有银弹【人月神话】 5.1 微服务——集成与部署 持续集成——jekins 虚拟化——虚拟机 容器——Docker]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript语法]]></title>
    <url>%2F2019%2F03%2F24%2FTypeScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[初始化配置文件 tsc –init修改outDir 定义数组 1 1var arr:number[] = [1,2,3,4] 2 1var arr:Array&lt;number&gt; = [3,4,56,7,8,9] 3 1var arr:any[] = [1,'5515', false] 定义元组 元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。1 1let arr:[number, string] = [123, 'this is ts'] 定义枚举 用于处理非数值的数据 1234enum Flag &#123; success=1, error=2 &#125;;let s:Flag=Flag.successconsole.log(s) // 1 never 类型: never类型表示的是那些永不存在的值的类型, 如null, undefind, error 12var a:undefineda = undefined 定义 symbol类型 symbol类型的值是通过Symbol构造函数创建的。 1let sym1 = Symbol(); 容许多个类型1234var num:number | undefined;num = 123;console.log(num) 有返回值类型 函数声明 123function run():string &#123; return '32132132'&#125; 函数表达式 123var fun2 = function():number &#123; return 132&#125; 无返回值类型123function run():void&#123; console.log('run')&#125; 可选参数、 默认参数 、剩余参数 默认必传, 带‘?’可传可不传， 必须配置到参数的最后面 123function getInfo(name:string, age?:number):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 默认参数写了默认参数就不再需要 ‘?’ 标记 123function getInfo(name:string, age:number=250):string &#123; return `$&#123;name&#125; ---- $&#123;age&#125;`&#125; 剩余参数12 json 属性约束12345// json属性约束function jsonCon(label) &#123; console.log(label.labelJson);&#125;jsonCon(&#123; labelJson: '你好评' &#125;); 重载 因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof 123456789101112131415function getInfo(name:string):string;function getInfo(name:string, age:number):string;function getInfo(name:string, age?:any):string &#123; // 判断类型用 typeof if(age) &#123; return `姓名:$&#123;name&#125;, 年龄$&#123;age&#125;` &#125;else &#123; return `姓名:$&#123;name&#125;` &#125;&#125;console.log(getInfo('吴大龙')) 创建类123456789101112131415161718class Person&#123; name:string; // 属性 ,前面省略了Public 关键词 constructor(name:string)&#123; // 构造函数 实例化类的时候 触发的方法 this.name = name; &#125; getName():string&#123; return this.name &#125; setName(name:string):void&#123; this.name=name; &#125;&#125; var aa = new Person('栗色')console.log(aa.getName())aa.setName('吴大龙')console.log(aa.getName()) 使用类的 get 和 set 123456789101112131415class Person&#123; private _name:string; constructor(name:string, age:number)&#123; this._name = name; &#125; get name():string&#123; return this._name &#125; set name(name:string)&#123; this._name = name; &#125;&#125;const p = new Person('吴大龙', 112)p.name = '吴强' // 赋值console.log(p.name) // 取值 实现继承 继承自上方类 12345678class Web extends Person &#123; constructor(name:string)&#123; super(name); &#125;&#125;var w=new Web('往');console.log(w.run()) 类修饰符 不加修饰符默认就是 Public , ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==public: 共有, 在类的里面, 子类, 类外部都可以访问 protected: 保护类型, 在类里面, 子类里面可以访问, 类外部无法访问 private: 私有, 在类里可以访问, 子类, 类外部都没法访问 静态属性和静态方法 static 静态方法, 在没有 new 出实例前都可以调用==但是没法直接调用类里面的属性== 123456789class Person &#123; public nickname:string= '吴大龙'; static speak():void&#123; console.log(`用户姓名:$&#123;this.nickname&#125;`) &#125;&#125;Person.speak() // 用户姓名:undefined 多态 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态 123456789101112131415161718192021222324252627282930313233343536// 多态class Animal &#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat():void&#123; console.log(`$&#123;this.name&#125;， 在吃屎`) &#125;&#125;class Dog extends Animal &#123; constructor(name:string)&#123; super(name) &#125; // 子类重新定义 eat方法 eat():void &#123; console.log(this.name+'吃肉') &#125;&#125;const wuxiaohong = new Dog('吴晓红')wuxiaohong.eat()// 子类重新定义 eat方法class Cat extends Animal &#123; constructor(name:string) &#123; super(name) &#125; eat():void&#123; console.log(this.name+ '吃粮食') &#125;&#125;var cc = new Cat('吴强')cc.eat() 抽象类 用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类==抽象方法只能放在抽象类里==从抽象类继承的方法必须被子类重写, 重新实现 1234567891011121314151617181920abstract class Animal&#123; public name:string; constructor(name:string)&#123; this.name=name; &#125; abstract eat():any;&#125;class Dog extends Animal&#123; constructor(name:any)&#123; super(name) &#125; eat()&#123; console.log(this.name + '吃粮食') &#125;&#125;var d = new Dog('小狗')d.eat() 接口 也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类 批量属性接口， 可定义可选参数 123456789// 属性接口interface FullName&#123; firstName: string; //封号结束 secondName: string;&#125;function printName (name: FullName) : void&#123; console.log(name.firstName +'====&gt;' + name.secondName);&#125;printName(&#123;firstName: '吴', secondName: '大龙'&#125;) // 吴====&gt;大龙 数组类型接口123456interface StringArray &#123; [index:number]:string&#125;var myArray:StringArray;myArray = ["iwen", "ime"]alert(myArray[1]) 函数类型接口, 对方法传入的参数， 以及返回值进行约束 123456789// 比如建一个md5加密的接口 的接口interface encrypt&#123; (key:string, value:string):string;&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key + value;&#125;console.log(md5('name', '吴大龙')) 接口扩展， 接口可以继承接口 1234567891011121314151617181920212223interface Animal&#123; eat():void;&#125;// 继承上方接口interface Person extends Animal &#123; work():void;&#125;// 有个类 实现 这个接口class Web implements Person &#123; public name:string; constructor(name:string)&#123; this.name=name &#125; eat()&#123; console.log(this.name + '喜欢吃馒头') &#125; work()&#123; console.log(this.name + '写代码') &#125;&#125;var w = new Web('小林')w.work() // 小林写代码 接口多继承 &amp;&amp; ==创建一个接口对象==123456789101112131415161718// 多继承 并 创建一个接口对象interface Shape &#123; color:string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength:number;&#125;// 创建接口对象不需要 new 而是这样的语法var s = &lt;Square&gt;&#123;&#125;;s.color = "blue"s.penWidth = 10s.sideLength = 10 泛型 用于创建可重用的组件， 让一个组件支持多种数据类型 ==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持== 基本使用 12345// 泛型 : 可以支持不特定的数据类型 要求： 传入的参数和返回的参数一致function getData&lt;T&gt;(value:T):T&#123; // T表示泛型 return value&#125;console.log(getData&lt;string&gt;('我是泛型')) 多个泛型参数 12345678910class HelloNumber&lt;T, S&gt;&#123; Ten:T; add:(x:T, y:T) =&gt; S;&#125;var myHelloNumber = new HelloNumber&lt;number, string&gt;()myHelloNumber.Ten = 10;myHelloNumber.add = function(x, y) &#123; return x+y+''&#125;console.log(myHelloNumber.add(1, 2)); lamb 表达式 12345678function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数var myHello:&lt;K&gt;(arg:K)=&gt; K = &lt;K&gt;(arg:K):K =&gt; &#123; return arg&#125;alert(myHello('hello')) 另一种写法， 对象形式 12345function Hello&lt;T&gt;(arg:T)&#123; return arg&#125;var myHello:&#123;&lt;T&gt;(arg:T):T&#125; = Hello;alert(myHello(" Hello")) 泛型接口 12345678// 泛型接口interface ConfigFn&#123; &lt;T&gt;(value:T):T;&#125;var getData:ConfigFn = function&lt;T&gt;(value:T):T&#123; return value&#125;console.log( getData&lt;string&gt;('你好') ) 泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现== 12345678910111213141516171819202122// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现class MinClass&lt;T&gt;&#123; list:T[]=[] add(value:T):void&#123; this.list.push(value) &#125; min():T&#123; var minNum = this.list[0] for(var i=0;i&lt;this.list.length;i++)&#123; if(minNum &gt; this.list[i])&#123; minNum=this.list[i] &#125; &#125; return minNum; &#125;&#125;var m1 = new MinClass&lt;string&gt;();m1.add('1')m1.add('you')m1.add('love')console.log(m1.min()) 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在伪元素中使用Iconfont]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E4%BD%BF%E7%94%A8Iconfont%2F</url>
    <content type="text"><![CDATA[把iconfont 中的样式拷到 伪元素上1234567.iconfont&#123; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 砍掉unicode 前面的字符如下 即可123456789&amp;::after&#123; content: '\e60e'; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125; 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AOP】面向切面编程]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%90AOP%E3%80%91%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Aspect Oriented Programming 面向切面编程（aop）是对面向对象编程（oop）的补充 面向切面编程在软件业， AOP为 Aspect Oriented Programming 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。 基础概念AOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。 FilterFilter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为”Aspect”， 即切面。 所谓“切面”。 优点AOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！ 就像函数的before和 after 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之IOC控制反转]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BIOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[IOC （控制反转） Inversion of Control IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。 什么是控制反转控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。 DI是IOC的一种表现形式 两种方式依赖查找容器提供回调接口和上下文条件给组件。 依赖注入组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。 IOC概念图在未使用IOC的时候 各个 Object 之间的耦合度很高， 谁也离不开谁 在使用 IOC 后， 各个 Object 之间通过 IOC容器 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁， 降低了耦合度 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>IOC</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解汇编语言]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[汇编语言是最贴近底层的计算机语言 汇编语言是直接操作硬件的，没有任何抽象 汇编语言由指令与数据组成，没有任何语句 汇编指令受到硬件平台限制，可移植性很低 了解一些底层语言知识，对理解计算机的运作机制和内存管理大有好处 体验一下汇编语言来看一下一个简单的汇编语言代码， 这段代码只是为了输出一个”hello world” 上面部分也就是程序的数据段: 下面这部分是程序的代码段: 代码段和数据段是严格分开的， 汇编语言最原始的方式是：当这段代码转换为机器指令后， 数据和代码是相邻在一起的. 但其实放在一起是不太安全的！ 现代计算机的做法是， 将代码段和数据段严格区分开来， 如果越界，在数据段的地方取代码， 操作系统就会给你抛出错误， 也就是经典的蓝屏]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则之S.O.L.I.D]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BSOLID%2F</url>
    <content type="text"><![CDATA[作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步 那编程里如何提升内功， 主要就是体现在编程思想上了， 逐层提升你编程思想比如从一开始的最传统的面向对象 到 面向切面 面向对象 -&gt; 工厂模式 -&gt; 面向切面 从 “oop 的静态抽象” 演变为 “aop的动态抽象” SOLID原则的基本概念让我们来看下 SOLID 的概念 程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。 SOLID这几个字母代表什么意义？S (单一一功能原则) Single Responsibility Principle 单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。 缩减一下就是: 让每个函数和每个类都只做一件小事，职责单一，解耦和 O (开闭原则) Open Close Principle 开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。 说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。 让我们来看下一个简单的 Ts demo 糟糕的实现1234567891011121314class Animal &#123; constructor(name: any) &#123; super(name) this.name = name &#125; eat() &#123; if(this.name == '小猫') &#123; console.log(this.name + '吃猫粮') &#125; else if( this.name == "小狗") &#123; console.log(this.name + '吃狗粮') &#125; &#125;&#125; 这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背 利用 OCP 思想1234567891011121314151617181920// Animal 抽象类abstract class Animal &#123; public name: string; constructor(name: string) &#123; this.name = name; &#125; abstract eat(): any;&#125;// 实现Animal抽象类class Dog extends Animal &#123; constructor(name: any) &#123; super(name) &#125; eat() &#123; console.log(this.name + '吃狗粮') &#125;&#125;var d = new Dog('小狗')d.eat() 上面的代码中， 首先使用abstract 定义抽象类和抽象方法，提供其他类继承的基类我们定义只要是Animal就必须要有eat方法 于是， 我们创建了一个Dog 继承Animal ,这个Dog就不一般了， 它规定了必须重新实现 eat 方法， 并且可以扩展自己的方法 当我们将来如果需要一只 Cat我们一样只需要让他继承Animal抽象类， 然后实现一个自己的eat方法 L (里⽒氏替换原则) Liskov Substitution Principle 里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。 子类必须能够替换他们的基类。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现if/else之类对子类类型进行判断的条件。 里氏替换原则LSP使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， LSP则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。 当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。 缩减一下就是: 老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系 I (接⼝隔离原则) Interface Segregation Principle 接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 不能强迫用户去依赖那些他们不能使用的接口。 换句话说， 使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。 注意： 在代码中应用 ISP 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。 这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， ISP原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。 缩减一下就是: 每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口 D (依赖反转原则) Dependency Inversion Principle 依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。 高层模块不应该依赖于底层模块， 二者都应该依赖于抽象抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦) 类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。 举个例子: 你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。 此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品， 当我们需要某件物品时就可以去商场购买现成地商品 依赖反转原则依赖注入 当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。 注⼊入过程 如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊ 依赖反转有两种方式 设值注入（在类上方设置字段） 构造注入 （在constructor中接收需要地参数） DI（依赖注⼊入） 依赖注⼊入（Dependency Injection） 为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C语言】入门知识]]></title>
    <url>%2F2019%2F03%2F23%2F%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[C语言的诞生要比JavaScript早很多, 属于低级语言，比较擅长和系统交互写底层应用。 C语言的编译工具就是gcc 🤯前端不限端作为一名优质的前端切图仔， 不应该把自己困死在前端中， 更应该多开阔视野， 朝较底层的方向探索 当然， 这只是鸡汤， 我们来看看前端学习C语言的必要性 编译开源软件的源代码 C语言基本语法，要看得懂代码 指针和C语言的坑 从内存层面理解数据结构 搞懂V8的内存管理机制 分析webkit引擎代码 用C语言编写Node.js和PHP扩展模块 C语言沉浮录C语言的前身是B语言 天生的系统级语言 最早用来编写Unix内核 曾经最流行的语言 至今仍在不断发展 C语言和JavaScript的异同 C语言是编译型语言 C语言要借助编译器转换成可执行程序 JavaScript是解释型语言 JavaScript要借助解释引擎运行 需要编译的语言经过编译后生成目标程序， 其实生成目标程序时已经是机器指令了， 但是计算机仍旧无法直接运行它，因为操作系统有他自己的规则， 想要符合操作系统的规则， 这时候就要走链接， 那链接做了哪些事让操作系统能够识别到该程序呢： 给操作系统一个识别块，操作系统先读识别块再运行程序 把生成的很多.obj文件串起来， 连成一块 C语言与C++语言的区别 C++是新的编程语言，并不是C的扩展 C语言是面向过程的，C＋＋是面向对象的 C和C++语言都有标准库【standard.io】 目前C大多用在网络相关和嵌入式等方面【不管Python、还是JS，底层都需要C语言基本环境】 目前C++大多用在复杂引擎和应用软件方面 理解内存与指针 内存与内存地址 指针、地址与引用 指向变量的指针 指向指针的指针 指向函数的指针 动态内存分配 要理解内存和指针首先我们应该知道内存在计算机中是什么样子的， 我们可以把内存看作是一个打了很多格子的小纸条，每个格子就是内存的基本存储单位, 1个单位是一个字节，也就是一个byte, 而一个byte等于8个bit，那我们该如何找到对应的内存呢， 实际上内存是有编号的，这个编号从0开始， 作为内存的地址（门牌） 指针 指针其实也是可以运算的，但大多数情况没有意义， 一般用在计算存储空间 容纳内存地址的变量就是指针 C语言中， 指针也是有类型的， 因为不同的数据类型对应内存中的所占的大小不一样， 定义类型是为了从内存中拿出正确长度的数据， 比如： 短整型只占两个字节、 长整型占4个字节、 超长整型占8个字节、单精度浮点型占6个字节、 双精度浮点型占8个字节 如果不正确定义指针的类型，就会导致从内存中拿出来的长度是错的， 也就是导致得到的值是错的 🕵️‍一级指针结构 🕵️‍二级指针结构 🤒声明指针 一开始声明的指针我们只能给他一个Null或是 内存地址, 因为一个具体的值对于指针是没有意义的， 声明一个整型的指针12345// 声明一个变量， 会自动分配内存int a = 10;// 声明一个指向变量a的指针int * p_a = &amp;a; 🧐直接寻址和间接寻址直接使用变量和利用指针访问的结构是一样的12printf(a); // 10printf( *p ); // 10 🤒二级指针及多级指针 不管是几级指针编译器都是能够通过的 12345678// 声明一个变量， 会自动分配内存int a = 10;// 声明一个指向变量a的指针int * p_a = &amp;a;// 声明一个指向指针的指针int ** pp_a = &amp;p_a; 指向函数的指针 函数它本身也在内存当中, 当我们看到一个指向函数的指针时就代表着函数调用， 回调函数就是基于指针的 C语言的函数是有原型的 声明一个两数相加函数的原型12// 函数返回类型及参数类型int add( int, int ); 实现函数1234int add(int v1, int v2) &#123; return v1 + v2;&#125; 创建指向函数的指针12int*(int, int) p_func;p_func = add; 引用引用是对指针的封装， 现代语言不允许你直接去操作地址 因为现代语言都自带着垃圾回收机制， 在垃圾回收的过程中， 地址会经常改变， 改变地址的目的是为了提高内存的利用效率， 使内存连续 内存动态分配C语言主要分如下四个区 内存 描述 特性 栈区 是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow 自动分配, 自动释放 堆区 用于动态内存分配 手动分配和释放 ， 可占用80%内存 全局区或静态区 在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量） 只初始化一次 程序代码区 代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。 代码区的指令中包括操作码和要操作的对象（或对象地址引用） 栈区： 还用来保存当前函数的局部变量 堆区： 存放new出来的变量 全局区或静态区: 存放全局变量及对象的静态变量 程序代码区: 存放指令、代码， 以前的金山游侠修改器就是专门改程序代码区的 分配内存代码123456789101112131415161718int * p;// size_t 表示一个无符号整型// p = malloc( size_t );// 给整型分配空间必须 传入整型长度的倍数（ 整型长度是 4个字节）// 这样我就申请了40个字节的内存空间， 它能容纳10个整型的数字p = malloc(40);// 实际上 malloc 申请到的是一个数组， 下面这样是对前4个字节进行赋值*p = 1;// 实际等价于p[0] = 1;// 如果你要给其他位置的字节赋值, 这样表示向后移动一个元素单位的位置*(p+1) = 2; // 等价于p[1] = 2; 释放内存1free(p)]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】理解权限命令-chown]]></title>
    <url>%2F2019%2F03%2F22%2F%E3%80%90Linux%E3%80%91%E7%90%86%E8%A7%A3chown%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021# 更改文件属组chgrp [-R] 属组名 文件名# 更改文件属主 或 属组chown [-R] 属主名 文件名chown [-R] 属主名：属组名 文件名# 修改文件权限 9 个属性# 有两种设置方式， 一种是数字 一种是符号# 基本身份 owner/group/others 的各自三种权限# read(r 4)/write(w 2)/execute(x 1): -rwxr-xr-- = [4+2+1][4+0+1][4+0+0]=754chmod [-R] xyz 文件或目录# 符号修改权限chmod u(user) +(加入) r 文件或目录 g(group) -(减去) w o(others) =(设定) x a(all 全部身份) chmod u=rwx,g=rx, o=r 文件名chmod a-x test1 图解]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题集合]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[事件机制Promise题目一:123456789101112131415setTimeout(() =&gt; &#123; console.log(4)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(1) setTimeout(() =&gt; &#123; resolve("done") console.log(6) &#125;, 0) resolve(5)&#125;).then((res) =&gt; &#123; // 微任务 console.log(res)&#125;)console.log(2) 答案: 1 , 2 , 5 , 4, 6 注意， 没有done！ 分析:Promise 的resolve只会触发一次， 因为Promise的状态已经被修改为resolve 所以第二次的resolve 不会触发 题目二:1234567891011121314151617181920setTimeout(() =&gt; &#123; console.log(4)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(1) new Promise(resolve =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; resolve("done") console.log("aa") &#125;, 0) resolve(8) &#125;).then((res) =&gt; &#123; console.log(res) &#125;) resolve(5)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)console.log(2) 答案: 1, 7, 2, 8 , 5 , 4 , aa 分析:Promise的完成先后还得看谁先挂载了 then， 并不是谁先new就是谁 ES6系列async await:题目一: async 什么原理 ?例子:1234async function test () &#123; let result = await 10 &#125;test() 经过 Babel 转换12345678910111213while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return 10; case 2: result = _context.sent; case 3: case "end": return _context.stop(); &#125; 分析我们可以看到，经过babel 转换过的 async await 代码中关键的这句， while循环， 并且是一个死循环， babel 就是这样来模拟 async await的， 当await返回结果时， _context.stop抛出异常退出死循环 , babel这样做也是为了更好的捕获异常 题目二: 请问result输出几 ?12345678var a = 0async function test () &#123; let result = a + await 10 console.log(result)&#125;test()a = a + 1test() 答案: 10 , 11 分析: await 后如果是一个常量, 将作为 Promise.resolve的结果返回 因为 async await 是 generator的语法糖， 当执行 test 方法时， 变量a的值会被锁住 所以第一个结果是10， 第二个结果是 11 Promise题目一: 请用 ES5实现ES6 Promise A+规范的代码， 用时你能解释下如何使用Promise完成事务的操作吗]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript手册]]></title>
    <url>%2F2019%2F03%2F18%2FTypeScript%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[TypeScript是JavaScript的超集 开发环境搭建 我的环境: window10 + vscode 全局安装Ts npm i -g typescript 生成并配置tsconfig.json tsc –init 配置文件， 下面的配置中ts应存放在src 目录下， 并且会自动编译到dist文件夹下1234567891011121314151617181920212223242526272829303132333435&#123; "compilerOptions": &#123; "target": "es2017", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' "module": "commonjs", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' "moduleResolution": "node", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) "emitDecoratorMetadata": true, // 为装饰器提供元数据的支持 "experimentalDecorators": true, // 启用装饰器 "allowSyntheticDefaultImports": true, // 允许从没有设置默认导出的模块中默认导入。 "strict": true, // 启用所有严格类型检查选项 "noImplicitAny": true, // 在表达式和声明上有隐含的 any类型时报错 "alwaysStrict": true, // 以严格模式检查没个模块，并在没个文件里加入 'use strict' "sourceMap": true, "noEmit": false, // 不生成输出文件 "removeComments": true, // 删除编译后的所有的注释 "importHelpers": true, // 从 tslib 导入辅助工具函数 "strictNullChecks": true, // 启用严格的 null 检查 "lib": ["es2017"], // 指定要包含在编译中的库文件 "typeRoots": ["node_modules/@types"], "types": [ "node", ], "outDir": "./dist", // 编译后文件产出目录 "rootDir": "./src" // 你的ts文件目录 &#125;, "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 "./src/*.ts", "./src/**/*.ts" ], "exclude": [ "node_modules", "dist", "**/*.test.ts", "public" ]&#125; 快速生成package.json npm init -y 运行命令， 开始监听 tsc -w 是否有效呢？ 让我们来试一下 进入src目录新建一个 hello.ts，记得是.ts， 不要写习惯了打成.js😅 随便写点东西， 比如定义一个字符串类型:1var a:string = "hello world" 如果你配置没有问题的话， 我们就会看到他监听文件修改并编译 这是ts文件与 编译后的js文件 并且在他运行过程中， 我们可以按F5进行调试 基本数据类型 Boolean Number String Array Enum Any Void 简单的几种数据的定义123456// 定义一个Booleanvar a:boolean = true// 定义一个Numbervar a:number = 13// 定义一个 String var a:string = "13" 基本的数据结构定义1var list:number[] = [1,2,3] 接口 interfaces 基础接口没有接口时我们如何规范参数类型12345function fn(dog:&#123;name:string&#125;) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) 有了接口， 我们就可以把参数规定与函数分离 如何创建接口 通过 interface 关键字来声明 1234567891011interface dogValue &#123; name:string;&#125;// 指定参数`dog`是接口类型function fn(dog: dogValue) &#123; console.log(dog.name)&#125;var myObj = &#123; name: "Hello" &#125;fn(myObj) // 编译通过 接口的可选属性接口定义的参数不一定每一个都会被用到 泛型什么是泛型? 泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 一句话理解就是： 参数化类型（把类型当作是参数一样传递） 使用泛型的好处: 代码更加简洁【不用强制转换】 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】 可读性和稳定性【在编写集合的时候，就限定了类型】 指定一个最简单的泛型123function Hello&lt;T&gt;(arg:T):T &#123; return arg;&#125; Module 模块Module 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module Module 的好处 模块化 可重用 封装变量和函数 来看看在ES6之前是如何书写的123(function() &#123; // do somtiong&#125;()); 让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦 使用Module之前1234567891011121314151617interface StringValidator &#123; // 接口定义的方法 isAcceptable(s:string):boolean;&#125;var lettersRegexp = /^[A-Za-z]+$]/;var numberRegexp = /^[0-9]+$/;// 实现接口的方法class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return lettersRegexp.test(s) &#125;&#125; class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125;&#125; 使用了Module 的书写方式后 1234567891011121314151617181920module Validation &#123; // 需要使用 export 来表示对外暴露 export interface StringValidator &#123; isAcceptable(s:string): boolean; &#125; var lettersRegexp = /^[A-Za-z]+$]/; var numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s:string) &#123; return lettersRegexp.test(s) &#125; &#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s:string):boolean &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s) &#125; &#125;&#125; Module 与 类相结合使用12345678910111213141516171819module Person &#123; export class Student &#123; name: string; constructor(name:string) &#123; this.name = name; &#125; study() &#123; console.log(this.name + '在学习') &#125; speak() &#123; console.log(this.name + '在说话') &#125; &#125;&#125;// ----------- 使用时 -------------const xiaoming = new Person.Student('小明')xiaoming.study() NamespacesNamespaces 的和Module 的用法相同， 在Ts 的1.5 版本后， 用 Namespaces 取代了 Module 查看一下官方的示例 123456789namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123; &#125; export class Square &#123; &#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 装饰器 &lt; Decorators &gt;如何定义一个装饰器 其实装饰器就是一个普通的函数， 他接收一个参数target ，这个参数就是被装饰对象， 看下面的例子， sealed 装饰了Dog类， 并且在sealed 中打印了 target ， 让我们看看 target到底是什么？123456789101112function sealed(target:any) &#123; // do something with 'target' ... console.log(target) return target&#125;// 被装饰的对象 foo@sealedclass Dog &#123;&#125; 打印结果 我们可以看到， 得到的正是 Dog这个类 装饰器工厂&lt; Decorator Factories &gt; 如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。 装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果 如何定义一个装饰器工厂 123456789101112function dec(value:string) &#123; return function (target:any) &#123; console.log(value) console.log(target) &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; &#125; 让我们来看看运行的结果 可以看到，我们传入的test字符串和 Cat类都被打印出来了， 多装饰器的执行顺序使用多个装饰器时如何书写呢? 当我们使用多个装饰器时有两种写法 写成一行 1@f @g x 垂直书写 123@f@gx 多个装饰器的执行顺序是如何的呢？ 套用官网的说明 对每个装饰器的表达式进行自上而下的计算。 然后将结果作为自下而上的函数调用。 其实真实的运行原理是1f(g(x)) 访问器修饰器访问器修饰器的接收的参数和方法修饰器接收的参数一样 123456789101112131415161718192021function dec(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; this._x = x this._y = y &#125; // 访问器修饰器 @dec(true) get x() &#123; return this._x &#125; @dec(false) get y() &#123; return this._y &#125;&#125; 属性修饰器属性修饰器只有前两个参数123456789101112131415161718function dec(value:string) &#123; return function (target:any, propertyKey: string) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; private _x: number; private _y: number; constructor(x: number, y: number) &#123; // 属性修饰器 @dec(false) this._x = x this._y = y &#125;&#125; 参数修饰器参数修饰器也是三个参数， 但不同的是第三个参数接收 参数装饰器只能确认一个方法的参数是否被传入 前两个和其他的修饰器都相同， target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数 1234567891011function require(value:boolean) &#123; return function (target:any, propertyKey: string, index: number) &#123; &#125;&#125;// 在这里使用并传入自定义的参数@dec('test')class Cat &#123; run(@require(true) name:string) &#123; &#125;&#125; 装饰器参数 类装饰器 类装饰器的参数只接收一个， 那就是target 也就是这个类本身 就和上面演示的那些例子一样 方法装饰器 一般会传入三个参数 target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象 propertyKey 成员的名称 descriptor 成员属性的描述符 我们来验证下方法装饰器的参数 让我们看看这段例子会输出什么123456789101112function f(value:string) &#123; return function (target:any, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(arguments) console.log(target) &#125;&#125;class Tiger &#123; @f('tiger run') run() &#123; &#125;&#125; 输入结果: 在控制台输出， 我们看到了，第一个参数是 tiger 的实例对象（因为run是实例成员） 第二个参数是成员名称， 也就是被装饰的run 第三个参数是 run 的属性描述符 Mixins 混入除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。 Mixins 其实可以拆分为两个单词 Mix : 混合 ins : 是进入 所以合在一起就是叫 混入 的意思的单词 它想要表达的是一个对象中混入另一个对象的方法 让我们来实现一下Mixins 代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。 12345678910111213141516171819// Disposable Mixinclass Disposable &#123; isDisposed: boolean; dispose() &#123; this.isDisposed = true; &#125;&#125;// Activatable Mixinclass Activatable &#123; isActive: boolean; activate() &#123; this.isActive = true; &#125; deactivate() &#123; this.isActive = false; &#125;&#125; 创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：12class SmartObject implements Disposable, Activatable &#123; &#125; 这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。 我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。 也就是这样 1234567891011121314151617class SmartObject implements Disposable, Activatable &#123; constructor() &#123; setInterval(() =&gt; console.log(this.isActive + " : " + this.isDisposed), 500); &#125; interact() &#123; this.activate(); &#125; // Disposable isDisposed: boolean = false; dispose: () =&gt; void; // Activatable isActive: boolean = false; activate: () =&gt; void; deactivate: () =&gt; void;&#125; 最后，把mixins混入定义的类，完成全部实现部分。1applyMixins(SmartObject, [Disposable, Activatable]); 我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。1234567function applyMixins(derivedCtor: any, baseCtors: any[]) &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;);&#125; 参考文献 https://segmentfault.com/a/1190000016305647 ————————-待完善—————————-]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Css矩阵]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E7%9F%A9%E9%98%B5%E3%80%91%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Css%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[矩阵 matrix(a,b,c,d,e,f); a c e 分别和 X, Y, 1 相乘得出线性方程 b d f 分别和 X, Y, 1 相乘得出线性方程 这是很清楚的计算公式 rotateZ矩阵推理推理过程 参考同学的笔记同学写的很不错👍]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CSS全景】淘宝造物节H5原理]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90CSS%E5%85%A8%E6%99%AF%E3%80%91%E6%B7%98%E5%AE%9D%E9%80%A0%E7%89%A9%E8%8A%82H5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的 一、 载入图片, 定位至统一位置 因为20张图片被定位到统一地方, 所以所有图片都叠在一起了 此时效果 二、依照Y轴旋转图片 先说下为什么要依照y轴: 我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板, 图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起 素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, 这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片, 比如: 0度的图片, 头在0度, 尾在90度, 然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象 此时效果 为了方便理解, 切换成上帝视角, , 所有图片围绕中心点旋转 三、将图片沿着各自Z轴向外推 现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起, 才能形成一个圆 先了解每一块木板怎么推 简单的画了个前后的效果图, 用的是上帝视角, 也就是你低头看一个木桶的视角 如何计算该推多少距离 做一道三角函数数学题 画的角度不太对别介意 设一共12条线, 每条长200px(此时的长就对应图片的宽) , 求将橙线移动到图中最终位置的距离 “黑线”,12345678910// 先求旋转度数// 然后取度数的一半360 / 12 / 2 = 15 度// 得知直角底边长度200 / 2 = 100px// 根据度数得知 tan, 顺便说下, tan是对边比邻边tan15°= 0.26794// 求出黑线100PX / 黑线 = 0.26794黑线约等于 373.2px js计算时注意 Math.tan 接收的是弧度单位 Math.PI 表示的是一个 Π 360度 = 2Π 计算出每张图片之间的形成的弧度 12345678 // 假设图片数量是 8 张// 因为 360 = 2Π// 1度 = Π / 180// 每份的角度是const deg = 360 / 8 // 此时为 45// 一份的弧度就是 每份弧度 * 旋转角度的一半// 最后结果就等于 Π / 图片数量( Math.PI / 180 ) * ( 45 / 2 ) ==&gt; Math.PI / 8 谢谢最可爱的贝玺]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机语言的本源与发展]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%AC%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95%2F</url>
    <content type="text"><![CDATA[本源：二进制数据 第一代语言：机器指令 （痛苦指数 ✮✮✮✮✮） 第二代语言：汇编指令（痛苦指数 ✮✮✮✮✩） 第三代语言：高级语言（主要特征：面向过程） 第四代语言：面向对象语言（面向互联网、天然支持数据库）]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Vue】源码解析]]></title>
    <url>%2F2019%2F03%2F18%2F%E3%80%90Vue%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[现在三大框架风起云涌， JQuery老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， 当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然 要了解MVVM的本质原理， virtual Dom和 Diff算法解决的问题 拒绝盲目跟风 🍎diffDom优劣现在很多人都说 Vue, React 多牛， Diff算法快，不用操作Dom。 只能无语。 Diff算法不是不需要操作Dom, 而是不需要开发者去操作Dom了， Diff算法其实不快， 就算使用了virtual Dom, 还得花实现把真实Dom 转换为 virtual Dom 再去比对， 这远远没有js直接 getElementById直达目标来的快 那Diff算法不快为什么还要用呢? Diff算法其实是给那些比较随意的新手开发者准备的 看这个例子 123456&lt;!-- 原本的dom --&gt;&lt;ul id="ul"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt; 12345678// 拿到结果不管三七二十一把旧dom全替换了$.get('/api', (res) =&gt; &#123; var _HTML = "" for(var i=0; i&lt; res.length; i++)&#123; _HTML = "&lt;li&gt;" + res[i] +"&lt;/li&gt;" &#125; $("#ul").html(_HTML)&#125;) 如果是原始的Dom操作， 有很多小白会像这个例子一样， 不管Dom需不需要更新， 他都把ajax返回的请求全部跑一边，生成HTML模板， 然后把原本的所有li都删了， 再把新的模板放进去， Dom少还看不出来， 如果Dom多了呢， 上千的Dom， 这顿操作一下就玩炸了。 况且网站优化原则就是尽量减小Dom操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用append插入 📄Vue架构目录去Vue官网下载Vue源码看看， 打开里面会有一个 src目录， 里面就是整个的Vue源码 目前有6个目录， 作用分别如下 Vue.js 的组成是由 core + 对应的 ‘平台’ 补充代码构成（独立构建和运行时构建只是 platforms 下 web 平台的两种选择） Vue的核心原理就在core文件夹中， 让我们进入 core 文件夹看看 了解了目录，接下来我们就来研究Vue的双向绑定 🔗双向绑定（响应式原理） 所涉及到的技术 ✅ Obejct.defineProperty 【提供getter 和 setter】 ✅ Observer 【提供getter 和 setter】 ✅ watcher 【提供getter 和 setter】 ✅ Dep 【负责收集watcher】 ✅ Directive 【处理Vue模板指令】 Obejct.definePropertyObejct.defineProperty 是整个Vue的灵魂， 来看一下Obejct.defineProperty 如何使用1234567891011121314151617var obj = &#123;&#125;var c;Object.defineProperty(obj, 'a', &#123; get() &#123; console.log('getter') return a &#125;, set(newVal) &#123; console.log('setter') c = newVal this.a = newVal &#125;&#125;)obj.a = '234'console.log(c) // 234console.log(obj.a) // 234 它帮助Vue实现了双向绑定, 但也因为这个， Vue也只能舍弃了对低版本浏览器的支持。 它只能兼容到IE9 ， 并且市面上的polyfill实现的也并不是很好 那低版本如何代替Obejct.defineProperty ， 难道真没了它就不行吗？ 当然有： 👆 &gt; IE 7 实际上在IE7的时候就已经有暴露了 __defineGetter__ 方法， 具体用法如下1234567var random = &#123;&#125;;random.__defineGetter__('ten', function() &#123; return Math.floor(Math.random()*10); &#125;);random.__defineGetter__('hundred', function() &#123; return Math.floor(Math.random()*100); &#125;);random.ten // 随机的一个值 👇 &lt; IE 7 早年间的IE 是支持VBScript, VBScript 就可以直接写类， 并且也支持get，set方法 12345678class Test &#123; get name () &#123; &#125; set name() &#123; &#125;&#125; 🐶霸道的IE说了这么多IE的坏， 这里也带一嘴IE的好， IE能够调用EXE程序, 比如JS无法设置打印机的宽高，就可以利用ActiveObjectX来做到, 甚至可以修改word格式等等 , 所以办公类的项目离不开IE 😕MVVM 双向数据绑定流程MVVM: Model–view–viewmodel 那怎么区分这些层呢 🚀Model: Observer ✈️view : directive 🚚viewmodel: Watcher &amp;&amp; Dep 【用于连接 Model 和 view】 先看Directive, 这就是我们平时写的vue指令， 如上面举例得的v-text=&quot;times&quot;, 这就是一个指令， 一个Directive会分配一个Watcher Observer观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。 简单的描述就是: 你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的本子上, 当大爷的漫画到货的时候电话通知你。 这时你就是订阅者, 大爷就是发布者, 你们就存在一个发布订阅者的关系 Vue 中的Observer Observer会观察两种类型的数据，Object 与 Array对于Array类型的数据，由于 JavaScript 的限制， Vue 不能检测变化,会先重写操作数组的原型方法，重写后能达到两个目的， 当数组发生变化时，触发 notify 如果是 push，unshift，splice 这些添加新元素的操作，则会使用observer观察新添加的数据重写完原型方法后，遍历拿到数组中的每个数据 使用observer观察它而对于Object类型的数据，则遍历它的每个key，使用 defineProperty 设置 getter 和 setter，当触发getter的时候，observer则开始收集依赖，而触发setter的时候，observer则触发notify。 对 Object 的处理Observer 对象的标志就是__ob__ 这个属性，这个属性保存了 Observer 对象自己本身。对象在转化为 Observer 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 Observer 对象 对数组的处理其实 observeArray 方法就是对数组进行遍历，递归调用 observe 方法，最终都会走入 walk 方监控单个元素。而 walk 方法就是遍历对象，结合 defineReactive 方法递归将属性转化为 getter 和 setter WatcherWatcher 是将模板和 Observer 对象结合在一起的纽带。Watcher 是订阅者模式中的订阅者。Watcher 的两个参数： expOrFn 最终会被转换为 getter 函数， cb 是更新时执行的回调。依赖收集的入口就是get函数。 getter 函数是用来连接监控属性与 Watcher 的关键 只有通过watcher 触发的getter 会收集依赖，而所谓的被收集的依赖就是当前watcher.初始化时传入的参数 expOrFn 中涉及到的每一项数据，然后触发该数据项的 getter 函数；getter 函数中就是通过判断 Dep.target的有无来判断是 Watcher 初始化时调用的还是普通数据读取，如果有则进行依赖收集 Dep这个方法是在响应式的过程中调用的，用户修改数据触发 setter 函数，函数的最后一行就是调用 dep.notify 去通知订阅者更新视图。 Directive 关于编译这块vue分了两种类型，一种是文本节点，一种是元素节点 vue内置了这么多的指令，这些指令都会抛出两个接口bind 和 update，这两个接口的作用是，编译的最后一步是执行所有用到的指令的bind方法，而 update 方法则是当watcher 触发 update 时，Directive会触发指令的update方法 observe -&gt; 触发setter -&gt; watcher -&gt; 触发update -&gt; Directive -&gt; 触发update -&gt; 指令 💥源码分析Vue的完全版源码有很多判断以及其他的逻辑， 对于观看源码的人，会造成极大的困难， 因此准备了这版仿照Vue流程实现的 实现了双向绑定的简版Vue, 方便学习理解 通过这版对Vue源码的简易翻版， 我们来快速理解Vue原理 ✨ new Vue首先看一下，我们的 new Vue, 这是所有操作的入口 1234567new Vue(&#123; data: &#123; nickname: '张三', email: "123123@qq.com" &#125;, el: '#app'&#125;) 相信使用过Vue的小伙伴都明白， 这里定义了一个data， 用于存放变量， el是目标dom的选择器 🔥 new Vue 执行时做了什么1234567891011function Vue(option) &#123; var data = option.data this.data = data // 挂载 getter 和 setter observe(data, this) var id = option.el // 编译 模板 var dom = new Compile(document.querySelector(id), this) // 把编译好的模板挂载到 #app 上 document.querySelector(id).appendChild(dom)&#125; 我们可以看到， Vue其实是一个构造函数， 它接收了一个参数option， 这个option就是我们new Vue传入的那个对象因此我们可以通过option 拿到data和el两个变量， 当然这是js基础哈， 我就不再说了 拿到data后， 我们可以看到它调用了一个 observe方法, 将data和this传入( 此时this时Vue实例 ) 接下来又根据el来获取dom， 同样的将获取到的dom和this传入了 Compile中， 并且还接收了一个返回值， 然后又将这个返回值挂到了 #app上 是不是感觉， 什么鬼？, 这顿操作是啥 首先看一下疑惑的 observe， 传入了 data， this, 然后就没动静了， 既然如此， 我们就进入observe看看 找到Observe的构造函数12345function observe(obj, vm) &#123; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(vm, key, obj[key]) &#125;)&#125; 可以看到，它接收一个obj和 vm， 哦， 这里就一一对应上了， 就是我们刚才传入的 data和this 来看看它做了什么， 它把obj枚举了一遍， 并将每一次的 vm, key,value 都传入一个叫 defineReactive的方法 好，那就让来看defineReactive做了什么 1234567891011121314151617181920function defineReactive(vm, key, val) &#123; // 为每个变量分配一个 dep实例 var dep = new Dep() // 配置getter和setter并且挂载到vm上 Object.defineProperty(vm, key, &#123; get() &#123; if ( Dep.target ) &#123; // JS的浏览器单线程特性， 保证整个全局变量在同一时间内， 只有一个监听器使用 dep.addSub(Dep.target) &#125; return val &#125;, set(newVal) &#123; if ( newVal == val ) return; val = newVal; // 作为发布者发出通知 dep.notify() &#125; &#125;)&#125; 我们看到， 它new了一个Dep， 这个Dep就是报刊亭大爷的电话本， 用来收集所有想买报纸或杂志的人的电话， 等到到货时就好挨个通知 然后我们看到了灵魂函数 Object.defineProperty, 嗷那我们应该就明白了， 这里的一顿操作就是为了给data里的每个属性都挂载上 getter，setter, 并且将这些属性直接转移到了vm上（Vue实例） 那既然如此， 🤪让我们看看 getter方法做了什么， 首先它判断了一下Dep.target， 如果Dep.target为true , 就调用dep的addSub方法， 这里Dep.target是啥我们先不管， 留个印象即可 然后它直接return了val 😵再来看看setter方法 setter方法接收一个新值， 首先就是判断了新值和原本的值是否相等， 如果相等就不做处理了， 如果不相等， 它将新值赋给val 然后调用dep实例上的notify方法， notify 看着名字也知道是通知， 也就是大爷挨个打电话的一个操作 好, 这一块我们理顺了， 是为了挂上getter和setter， 但又遇到了新问题dep， dep到底在干什么， 为什么被getter，setter都使用了 找到Dep的构造函数1234567891011121314151617function Dep() &#123; // 存放watcher this.subs = []&#125;Dep.prototype = &#123; // 添加watcher, 也就是添加订阅 addSub(sub) &#123; this.subs.push(sub) &#125;, // 通知所有watcher notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125; 我们可以看到， Dep构造函数中维护了一个 subs数组， 并且下面的在prototype上定义了几个方法， addSub 和notify，这不就是刚刚observe里调用的两个方法吗，哦，明白了， addSub原来是将getter中传入的 Dep.target追加到每个Dep实例都单独维护的一个subs数组中呀， notify就是遍历整个数组，挨个调用update方法（先不管update的具体实现） 好， 解决了observe方法，那我们就回到最初的Vue构造函数中, 继续往下走, 攻克剩余的绿色区域 我们可以看到，它通过el 获取到了dom, 并在new Compile 将dom 传入 那我们就找到Compile的构造函数一探究竟123456function Compile(node, vm) &#123; if(node) &#123; this.$frag = this.nodeToFragment(node, vm) return this.$frag &#125;&#125; 可以看到， 它接收了一个node， 和一个vm , 并且判断了一下node是否存在， 并将node和vm，传入了this.nodeToFragment方法， 又将其的返回结果return出去， 也就是new Compile之后返回的值 ，如下 那this.nodeToFragment这个方法做了什么， 让我们找到他1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Compile.prototype = &#123; nodeToFragment(node, vm) &#123; var _this = this // 创建文档片段 var frag = document.createDocumentFragment() var child; while ( child = node.firstChild ) &#123; // 替换变量 _this.compileElement(child, vm) // 剪贴子元素 frag.append(child) &#125; return frag &#125;, compileElement(node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 节点类型为元素, 根据nodeType来判断 if ( node.nodeType === 1 ) &#123; // 获取自定义属性 var attr = node.attributes for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == "v-model") &#123; // 获取v-model 绑定的属性名 var name = attr[i].nodeValue // 双向绑定 node.addEventListener('input', function(e) &#123; // 给相应的data属性赋值， 进而触发该属性的set方法 // 再批处理渲染元素 vm[name] = e.target.value &#125;) // 把this ，节点， 还有v-model绑定的变量交给watcher new Watcher(vm, node, name, "value") &#125; &#125; &#125; // 节点类型为text if ( node.nodeType === 3 ) &#123; if ( reg.test(node.nodeValue) ) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim() // 把this ，节点， 还有&#123;&#123; xxx &#125;&#125;中使用的变量交给watcher new Watcher(vm, node, name, 'nodeValue') &#125; &#125; &#125;&#125; 我们看到它在Compile原型上挂了nodeToFragment, compileElement两个方法， nodeToFragment方法接收 node, vm参数 先保存了一下this指向, 然后使用document.createDocumentFragment()方法创建了一个文档片段， 并将在while循环中传入的node节点的第一个元素赋值给 child变量，然后使用compileElement(child, vm) 将child和vm 传入, 然后将child 追加给创建好的文档片段frag, 你肯定会觉得这是个死循环, 其实不是的， 这个append对dom有剪切的效果，所以他会一直抽离node的第一个节点，直至node空了， 吸干他 完成了这顿操作后， 再将frag文档片段返回 然后我们来看看它在while中调用的compileElement方法做了什么 它同样接收node和vm , 首先就是定义一个正则， 这是用来匹配双括号的， 也就是我们平时的变量写法 然后它判断了一下这个 node的节点类型, 如果nodeType == 1, 那就说明是元素， 如果nodeType == 3 那就说明节点类型是text 如果节点类型是元素， 就利用attributes 方法，获取到该元素身上的属性, 查看是否存在v-model这样一个属性， 如果有，就获取到v-model填写的变量，交给变量name,然后监听该元素的input事件， 所以每当改元素发生input时间时，就将元素上的value根据v-model上获取到的name作为vm的key去修改vm实例上的对应的值， 因为vm上的变量已经被挂载此来触发vm 最后还创建了一个Watcher实例, 传入vm, node ,name, &quot;value&quot;这几个参数， Watcher的具体实现我们待会去看 接下来就是判断node.nodeType == 3， 也就是text类型的节点， 如果是此类节点， 就先用正则去匹配一下语法， 看看有没有使用到某个变量，如果匹配到了， 则通过RegExp.$1获取到被匹配到的值， 然后去除左右的空格， 交给变量name最后，同样的创建了一个Watcher实例, 传入vm, node ,name, &quot;value&quot;这几个参数， 出现两次Watcher， 什么情况， 到底干了啥那， 现在就来让我们看看神秘的Watcher构造函数 找到Watcher的构造函数1234567891011121314151617181920let uid = 0;function Watcher(vm, node, name, type) &#123; // 单例， 使用原因未知 Dep.target = this // 姓名 this.name = name; // 呵呵哒 uid this.id = ++uid; // 与变量相关的Node节点 this.node = node; // vm 实例 this.vm = vm; // 变量类型 nodeValue || value this.type = type; // 触发自己原型上的update方法 this.update() // Watcher 实例创建结束就把单例置空 Dep.target = null&#125; 此时我们发现了一个关键的东西Dep.target ， 这个鬼东西原来在这里， 它被赋值为了Watcher的实例， 然后在Watcher实例上挂载了name，也就是用到的变量， 还使用了一个uid， 不过这uid也是呵呵了，用数字作为uid, Vue的真实源码就这么干的， 为每个Watcher都配分一个uid， 这会造成数组空间的不连续， 引发内存泄漏 接着说， 然后他将传入的node节点， vm实例， 还有type( ‘nodeValue’ 和 ‘value’ ), 都挂到了实例上面， 并且还在调用了update方法后， 将Dep.target设为null 那我们来看下update做了啥 123456789101112131415Watcher.prototype = &#123; update() &#123; this.get() if(!batcher) &#123; // bastcher 单例 batcher = new Batcher() &#125; // 加入队列 batcher.push(this) &#125;, // 获取新值挂到自己的实例上 get() &#123; this.value = this.vm[this.name] // 触发getter &#125;&#125; 看到update方法， 首先调用了一下get方法， 这个get呢就是根据this.name从 vm实例上取一次值， 并挂到Watcher实例上的value属性上, 并且他还会触发一次getter方法，将自己加入到dep中， 也就是加入到报刊亭大爷的电话本中， 便于之后的通知 然后判断了一下window.batcher是否存在， 如果不存在就创建一个， 保证其是一个单例模式,如果存在， 就将自己(watcher实例)，通过push方法传入 看到这里，又晕了， 什么时候又冒出来一个Batcher 我们又找到Batcher的构造函数好好分析下，12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 批处理构造函数function Batcher() &#123; // 重置 has queue waiting this.reset()&#125;Batcher.prototype.reset = function () &#123; this.has = &#123;&#125; this.queue = [] this.waiting = false&#125; // 将watcher 添加到队列中Batcher.prototype.push = function (job) &#123; let id = job.id // 先根据 对象的key 看看是否已经有了这个watcher if (!this.has[id]) &#123; // console.log(batcher) this.queue.push(job) // 将watcher 的key的设为true this.has[id] = true // 延迟执行 if (!this.waiting ) &#123; this.waiting = true if ( "Promise" in window ) &#123; Promise.resolve().then(() =&gt; &#123; this.flush() &#125;) &#125; else &#123; setTimeout(() =&gt; &#123; this.flush() &#125;, 0) &#125; &#125; &#125;&#125;// 执行并情况事件队列Batcher.prototype.flush = function() &#123; this.queue.forEach(job =&gt; &#123; job.cb() &#125;) this.reset()&#125; Batcher的构造函数很简单， 就调用了一下自己的reset方法， 但好像事情远没有这么简单，我们不是在 Watcher的update方法中调用了batcher.push吗， 我也可以在这原型上找的这个方法， 首先它接收一个job参数， 也就是Watcher实例， 获取到该watcher的id, 然后使用这个id,去has这个对象上访问一下， 看看是否存在，如果不存在，在证明之前没有添加进来过， 然后将该watcher实例加到queue队列中，并将has对象中id对应的值设为true, 以防止重复加入队列 并且判断一下waiting，得知当前是否处于等待状态， 如果不是， 就将waiting改为true, 然后就是判断当前浏览器的支持情况， 将处理的任务扔到异步队列中 它这里这么做是为了，只批处理一次， 你一瞬间加入多个watcher, 很容易造成重复执行， 利用Watcher的id来过滤， 并且利用异步， 等你要加的watcher都加完了， 我再给你统一的去执行所有Watcher 也就是异步任务结束后调用的flush方法， 它在内部会遍历queue队列， 挨个的调用Watcher的cb方法在这一切都执行完成之后， 又调用了一次reset方法， 将bascher的三个属性重置为初始状态 此时关注点又回到了Watcher身上， 它的cb方法又做了什么12345678910Watcher.prototype = &#123; // ...省略其他方法 // 给dom赋值 cb() &#123; // 最终实际虚拟dom 处理结果， 只处理一次 // 虚拟dom -&gt; diff( 虚拟dom ) -&gt; 局部更新 -&gt; createElement(vNode) -&gt; render this.node[this.type] = this.value &#125;,&#125; 可以看到cb方法做的事情很简单那， 就是根据元素的值类型去修改元素对象的值， 而这个this.value早在之前调用 Watcher的get方法时就被赋上了 到这里，整个流程就走完了， 相信你还是一头雾水， 我们把整个流程来串一下 new Vue 将data中的值挂上 getter和setter 的相应方法， 然后暂且搁置，因为此时还无人调用getter和setter 通过 Compile解析模板， 挨个递归#app下的dom, 判断元素类型， 如果是元素，并且使用了v-model， 就绑定一个input事件, 如果是文本类型节点,就去匹配是使用了语法， 最后为他们都创建了一个watcher 每个watcher 用来保存相关的元素对象， vm实例，使用的变量 以及元素值类型, 并将自己的实例交给， Dep.target， 并触发自己的update方法，update方法又会调用get方法， get方法又会触发该变量的getter， 这也就使得getter中可以将该watcher放入dep实例中， 最后将自己也放入Bacher中，用以批处理以及将Dep.target置空 Batcher是个单例， 根据Watcher的id, 它用来过滤重复传入的Watcher, 保证一个Watcher只触发一次, 并将更新事件丢入异步，等当前的连续操作执行完成后去调用Watcher的cb方法更新dom 之后用户修改了变量, setter又会调用dep这个发布者来发出通知， 相关的Watcher的update方法再次被调用， 又会加入batcher , batcher等待异步完成后又调用Watcher的cb方法更新dom 到这里就整个串完了，但是感觉废话还是有点多， 再简化一点流程: new Vue –&gt; Observe 挂载 setter 和 getter –&gt; Compile 编译模板 –&gt; 为每个指令分配一个watcher –&gt; 创建时会调用一次watcher.update 将自己加入到batcher的队列 –&gt;并且此时会触发 getter 将watcher加入dep –&gt; batcher 统一来处理watcher后初始化自己 –&gt; 当用户修改某个变量时 –&gt; dep通知watcher –&gt; watcher又被加入batcher处理 –&gt; watcher 更新dom Vue的batcher还是实现的不是很好， 缺少调度机制， 这点上还是React Fiber更优秀点，Fiber如果遇上了长时间的任务会选择放弃， 避免阻塞进程。 😕好了， 神秘的Vue源码已被揭开面纱， 但这仅仅是简易版的实现， 真实的Vue非常庞大， 还有更多的内容， 这里只是让大家明白MVVM的核心原理 项目源码: https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue 优质文献: 汤姆大叔的观察者模式]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【记录】工具目录]]></title>
    <url>%2F2019%2F03%2F17%2F%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E5%B7%A5%E5%85%B7%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这里存放各种可能用到的用不到的东西， 真用到时方便查找😄 当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用 CSS兼容查询 https://caniuse.com/ https://cssdb.org/ 动画 贝塞尔: http://cubic-bezier.com/#.17,.67,.83,.67 可生成matrix的网站 名称 网址 matrix3d http://ds-overdesign.com/transform/matrix3d.html CSS-Matrix3d https://github.com/Zhangdroid/CSS-Matrix3d matrix http://meyerweb.com/eric/tools/matrix/ tools http://www.f2e.name/case/css3/tools.html 高逼格 web component CSS: https://css-doodle.com/ PostCss 值得收藏的插件 功能 插件名 运行时变量 POSTCSS-CUSTOM-PROPERTIES 与SCSS一致的变量实现 POSTCSS-SIMPLE-VARS 实现类似SASS的@MIXIN的功能 POSTCSS-MIXINS 实现类似SASS的继承功能 POSTCSS-EXTEND 实现类似SASS的IMPORT POSTCSS-IMPORT 面向未来 CSSNext 修复过去（兼容IE，zomm、一像素留白等） CSS Grace PWA 集成化解决方案 lavas 离线状态检测插件 offline.js Node框架 功能 插件名 周边生态 帮助实现DI的库 Awilix awilix-koa 实现控制反转&amp;构造注入的框架 InversifyJS inversify-koa-utils 性能测试 功能 名称 性能测试 Benchmark.js webpack4学习帮助 webpack-internal-plugin-relation 可视化的webpack 钩子 功能性能类 功能 插件名 自动插入html及静态文件 HtmlWebpackPlugin【配置自动注入loading（监测资源）】 抽离css文件 MiniCssExtractPlugin 清空指定目录 CleanWebpackPlugin js 深度 tree sharking 基于ES6模块 webpack-deep-scope-plugin css tree sharking PurifyCSSPlugin 多核打包件 [需要babel] uglifyjs-webpack-plugin[官方], happypack 前端缓存负载【自动生成缓存文件】 Webpack Manifest Plugin js 压缩 以及 es压缩 多核压缩 webpack-parallel-uglify-plugin, happypack hint css 多核压缩css css-nano, optimize-css-assets-webpack-plugin js 转 ast静态语法分析树 acorn , acorn-walk 能对html进行hint 以及 fix 的插件 html-minifier, html-minifier-lint 搬运静态文件 copy-webpack-plugin 在html 插入静态资源路径 add-asset-html-webpack-plugin 优化体验类 功能 插件名 监测 webpack 打包速度 speed-measure-webpack-plugin 打包成功通知 webpack-build-notifier 显示打包进度 progress-bar-webpack-plugin 信息面板优化 webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览] 修改cmd 标题 node-bash-title[ github ][cmder 无效] loader 功能 插件名 缓存Loader结果 cache-loader AST acorn 生成 Ast acorn-walk 将AST转回代码 estraverse 用于遍历Ast 树 JavaScript颜色提取 RGBaster TypeScript运行工具 功能 插件名 周边生态 在node中不用编译就运行 ts-node ts-node-dev 热重启 Linuxvim 快速学习vim的网站: https://vim-adventures.com/ 算法学习帮助 算法过程可视化: https://algorithm-visualizer.org/branch-and-bound/binary-search k8s 中文手册: https://www.kubernetes.org.cn/docs Chart 应用仓库: https://hub.kubeapps.com/ 图形学 算法生成图像: https://blog.csdn.net/zhangpiu/article/details/49511107s canvas 库 提供基础的canvas效果库： http://spritejs.org/#/ 物理引擎 cocos2D： https://cocos2d-x.org/products phaser： http://phaser.io/ Three stats.min.js 显示动画帧率 性能优化更新算法（文件增量更新） mt.js (https://github.com/mtjs/mt)]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【容器】docker命令手册]]></title>
    <url>%2F2019%2F03%2F17%2F%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91docker%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[使用docker 查看所有命令 基本命令 命令 功能 示例 FROM 声明底包来源 FROM centos RUN 构建命令–只在构建镜像中使用 RUN yum install wget -y WORKDIR docker中必须用此切换目录 WORKDIR Python-3.7.0 CMD 运行命令 CMD python3 -m http.server docker build ‘dockerfile的路径’ 构建新镜像 进程相关命令 在docker client中使用 命令 功能 示例 docker ps 查看进城 docker ps docker kill ‘id’ 杀死指定容器 docker kill 123 docker rename 容器改名 docker restart 重启容器 docker rm 移除一个或多个’容器’(停止状态的容器) docker rmi 移除一个或多个’镜像’ python项目配置文件分析1234567891011121314151617181920212223242526# 前两行固定写法~# 你的底包来源FROM centos# 作者(用于上传时使用)MAINTAINER nxl &lt;nxl3477@foxmail.com&gt;# RUN构建命令--只在构建镜像中使用 ( -y 表示全部yes)RUN yum install gcc automake autoconf libtool make -y # python 依赖于 zlibRUN yum install zlib zlib-devel libffi-devel -y# 安装 wgetRUN yum install wget -y# 下载python安装包RUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz# 解压缩RUN tar -zxvf Python-3.7.0.tgz# 切换目录WORKDIR Python-3.7.0# 编译安装RUN ./configureRUN ls -alRUN make &amp;&amp; make install # CMD 运行命令， 唤起python自带的服务器CMD python3 -m http.server]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css分层&命名规范]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E5%88%86%E5%B1%82-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为什么要分层? CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。 避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。 有责任感地去命名你的选择器 有哪些分层理论? SMACSS BEM SUIT ACSS ITCSS BEMBEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier ) block - 代表了更高级别的抽象或组件 block__element - 代表.block的后代， 用于形成一个完整的.block的整体。 block–modifier - 代表.block 的不同状态或不同版本。 修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 ) 12345678&lt;!-- container 是大容器 --&gt;&lt;div class="container"&gt; &lt;div class="menu"&gt; &lt;div class="menu--item menu--item__active"&gt;首页&lt;/div&gt; &lt;div class="menu--item"&gt;新闻&lt;/div&gt; &lt;div class="menu--item"&gt;消息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【css-doodle】 css web-component入门]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90css-doodle%E3%80%91css-web-component%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效 https://css-doodle.com/ &lt;css-doodle /&gt;基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。 既然它这么牛逼， 那怎么用呢？ 我们一起来搭几个demo css-doodle入门 此处用到的语法或api有不了解的 请看页面下方的“释义” 区域 动手过程中需要注意， 不要在css-doodle内部写注释， 会导致样式无效 首先搭建好运行css-doodle的环境12345678&lt;!-- 引入CDN --&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js"&gt;&lt;/script&gt;&lt;!-- 页面上加入 css-doodle --&gt;&lt;css-doodle&gt;&lt;!-- 我们将在这里写代码 --&gt;&lt;/css-doodle&gt; 此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。 现在我们给他加点料。 12345&lt;css-doodle&gt; width: 100px; height: 100px; background: red;&lt;/css-doodle&gt; 此时我们再看看页面， 就出现了一个100 x 100的红色小方块， 好，这个相当于hello world 级别的练习就完成了， 我们再来点难的： 我想要一个10 x 10 个的小方块组成的大正方形! 正好我们可以借此尝试使用一下它提供的API 123456&lt;css-doodle&gt; :doodle &#123; @grid: 10x10 / 500px; &#125; background: #60569e;&lt;/css-doodle&gt; 出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色 好既然实现了， 那现在需求升级了 那我要10个长方形怎么办， 并且我还要长短不一的！ 我去，还要长短不一， 咋整呢 别慌 机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数@index 严格的来说他会返回当前单元格的索引值 既然有方法了那我们也有思路了， 二话不说开始动手。 12345678910&lt;!-- 首先把 10 x 10 小方块变为10个长方形 --&gt;&lt;!-- 然后根据 @index 获取当前单元格的索引 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; background: #60569e; @size: calc(@index() * 1vmin);&lt;/css-doodle&gt;&lt;!-- 根据 index 这个索引值乘以高度 --&gt; duang! 这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了 我们再给他加上border-radius: 50%; 它就变成10个球了 此时需求又来了 甲方：可不可以弄10个光环？还是渐变的那种? 行吧， 试试喽谁怕谁 我们可以举一反三， 利用@index这个好东西来修改hsla产生不同的颜色， 当然修改rgba 也是可以的 123456789101112&lt;!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 --&gt;&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%;&lt;/css-doodle&gt; 好， 甲方爸爸， 你的需求我做到了 甲方: 还不够，我要的是同心圆 我。。。。。 得嘞，您说是啥就是啥 同心圆， 你第一反应想到的是不是使用position: absolute; ?不 ，那太low 了我们只需要 @place-cell: center; 这个参数就搞定了， 它会将每个单元格都摆放至中间 12345678&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; &lt;!-- ...省略之前的代码 --&gt;&lt;/css-doodle&gt; 然后去看一下效果， 卧槽 进阶基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧 既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下 我们先让光环变粗一点， 让他呈现扇叶的形状 1border-width: calc(@index() * 10px); 然后让我们用上 keyframes ， 为他添加动画 为每个单元格注册几个css变量（css的新特性）， 变量--speed控制动画的持续时间，也就是速度。 --start 控制当前光环的起始角度 --direction: 控制方向， 因为turn表示一圈， 所以 1turn 就是正的转一圈,-1turn 就是反着转一圈， 利用@pick方法来随机取一个值 1234567891011121314151617181920212223&lt;css-doodle&gt; &lt;!-- ...省略之前的代码 --&gt; &lt;!-- 动画执行时间在20秒 - 40秒之间取值--&gt; --speed: @rand(20s, 40s); &lt;!-- 360度里取随机数 --&gt; --start: @rand(360deg); &lt;!-- 顺时针 或 逆时针 --&gt; --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) linear infinite; @keyframes demo &#123; form &#123; &lt;!-- 填入起始角度 --&gt; transform: rotate(var(--start)); &#125; to &#123; &lt;!-- 随机顺时针和逆时针旋转 --&gt; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt; 看看效果 炫酷不？ 能不能再酷一点？ 可以， 我们再给他添一笔， 给他加上一个自定义的贝塞尔 贝塞尔可以去这个网站，根据需要生成 http://cubic-bezier.com/#1,.25,.83,.67 然后我们你所需要的贝塞尔去更改animation 的参数1animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; 根据贝塞尔曲线完成了加速减速的动画效果 😎cool~ 还有更多更酷的特效等着大家去探索~ 切记css-doodle 中不能写注释，大家拷贝的时候记得删掉 释义 :doodle 选择器会创建一个display: grid; 的布局 @grid提供布局， 用法为 @grid: 行 x 列 / 总宽高 @index 返回当前单元格的索引 hsla 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% A：Alpha透明度。取值0~1之间。 @place-cell 调整单元格相对于网格放置。 @pick： 从给定列表中随机选择一个值。 turn: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad ) 1turn 就是1圈 完整的代码1234567891011121314151617181920212223242526&lt;css-doodle&gt; :doodle &#123; @grid: 1x10 / 61.8vmin; &#125; @place-cell: center; border-color: hsla( calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8) ); border-width: calc(@index() * 10px); @size: calc(@index() * 10%); border-style: dashed; border-radius: 50%; --speed: @rand(20s, 40s); --start: @rand(360deg); --direction: calc(var(--start) + @pick(1turn, -1turn)); animation: demo var(--speed) cubic-bezier(0,.88,.42,.99) infinite; @keyframes demo &#123; form &#123; transform: rotate(var(--start)); &#125; to &#123; transform: rotate(var(--direction)); &#125; &#125;&lt;/css-doodle&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web-component</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CSS混合模式更改图片颜色]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%88%A9%E7%94%A8CSS%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[CSS3 新增了一个很有意思的属性 mix-blend-mode ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。 混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。 开始动手吧 ~ 尝试修改图片物体颜色首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）1234&lt;body&gt; &lt;input type="color" /&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553336864&amp;di=2f41edc8eedbf09fb1d106545acaed5f&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg" alt=""&gt;&lt;/body&gt; 然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式mix-blend-mode: hue; 因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效 123456789101112&lt;style&gt;html,body, input, img &#123; width: 100%; height: 100%;&#125;input&#123; position: absolute; top: 0; left: 0; mix-blend-mode: hue;&#125;&lt;/style&gt; 过程记录原图: 添加上了混合模式(变灰是因为color选择器默认是黑色): 切换颜色中: 切换后: 虽然有点丑但我们成功了~ 更多可能性利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错 参考文献 https://www.cnblogs.com/coco1s/p/6829372.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【容器】Docker入门教程]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91Docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.1 Docker简介 Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 2.1 Docker vs. VM VM： 运行在宿主机之上的完整的操作系统 运行自身操作系统会占用较多的资源 Docker： Docker更加轻量高效 对系统资源的利用率很高 比虚拟机技术更为轻便、快捷 隔离效果不如VM 总的来说， 虚拟机是在操作系统上又装了一个操作系统，运行操作系统特别消耗资源 而Docker是一种类似于隔离的技术， 由CPU 和Linux内核提供的虚拟化技术， 公用你宿主机上的内核， 在Docker中再装了一层shell, 并且Docker和其他Docker之间是可以通过内核相互进行通信的(Linux进程之间必须经过内核) 3.1 镜像与容器image是静态的概念， 比如： 你的exe文件 container是动态的概念， 比如： 你执行exe后的进程 4.1 Docker相关概念 Docker是CS架构，主要有两个概念： Docker daemon: 运行在宿主机上 Docker守护进程 用户通过Docker client(Docker命令)与Docker daemon交互 Docker client: Docker 命令行工具，是用户使用Docker的主要方式 Docker client与Docker daemon通信并将结果返回给用户 Docker client也可以通过socket或者RESTful api访问远程的 Docker daemon 4.2 相关概念详解Docker最底层是宿主的操作系统内核， 再上层就是底包， 底包就是存放bash以及bash所依赖的基本环境， 每个系统都有不一样的底包， 你可以自己去做底包， 也可以到dockerHub里找 在此之上一层一层的往上累加，比如Node、Mysql啥的, 最后扔到容器里跑, 就像下面这张图， 一层一层的往上叠加，跟码头的集装箱一样 5.1 Dockerfile 脚本 规定了如何创建Image Dockerfile 概念 Dockerfile 文件格式 构建镜像 镜像标签 修改容器内容 6.1 配置文件分析1234567891011121314151617181920212223242526# 前两行固定写法~# 你的底包来源FROM centos# 作者(用于上传时使用)MAINTAINER nxl &lt;nxl3477@foxmail.com&gt;# RUN构建命令--只在构建镜像中使用 ( -y 表示全部yes)RUN yum install gcc automake autoconf libtool make -y # python 依赖于 zlibRUN yum install zlib zlib-devel libffi-devel -y# 安装 wgetRUN yum install wget -y# 下载python安装包RUN wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz# 解压缩RUN tar -zxvf Python-3.7.0.tgz# 切换目录WORKDIR Python-3.7.0# 编译安装RUN ./configureRUN ls -alRUN make &amp;&amp; make install # CMD 运行命令， 唤起python自带的服务器CMD python3 -m http.server]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js与CSS变量操作]]></title>
    <url>%2F2019%2F03%2F16%2FJs%E4%B8%8ECSS%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排 一起来看看如何操作吧~ 变量虽好， 不可滥用哦 定义一个简单的变量12345678/* 定义css 变量 */:root &#123; --backgroundColor: pink;&#125;body &#123; background-color: var(--backgroundColor);&#125; 创建一个按钮123&lt;body&gt; &lt;button id="btn"&gt;点我改变背景&lt;/button&gt;&lt;/body&gt; 获取root元素并绑定按钮的点击事件12345678&lt;script&gt;var root = document.documentElementbtn.onclick = function() &#123; // 将变量修改为天蓝色 root.style.setProperty('--backgroundColor', 'skyblue')&#125;&lt;/script&gt; 结果对比点击前 按钮点击后 非常Nice~ 利用这个特性实现更多的可能吧！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS如何了解新知识]]></title>
    <url>%2F2019%2F03%2F16%2FCSS%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E6%96%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现 并且还可以尝试着参与MDN的文章翻译及国外优质技术文章 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference]]></content>
      <categories>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>学习技巧</tag>
        <tag>学习渠道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PostCss】使用明天的CSS]]></title>
    <url>%2F2019%2F03%2F16%2F%E3%80%90PostCss%E3%80%91%E4%BD%BF%E7%94%A8%E6%98%8E%E5%A4%A9%E7%9A%84CSS%2F</url>
    <content type="text"><![CDATA[通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法 当然国内的情况有点不一样 新特性举例比如这个CSS变量:他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了12345@custom-media --viewport-medium (width &lt;= 50rem);@media (--viewport-medium) &#123; body &#123; font-size: calc(var(--fontSize) * 1.2); &#125;&#125; 那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码 123@media (max-width: 50rem) &#123; body &#123; font-size: 1.2rem; &#125;&#125; 更多演示 编译前后以 —— 分割 自定义选择器1234@custom-selector :--heading h1, h2, h3, h4, h5, h6;:--heading &#123; margin-top: 0 &#125;/* ------------------------------------ */h1,h2,h3,h4,h5,h6 &#123; margin-top: 0 &#125; 自动一倍图(1X)和二倍图(2X)123456789101112131415161718192021222324/* image-set function */.foo &#123; background-image: image-set( url(img/test.png) 1x, url(img/test-2x.png) 2x );&#125;/* ------------------------------------ *//* 默认状态 */.foo &#123; background-image: url(img/test.png);&#125;/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例 */@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) &#123;.foo &#123; background-image: url(img/test-2x.png);&#125;&#125; any-link, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效1234567891011121314151617181920212223a &#123;color: var(--highlightColor);transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: gray(255, 50%) &#125;a:active &#123; color: rebeccapurple &#125;a:focus &#123; background-color: rgb(255 153 0 / 33%); outline: 3px solid hsl(1turn 60% 50%); &#125;a:any-link &#123; color: color(var(--highlightColor) blackness(+20%)) &#125;/* --------------------------------- */a &#123; color: rgb(89, 185, 204); -webkit-transition: color 1s; transition: color 1s; /* autoprefixed ! */&#125;a:hover &#123; color: rgba(255, 255, 255, 0.5) &#125;a:active &#123; color: #639 &#125;a:focus &#123; background-color: rgba(255, 153, 0, .33); outline: 3px solid hsl(360, 60%, 50%); &#125;a:link,a:visited &#123; color: rgb(89, 142, 153) &#125; 还有很多， 不一一举例了， 比如： 各个浏览器的滤镜filter兼容 选择器正则 css嵌套 如何让PostCS支持嵌套 本环境基于webpack npm地址: https://www.npmjs.com/package/postcss https://www.npmjs.com/package/postcss-loader 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */ &amp; .menu &#123; height: 40px; background: sandybrown; &amp; .menu--item &#123; height: 40px; color: skyblue; &amp; .menu--item__active &#123; color: pink; &#125; &#125; &#125;&#125; 首先在项目的根目录中创建一个文件postcss.config.js 相关依赖安装就不说了， 真的缺了也会报错提示的 我们将会在里面做PostCSS的相关配置 12345module.exports = &#123; plugins: [ require('postcss-nested') ]&#125; 然后接下来是配置 Loader ， 进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader123456789101112131415161718192021222324252627rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'css-loader', &#125;, // --------------新增区域--------------- &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: (loader) =&gt; [ require('postcss-preset-env')(&#123; /* 这里要改成 0 否则不一定编译嵌套 */ stage: 0, features: &#123; 'nesting-rules': true &#125; &#125;) ] &#125; &#125; // --------------新增区域--------------- ] &#125;] 像这样，记得把 stage 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。 我们运行一下看看 1234567891011121314.container &#123; /* 一定要带上 &amp; 才会编译 */&#125;.container .menu &#123; height: 40px; background: sandybrown&#125;.container .menu .menu--item &#123; height: 40px; color: skyblue&#125;.container .menu .menu--item .menu--item__active &#123; color: pink;&#125; 大功告成😄~ 想知道有用的PostCSS的插件大纲，可以在本站内搜索: CSS插件 相关的网站 PostCss: https://postcss.org/css next: http://cssnext.io/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins构建前端持续集成]]></title>
    <url>%2F2019%2F03%2F16%2F%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装JDK 直接使用yum 安装的是 openjdk , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装 1yum install -y java 安装jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。 123wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.reporpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.keyyum install -y jenkins 添加Jenkins库到yum库，Jenkins将从这里下载安装。12wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 配置jenkis的端口 jenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口 1vim /etc/sysconfig/jenkins 找到修改端口号： JENKINS_PORT=”8080” 启动jenkins 1service jenkins start/stop/restart 安装成功后Jenkins将作为一个守护进程随系统启动 系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改/var/log/jenkins, /var/lib/jenkins, 和/var/cache/jenkins的所有者 启动的时候将从/etc/sysconfig/jenkins获取配置参数 默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置 Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo 配置阶段安装好jenkins 后 ， 我们就可以根据刚才所设置的端口号访问 jenkins 服务了 比如进入 127.0.0.1:8081 访问jenkins 首先会看到让我们输入初始密码 它提示我们进入 /var/lib/jenkins/secrets/initialAdminPassword 查看 输入密码无误后， 就是提示我们安装对应的插件了， 左边是推荐安装， 右边是自定义安装， 这里我们建议点击 推荐安装 安装过程可能稍长 这时我们创建一个 Jenkins 账户，一定要牢记你的输入账号和密码， 用作之后的登录 创建账户之后， 会显示一个 jenkins 的资源根路径， 一般不需要修改， 保持默认即可 之后就是愉快的jenkins 之旅啦 补善插件阶段我们要做的前端持续集成， 所以 jenkins 默认安装的插件 并不能完全的满足我们的需求 进入jenkins 主页面后， 找到插件管理 首先查看我们必要的插件是否安装好了 NodeJs Plugin Publish Over SSH GitHub 如果发现没有安装的就安装， 查漏补缺 变量及远程服务器基本配置插件安装好后, 进入系统设置 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好 管理员邮件地址, 推荐填写, 当jenkins 工作完成后会把 构建信息发送至此邮箱 (这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上 比较重要的就是这里了 , 配置远程服务器, 也就是你的发布地址 点击新增添加你的服务器 点击新增后, 这里有几个关键的参数, 需要注意 连接目标服务器肯定需要登录, 下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容, 前提是你配置了 ssh 的免密登录 填写密钥路径这里你很有可能会出现权限不够的错误， 如下图， 因为jenkins的在运行时会自动的创建一个名为jenkins的用户， 而这个用户的权限不够，无法访问你的目录 解决方案有两个: 把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限 把jenkins 的运行身份修改为 root, 但是会有点安全性问题 本次实践以学习为目的， 所以这里我选择了第二钟 相关操作文章: https://blog.csdn.net/jeikerxiao/article/details/80768949 ssh 免密配置成功后， 我们就可以开始创建一个自己的任务了 创建任务阶段回到主页， 找到新建任务 进入新建任务后， 有几种不同的项目， 我们这里选择 自由风格， 并且输入项目名称 创建好项目后就会自动进入 当前项目的配置文件中 首先我们看到General, 这是一些全局的配置， 在这里我们可以写上该项目的描述 General的后面几个类目是构建项目阶段几个比较大的步骤和流程 如果你要配置的“github”项目， 可以在Git这里打上勾 并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在Credentials 处新增配置 接下来是看看构建触发器， 这里的填写根据你的工程需要， 可以配置定时任务 或 多任务构建 本次演示我并没有用到 现在来到我们的重点构建 ， 我们可以添加步骤，我们可以看到能够支持 Node、shell 、批处理等等方式 这些添加的步骤会按顺序执行， 我们需要shell 脚本来运行npm 命令 所以我创建了 shell的操作步骤 基于此， jenkins 就会自动帮我们做好 测试与打包的步骤， 在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个send files or execute commands over SSH 步骤， 建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去 deploy文件参考 你可能遇到的问题命令无效或不存在 这里拿npm举例， 其他命令如:node ,都是同理 因为全局的命令需要设置软连接 Jenkins 才可以访问的到 如何设置: 先查看一下你的 npm 在哪 whereis npm 这个/usr/local/bin/npm 就是你的npm所在位置 ( 使用带 local 的地址) 我们来创建 软连接, 这里使用刚刚获取到的npm ln -s /usr/local/bin/npm /usr/bin 如果出现无法修改的情况， 那我们就将他强制更改 😄 ln -sf /usr/local/bin/npm /usr/bin 再去构建一次Jenkins 任务 看到控制台输出， 现在npm 可以正常运行了 持续集成的必要条件 必须有github 、svn或私有git服务器 完整的项目 test 接口测试 其他的测试内容 CI 平台 项目代码要提交到Github、 svn等服务器上 保证代码在开发机的正常 bug 运行环境 ( 引用的包要写入packa) 保证jenkins 环境一切正常 发布服务器上也要存在基础的运行环境(不包括项目本身引用的包) 必要的静态资源服务器 配置jenkins的自动化处理流程 参考文章: https://www.cnblogs.com/loveyouyou616/p/8714544.html]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
        <tag>Centos</tag>
        <tag>前端持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理与后处理器]]></title>
    <url>%2F2019%2F03%2F16%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css 一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器， 所以使用预处理器的意义越来越小了 预处理器具有的能力 变量 混合(Mixin) Extend 嵌套规则 运算 函数 Namespaces &amp; Accessors (命名空间和访问器) scope 注释 后处理器的能力 CSS 压缩 CLEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework取代stylus 后处理器发热 前后通吃的 PostCss 他们是如何处理的CSS预处理器预处理器， 如： sass 它会先将他的语法转换成 AST–抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS PostCssPostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手AngularJs入门教程]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%89%8B%E6%91%B8%E6%89%8BAngularJs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[AngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。 这里我们用AngularJs7的练手吧 起步 请确保电脑已安装了Node.js 首先是全局安装脚手架1npm install -g @angular/cli 安装好后查看一下版本 ng –version 确认ng命令存在后就可以开始创建我们的第一个 Angular 项目了12# 创建项目 project 替换为你的项目名称ng new project 当你输入命令后他会问你需要的配置， 这里附上我的选择， 大家可以参照 你是否需要添加路由？ —- yes 选择你喜欢的css 风格 —- SCSS 选择好后， 就会进入漫长的安装了 安装好后， cd 进入到项目所在的目录， 运行 ng serve 命令， 并打开http://localhost:4200/ 查看我们第一个 Angular项目12345678# 进入你的项目目录cd project# 启动项目ng serve# 如果你需要 可以生产环境运行ng serve --prod --aot 基本的路由配置 如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能因为之前我们在构建项目时就选择了加入路由， 因此也省去了很多配置过程， 现在，我们来看看怎么用吧， 首先想使用路由， 得需要再创建一个”页面”（这里指组件）， 这样才能通过切换看出是否实现了路由， 那如何创建一个组件呢？ Angular 给我们提供了非常多的创建命令， 组件也可以一键的生成 我们来创建一个 Demo 组件 ng g c Demo 等待片刻， 安装好后 我们发现项目文件中的 app 目录下多了一个文件夹 里面有配套的 模板文件 样式文件 测试文件 ts 脚本文件 既然有了组件， 那我们现在需要为这个路由分配相应的访问路径 进入 app/app-routing.module.ts 这个文件 我们首先导入刚刚创建的Demo组件， 再 routes数组中，分配一个用于访问的path, 并和导入的DemoComponent关联上 如下: 123456789101112131415161718192021// ------------新增区域------------import &#123; DemoComponent &#125; from './demo/demo.component';// ------------新增区域------------import &#123; NgModule &#125; from '@angular/core';import &#123; Routes, RouterModule &#125; from '@angular/router';const routes: Routes = [ // -----------新增区域------------- &#123; path: "demo", component: DemoComponent &#125; // ------------新增区域------------];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 然后进入 app/app.component.html 文件中找到 &lt;router-outlet&gt;&lt;/router-outlet&gt; 刚才配置的路由就会显示在这个标签所在的位置，为了减少一点干扰，我们把没有用的信息删除 !component19html切换后](http://img.nixiaolei.com/2019-03--17-17-27-25.png app.我只留了一张图片, 然后我们进入 app/demo/demo.component.html 文件中 原本是123&lt;p&gt; demo works!&lt;/p&gt; 我们改成明显一点的内容 千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息 123&lt;div&gt; &lt;h1&gt;我是Demo 页面&lt;/h1&gt;&lt;/div&gt; 我们看看是否配置成功了 首先，刚进入， 只有一张图片 让我们切换至/demo 我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 app/app.component.html 中所做的配置一样 ——————–待完善————————- 常用的命令 把 XXX 替换成你要的名字 ng g cl xxx // 创建一个新类 ng g c xxx // 创建一个新组件 ng g d xxx // 创建一个新指令 ng g e xxx // 创建一个新枚举 ng g m xxx // 创建一个新模块 ng g p xxx // 创建一个新管道 ng g s xxx // 创建一个新的指服务 参考文献 https://github.com/angular/angular-cli/wiki]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中如何使用本地图片]]></title>
    <url>%2F2019%2F03%2F16%2Fhexo%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先需要修改_config.yml配置文件post_asset_folder项为true 使用命令创建博客1hexo new 你的文章名称 他会生成.md文件及一个对应的文件夹， 我们将图片放到该文件夹中 方法一在文章中这样插入图片1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 效果如下: 方法二 这个方法在首页无法正常预览图片 安装一下这个插件 1npm install hexo-asset-image --save 在文章中这样插入图片1![这是一张图片](xxxx.png) 效果如下: 参考文献 http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
