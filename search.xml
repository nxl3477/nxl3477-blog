<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【flutter】如何将打项目包成app</title>
    <url>/2019/11/23/%E3%80%90flutter%E3%80%91%E5%A6%82%E4%BD%95%E5%B0%86%E6%89%93%E9%A1%B9%E7%9B%AE%E5%8C%85%E6%88%90app/</url>
    <content><![CDATA[<h1 id="首先需要创建一个-keystore"><a href="#首先需要创建一个-keystore" class="headerlink" title="首先需要创建一个 keystore"></a>首先需要创建一个 keystore</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key</span><br></pre></td></tr></table></figure>
<p>设置一下密钥库口令， 自己要记住不要忘记， 最少6位字符（对安卓一窍不通的我刚开始还以为是以前某个时候生成的， 完全想不起来是啥， 后来才知道原来是创建一个新的）</p>
<p><img src="http://img.nixiaolei.com/2019-11-23-10-13-04.png" alt="2019-11-23-10-13-04"></p>
<p>按命令一步一步来就可以创建好了， 顺便记一下 <code>key.jks</code>的生成地址， 待会要用</p>
<h2 id="配置-key-properties-文件"><a href="#配置-key-properties-文件" class="headerlink" title="配置 key.properties 文件"></a>配置 key.properties 文件</h2><p>进入 <code>flutter_app项目/android/</code> 目录， 创建一个 <code>key.properties</code> 文件, 填入以下信息， 注意要根据自己填的密钥口令来写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">storePassword=123456	秘钥库密码</span><br><span class="line">keyPassword=123456		key密码</span><br><span class="line">keyAlias=key			key别名</span><br><span class="line">storeFile=D:/android/android_work_space/demo/flutter_app/key.jks		key.jks存放路径</span><br></pre></td></tr></table></figure>
<h2 id="配置-build-gradle"><a href="#配置-build-gradle" class="headerlink" title="配置 build.gradle"></a>配置 build.gradle</h2><p>进入 <code>flutter_app项目/android/app/build.gradle</code> 目录， 我们需要添加以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;)</span><br><span class="line">def keystoreProperties = new Properties()</span><br><span class="line">keystoreProperties.load(new FileInputStream(keystorePropertiesFile))</span><br></pre></td></tr></table></figure>
<p>放在红色框框区域</p>
<p><img src="http://img.nixiaolei.com/2019-11-23-11-27-16.png" alt="2019-11-23-11-27-16"></p>
<p>接着用这段代码替换掉原本的 <code>buidTypes</code>相关代码  并增加了 <code>signingConfigs</code> 相关代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        keyAlias keystoreProperties[&apos;keyAlias&apos;]</span><br><span class="line">        keyPassword keystoreProperties[&apos;keyPassword&apos;]</span><br><span class="line">        storeFile file(keystoreProperties[&apos;storeFile&apos;])</span><br><span class="line">        storePassword keystoreProperties[&apos;storePassword&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.nixiaolei.com/2019-11-23-11-30-43.png" alt="2019-11-23-11-30-43"></p>
<h2 id="授权允许访问互联网"><a href="#授权允许访问互联网" class="headerlink" title="授权允许访问互联网"></a>授权允许访问互联网</h2><p>进入 <code>flutter_app项目/android/app/src/profile/AndroidManifest.xml</code></p>
<p>将以下代码复制进去<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.nixiaolei.com/2019-11-23-11-33-35.png" alt="2019-11-23-11-33-35"></p>
<p>到这里为止， 我亲身实践还没有成功， 因为还有一个配置文件, 需要再做一次上面的事情</p>
<p>我们可以看到整个目录下面有两个相同的<code>AndroidManifest.xml</code>文件<br><img src="http://img.nixiaolei.com/2019-11-23-11-34-58.png" alt="2019-11-23-11-34-58"></p>
<p>所以我们需要进入 <code>flutter_app项目/android/app/src/main/AndroidManifest.xml</code></p>
<p>把上面的代码同样粘贴进去</p>
<p><img src="http://img.nixiaolei.com/2019-11-23-11-36-02.png" alt="2019-11-23-11-36-02"></p>
<p>如此大功告成， 可以打包了</p>
<h2 id="打包-app"><a href="#打包-app" class="headerlink" title="打包 app"></a>打包 app</h2><p>flutter build apk</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】如何资源定位</title>
    <url>/2019/11/20/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91%E5%A6%82%E4%BD%95%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="资源定位"><a href="#资源定位" class="headerlink" title="资源定位"></a>资源定位</h1><p>浏览器会自动的缓存静态文件， 如： <code>a.css</code> 第一次访问成功后被浏览器缓存， 第二次就回直接走内存中读取，  这有利于提升性能， 但这也带来了一些问题， 当网站发布新版本的时候， 无法做到强制用户的浏览器去更新数据， 浏览器还是傻傻的使用了之前的缓存</p>
<p>所有有了多种解决办法， 但也各有利弊</p>
<h2 id="1-加版本号"><a href="#1-加版本号" class="headerlink" title="1. 加版本号"></a>1. 加版本号</h2><p>加版本号是最常见的方法， 比如：</p>
<ul>
<li>a.css?v=1.1</li>
<li>b.css?v=1.1</li>
</ul>
<p>这个方法确实非常有效， 每次发布新版本都可以做到及时更新数据了，但这又带来了一些问题</p>
<ol>
<li>我a修改了， b没有修改。 b的版本也要更新， b的浏览器缓存就被浪费了</li>
<li>每次修改， 引用的所有静态文件都要去手动更改版本号， 特别麻烦</li>
</ol>
<h2 id="2-md5戳"><a href="#2-md5戳" class="headerlink" title="2. md5戳"></a>2. md5戳</h2><p>因为版本号所带来的问题， 所以就有人有了新的想法， 将版本号改为了md5戳， 这样就不用去因为版本号浪费缓存资源</p>
<p>但这又产生了新问题</p>
<p>当你改了html， 也改了css , 我们应该先上谁</p>
<ol>
<li>先上html的话， 在你上新版<code>css</code> 之前访问的用户就会出现问题， 依旧会使用旧的css样式。 </li>
<li>先上css的话， 在你上新版<code>html</code>之前， 如果用户没有<code>css</code>缓存, 用旧的<code>html</code>去使用新的<code>css</code>也会出现问题。</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-11-20-11-49-49.png" alt="2019-11-20-11-49-49"></p>
<p><strong>那为什么不一起上呢？</strong></p>
<p>这个因为css 和 html资源不可能一样大， 发布所需要的时间也不同， </p>
<p>那怎么办呢</p>
<h2 id="3-将md5作为文件名"><a href="#3-将md5作为文件名" class="headerlink" title="3. 将md5作为文件名"></a>3. 将md5作为文件名</h2><p>既然后面加md5戳行不通， 那就又有了新思路， 我们把md5作为 css的文件名，</p>
<p>然后先发布新的css资源文件，再发布新的html文件</p>
<p>上新的css保留旧的css文件， 不要去删除旧的css ,尽管旧文件都在， 但是没关系的，  利 &gt; 弊</p>
<p><strong>这样的好处呢？</strong></p>
<ul>
<li>将md5作为css 的文件名就是为了每次将css资源作为新的文件发布， 不覆盖原有的文件</li>
<li>html未发布之前依旧可以访问到旧的css ,  新的html发布立即可以访问到新的css资源</li>
<li>并且方便回滚， 回滚不用上线， 只要改个html， 静态资源全部都还在</li>
</ul>
<h2 id="4-更优的解决办法"><a href="#4-更优的解决办法" class="headerlink" title="4. 更优的解决办法"></a>4. 更优的解决办法</h2><p>哪变了弄哪， 不把整个文件都改进去</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>配置超长时间的本地缓存 - 节省带宽， 提高性能</li>
<li>采用内容摘要作为缓存更新依据 - 精确的缓存控制</li>
<li>静态资源cdn部署</li>
<li>更资源发布路径实现<strong>非覆盖式发布</strong> - 平滑升级</li>
</ol>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>资源定位</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】初识WebComponents</title>
    <url>/2019/11/20/%E3%80%90JS%E3%80%91%E5%88%9D%E8%AF%86WebComponents/</url>
    <content><![CDATA[<h1 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h1><ul>
<li>Custom Elements<ul>
<li>定制元素， 也就是自定义的元素，像vue的组件</li>
</ul>
</li>
<li>HTML Imports<ul>
<li>支持import 方式引用组件</li>
</ul>
</li>
<li>HTML Templates<ul>
<li>可以实现把dom结构写好</li>
</ul>
</li>
<li>Shadow DOM<ul>
<li>沙箱dom ， 外部的css不会影响其</li>
</ul>
</li>
</ul>
<h2 id="Custom-Elements"><a href="#Custom-Elements" class="headerlink" title="Custom Elements"></a>Custom Elements</h2><p>提供⼀种⽅式让开发者可以⾃定义 HTML 元素，包括特定的组成，样式和行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ButtonHelloElement extends HTMLButtonElement &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      super()</span><br><span class="line">      this.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">        alert(&apos;hello world&apos;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  customElements.define(&apos;button-hello&apos;, ButtonHelloElement, &#123;</span><br><span class="line">    extends: &apos;button&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button id=&quot;button-hello&quot;&gt;hello world&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HTML-Imports"><a href="#HTML-Imports" class="headerlink" title="HTML Imports"></a>HTML Imports</h2><p>HTML Imports 是一种在 HTML 中引⽤以及复⽤其他的HTML ⽂档的⽅式。这个 Import 很漂亮，可以简单理解为我们常⻅的模板中的 include 之类的作⽤。</p>
<p>听说这个标准后来被废弃了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;import&quot; href=“/components/header.html&quot;&gt;</span><br><span class="line">const link = document.querySelector(&apos;link[rel=import]&apos;)</span><br><span class="line">const header = link.import;</span><br><span class="line">const pulse = header.querySelector(‘div.logo&apos;);</span><br><span class="line">//获取 import 的 HTML 的 document</span><br><span class="line">const d = document.currentScript.ownerDocument</span><br></pre></td></tr></table></figure></p>
<h2 id="HTML-Templates"><a href="#HTML-Templates" class="headerlink" title="HTML Templates"></a>HTML Templates</h2><p>用过 handlebars 的⼈都知道有这么⼀个东⻄: <code>&lt;script id=&quot;template&quot; type=&quot;text/x-handlebars-template&quot;&gt;&lt;/script&gt;</code>那么 HTML Templates 便是把这个东⻄官⽅标准化，提供了了⼀个 template 标签来存放以后需要但是暂时不渲染的 HTML 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template id=&quot;template&quot;&gt;&lt;p&gt;Smile!&lt;/p&gt;&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let num = 3;</span><br><span class="line">  const fragment = document.getElementById(&apos;template&apos;).content.cloneNode(true);</span><br><span class="line">  while (num-- &gt; 1) &#123;</span><br><span class="line">    fragment.firstChild.before(fragment.firstChild.cloneNode(true));</span><br><span class="line">    fragment.firstChild.textContent += fragment.lastChild.textContent;</span><br><span class="line">  &#125;</span><br><span class="line">  document.body.appendChild(fragment);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h2><p>Shadow DOM 最本质的需求是需要⼀个隔离组件代码作⽤域的东⻄西，例如我组件代码的 CSS 不能影响其他组件之类的，⽽iframe ⼜太重并且可能有各种奇怪问题。旨在提供⼀种更好地组织⻚⾯元素的⽅式，来为⽇趋复杂的⻚⾯应⽤提供强⼤⽀持，避免代码间的相互影响。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const div = document.getElementById(&apos;id&apos;)</span><br><span class="line">const shadowRoot = div.createShadowRoot()</span><br><span class="line">const span = document.createElement(&apos;span&apos;)</span><br><span class="line">span.textContent = &apos;hello world&apos;</span><br><span class="line">shadowRoot.appendChild(span)</span><br></pre></td></tr></table></figure></p>
<p>x-foo::shadow &gt; span 可以匹配到 #top 元素<br>x-foo /deep/ span 可以匹配到 #not-top 和 #top 元素<br>:host(.foo) 匹配 <code>&lt;x-foo&gt;</code> 元素</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>webComponents</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】webpack4 时代如何更好的配置 dll</title>
    <url>/2019/11/19/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack4-%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%85%8D%E7%BD%AE-dll/</url>
    <content><![CDATA[<p>因为公司的pc 项目有点庞大， 每次打包构建都得1分钟左右， 实在有点无法接受， 于是尝试优化一下 webpack 看看能否提升提升相关的性能<br>也就有了这篇文章的由来，也是想记录一下关于webpack优化的内容</p>
<p>如果你去搜索 webpack 优化一定会搜索到dll相关的配置，同样也会被一串莫名其妙的webpack 搞的一头雾水， 那么我们就来简单理解一下</p>
<h2 id="什么是dll呢"><a href="#什么是dll呢" class="headerlink" title="什么是dll呢"></a>什么是dll呢</h2><p>dll原本是window系统的一种优化手段 利用动态链接，大体上的操作是: 许多应用共享的代码能够切分到一个DLL中，在硬盘上存为一个文档，在内存中只需使用一个实例。 用于节省应用程序的资源和状态， 总的来说是一种用空间换时间的方案</p>
<p>再人话一点就是： 把程序可复用的公共代码抽出来，作为外部依赖引用</p>
<p>那么 Dll 在前端中的作用就是将需要打包的第三方依赖从项目中抽离出来， 单独打包一份 vender 文件，</p>
<p>我们的配置也就是在干这么一件事:</p>
<ul>
<li>第一次打包： 将依赖单独打包抽离， 存储在磁盘中并生成映射关系， 方便后续查找，也就是 manifest.json 文件</li>
<li>第二次打包： 根据 manifest.json 获取之前的依赖打包缓存， 只需要打包业务相关的代码</li>
</ul>
<h2 id="简单介绍应该如何配置-dll"><a href="#简单介绍应该如何配置-dll" class="headerlink" title="简单介绍应该如何配置 dll"></a>简单介绍应该如何配置 dll</h2><p>首先编写一个专门用来打包和更新 dll 的 webpack 配置, 保存到项目根目录中 <code>webpack.dll.config.js</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'../dll'</span>),</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">        library: <span class="string">'[name]_library'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123; </span><br><span class="line">            name: <span class="string">'[name]_library'</span>,</span><br><span class="line">            context: __dirname,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'../dll/[name]-manifest.json'</span>),</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">编写好脚本必然需要有一个方法去触发他， 我们到 package.json 中编写一个 script : </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>json</span><br><span class="line"><span class="string">"script"</span>: &#123;</span><br><span class="line">  <span class="string">"dll"</span>: <span class="string">"webpack --config=webpack.dll.config.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时我们运行<code>npm run dll</code>便可生成一份打包的 dll文件</p>
<p>那如何建立起动态链接呢? </p>
<p>上面的打包操作会产出一份 <code>manifest.json</code> 映射关系文件，它就像一个“地图”绘制着各个被打包到dll的依赖的相关信息， 那我们只要把这份映射关系文件告诉webpck ， 让他按照这个份“地图” 去寻址</p>
<p>所以我们要在正常的打包配置中加入这样一个 plugins, 然后利用 <code>add-asset-html-webpack-plugin</code> 将静态资源的路径插入到html中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    context: path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">    manifest: path.resolve(__dirname, <span class="string">'../dll/react.manifest.json'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> AddAssetHtmlPlugin(&#123;</span><br><span class="line">    filepath: path.resolve(__dirname, <span class="string">'../dll/_dll_react.js'</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="dll-优劣"><a href="#dll-优劣" class="headerlink" title="dll 优劣"></a>dll 优劣</h2><p>dll的缓存机制带来的打包效果是非常显著的， 能大幅减少项目的打包时间， 上面也说了dll 是一种拿空间换时间的一种方式， 可以先将项目所依赖的库提前打包出来， 存储在本地磁盘中， 然后通过mainifest.json 的映射文件， 在下次打包的时候产生链接关系， 这样就可以做到， 你把这份提前打包的dll包放置在 cdn上？ 因为他不会经常性的修改， 只需要在项目的第三方依赖需要修改的时候再去替换他即可， 然后每次打包都可以跳过打包第三方依赖，只处理业务代码， </p>
<p>但其实这样也有一个问题， 那就是整个 spa 应用就会很蠢， 本来是可以利用 code split 来达到按需加载js  文件的功能， 但是这样一整吧， 不管用户访问哪个页面都会把整个作为 dll 的依赖包下载下来， 变相的增加了加载时间，  所以dll也只是推荐在开发环境使用，  生产环境还是使用 commonChunk 的方式提取公共依赖把， 虽然 commonChunk无法为你优化打包时间</p>
<h2 id="webpack4-中我们应该怎么做"><a href="#webpack4-中我们应该怎么做" class="headerlink" title="webpack4 中我们应该怎么做"></a>webpack4 中我们应该怎么做</h2><p>同样的配置我尝试在使用了 webpack4的新项目中试了试， 发现 dll 加速太不明显了， 测试了几次感觉只优化了100毫秒， 因为webpack4  的性能足够好  （ 项目原本打包需要1.8秒上下 ）， 所以这也是 vue-cli 将 dll 这种方式弃用的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dll option will be removed. Webpack 4 should provide good enough perf and the cost of maintaining DLL mode inside Vue CLI is no longer justified.</span><br><span class="line"></span><br><span class="line">dll 配置将会被移除，因为 Webpack 4 的打包性能足够好的，dll 没有在 Vue ClI 里继续维护的必要了。</span><br></pre></td></tr></table></figure>
<p>那我们真的只能跟 dll 分手告别了吗? 不会的，工具只会越发展越完善， 在webpack4的时代，我们可以使用 <code>hard-source-webpack-plugin</code> ，<br>只需要在webpack的plugins 中加入<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>就这仅仅一行即可， 效果拔群</p>
<p>就是他了， 上了这车直接提升了3分之一的速度， 太秀了吧， 硬核</p>
<p>并且听说等到了 webpack5 自身就会集成了</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://segmentfault.com/a/1190000020485804" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020485804</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【模块化】AMD和CMD的区别</title>
    <url>/2019/10/20/%E3%80%90%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%91AMD%E5%92%8CCMD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><ol>
<li>前端模块化框架肩负着模块管理、 资源加载两项重要的功能， 这两项功能与工具、性能、业务、 部署等工程环节都有着非常紧密的联系。 因此， 模块化框架的设计应该最高优先级考虑工程需要。</li>
<li>ConmmonJS API定义很多普通应用程序 （主要指非浏览器的应用 ） 使用的API， 从而填补了这个空白。 它的终极目标就是提供一个类似Python 、Ruby和Java的标准库。</li>
<li>根据这个规范， 每个文件就是一个模块， 有自己的作用域。 在一个文件里面定义的变量、函数、类，都是私有的， 对其他文件不可见。</li>
<li>CMD和AMD都是CommonJS的一种规范的实现定义， RequireJS和SeaJS都是对应的实践。 还有一种兼容cmd和 amd的模式叫umd</li>
</ol>
<p><strong>关于CommonJs为什么不适合浏览器端</strong><br>因为CommonJS的 <code>require</code>是同步加载， 并且是复制模块的方式， 所以让浏览器去同步加载模块显然有点不太合理， 但对后端服务来说却不一样，有充足的时间去加载本地文件 ， 而浏览器端遵守的<code>EcmaScript</code>标准的import 遵循的是 关系引用加载</p>
<h2 id="AMD-CMD"><a href="#AMD-CMD" class="headerlink" title="AMD / CMD"></a>AMD / CMD</h2><ul>
<li>AMD 推崇<strong>依赖前置</strong>， 是 RequireJS 在推广过程中对模块定义的规范化产出。</li>
<li>CMD 推崇<strong>依赖就近</strong>， 是 SeaJS 在推广过程中对模块定义的规范化产出。</li>
</ul>
<p>但是尴尬的是， 在浏览器端实际实现的过程中， 依旧需要提前加载好所有模块， 否则等到用到的时候再去加载不就要阻塞了吗</p>
<p><strong>样例代码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//AMD(Asynchronous Module Definition)</span><br><span class="line">define([&apos;dep1&apos;,&apos;dep2&apos;],function(dep1,dep2)&#123;</span><br><span class="line">  //内部只能使⽤用指定的模块</span><br><span class="line">  return function()&#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">//CMD</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">  //此处如果需要加载某XX模块，可以引⼊入</span><br><span class="line">  var xx=require(‘XX’);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>根据书写习惯的的不一样， cmd和amd 的模块执行顺序也不尽相同， 但是大致模块加载原理是一样的</p>
<p>amd 倒着来的原因是， 如果不先把最内部的依赖先执行完， 后面没法接着执行</p>
<ul>
<li><p>AMD： 3.js，2.js，1.js，，，即如果模块以及该模块的依赖都加载完了，那么就执行。。。 比如 3.js 加载完后，发现自己也没有依赖啊，那么直接执行3.js的回调了，，2.js加载完后探查到依赖的3.js也加载完了，那么2.js就执行自己的回调了。 主模块一定在最后执行</p>
</li>
<li><p>CMD： 1.js，2.js，3.js，，，即先执行主模块1.js，碰到require(‘2.js’)就执行2.js，2.js中碰到require(‘3.js’)就执行3.js</p>
</li>
</ul>
<h2 id="加载顺序及原理"><a href="#加载顺序及原理" class="headerlink" title="加载顺序及原理"></a>加载顺序及原理</h2><p>如果你的结构是这样的: 网页引用了<code>1.js</code> , 然后<code>1.js</code>引用 <code>2.js</code>和<code>4.js</code> , <code>2.js</code> 引用 <code>3.js</code>, 大致结构就是这样:</p>
<ul>
<li>1.js<ul>
<li>2.js<ul>
<li>3.js</li>
</ul>
</li>
<li>4.js</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模块化的原理也就是创建了使用 <code>script</code> 标签， 使用<code>src</code>去载入对应的js文件,  用<code>load</code>或<code>onreadystatechange</code>事件监听请求完成  ,像<code>amd</code>这种依赖前置的模块就比较清晰， 所以只需要按填写的请求即可，  但是因为 <code>cmd</code> 是推崇的依赖就近， 所以它需要使用正则去解析文档， 找出<code>require</code>的依赖， 所以也就造成了被注释了的<code>require</code>语句依旧去请求了</p>
<h3 id="但是它实际的引用顺序呢？"><a href="#但是它实际的引用顺序呢？" class="headerlink" title="但是它实际的引用顺序呢？"></a>但是它实际的引用顺序呢？</h3><p><strong>请求顺序</strong><br><code>require.js</code> 的模块加载顺序是先走的<code>广度优先</code>， 也就是先请求出<code>1.js</code>、 <code>4.js</code> ， 等到<code>2.js</code>和<code>4.js</code>都请求成功了，  然后进入各个文件内部， 进行<code>深度优先</code>， 也就是进入<code>1.js</code> 找到<code>2.js</code> 再找到<code>3.js</code>直至没有任何引用后再返回</p>
<p><strong>看图</strong></p>
<p>3.js 会在 <code>2.js</code> 和 <code>4.js</code> 都被请求完成之后去请求</p>
<p><img src="http://img.nixiaolei.com/2019-11-20-11-56-09.png" alt="2019-11-20-11-56-09"></p>
<p><strong>返回顺序</strong></p>
<p>框架会监测 js 的加载完成事件， 当最内部的执行完成后， 向上返回， 类似于递归的一个执行流程， </p>
<p>有这样一种情况， 当<code>4.js</code> 请求完成后并且内部依赖也完成， 并不会立马返回给<code>1.js</code>, 而是等候其他未完成的依赖， 比如<code>2.js</code>还在处理它内部的依赖， 当<code>4.js</code>和 <code>2.js</code>都完成后， 它会有一个聚合的过程， 统一再返回给 <code>1.js</code></p>
<p><strong>看图</strong><br><img src="http://img.nixiaolei.com/2019-11-20-11-56-44.png" alt="2019-11-20-11-56-44"></p>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】记一次支付功能的开发</title>
    <url>/2019/09/30/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>今天国庆赶车回家 ，陪女朋友赶车（女朋友的票要早两个小时）， 无聊本想着看会剧， 但是车站坑爹啊， 网络太卡了， 想下载个腾讯视频都下载不了， 既然没网看不了剧， 发呆太可惜了， 想着最近很久没补博客了， 趁这个时间补一点好了， 这星期做的这个支付的几个关键点记录一下。</p>
<p>提到支付当然微信和支付宝都得做， 还有公司内部的支付方式， 当然公司内部的支付就不提了， 这个每个公司的情况都不一样， 这里关键记录一下微信和支付宝的</p>
<h2 id="微信中打开支付"><a href="#微信中打开支付" class="headerlink" title="微信中打开支付"></a>微信中打开支付</h2><p>在微信自身中打开我们的支付页面， 此时我们的网页可以被赋能可以获得jsBridge ， 这是微信暴露给webview的方法， 类似于Cordova 之类的 web容器式混合应用, 通过jsBridge 唤起微信原生的支付</p>
<h3 id="获取微信code"><a href="#获取微信code" class="headerlink" title="获取微信code"></a>获取微信code</h3><p>在微信原生中支付，需要获取一串code, 类似于登录操作， 需要把code交给后台， 后台去问微信索要openID , 用来支付</p>
<p>那么如果获取到这串code：<br>我们需要在路径上判断一下query， 如果没有query 那就跳转到获取code的地址， 并携带上当前的地址，因为跳转到该地址后会携带着code 跳转回来，</p>
<p>跳转去获取code：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取路径上携带的code</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    code: <span class="keyword">this</span>.$route.query.code ? <span class="keyword">this</span>.$route.query.code : <span class="string">''</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测微信环境</span></span><br><span class="line"><span class="keyword">if</span> (verify(<span class="string">'wechat'</span>)) &#123;</span><br><span class="line">  <span class="comment">// 如果code 不存在就跳去获取</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.code) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">"https://open.weixin.qq.com/connect/oauth2/authorize?appid="</span> + wechatAppId + <span class="string">"&amp;redirect_uri="</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">window</span>.location.href) + <span class="string">"&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE#wechat_redirect"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时这里还有需要注意的地方，微信获取的code只能使用一次支付， 也就是说， 当用户唤起一次支付以后， 但并没有真的支付， 而是取消支付了， 那他下次就无法再唤起支付， 因为code使用过了， 后台的订单会创建失败， </p>
<p>解决方法就是在获取一次code！</p>
<p>如何再获取一次code呢？ 刷新页面呗</p>
<p>这里我用了比较偷懒的办法， 我们不是判断 <code>this.code</code> 是否存在才去获取code吗， 那我们把旧的code干掉就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getCodeAgain() &#123;</span><br><span class="line">  <span class="keyword">let</span> _url = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="comment">// soot 是废弃的意思，， 随便起的名字， 可以随意换，</span></span><br><span class="line">  _url = _url.replace(<span class="string">'code'</span>, <span class="string">'soot'</span>)</span><br><span class="line">  <span class="built_in">window</span>.location.href = _url</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如此替换之后访问页面时就获取不到code， 自然会再去跳转获取新code , 嘿嘿， 这是比较偷懒的方法， 最好还是去正则匹配一下路径参数， 然后把code相关内容删掉， 避免url过长</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">关键的调用js 支付方法,  有比较坑爹的是， 使用 `</span>res.err_msg<span class="string">` 来判断用户是否支付成功, 微信居然无法保证其可靠性！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">顺便一提， params 参数是后台给的（我们公司的情况）， 这种支付相关的还是交给后台保存吧</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">WeixinJSBridge.invoke(<span class="string">'getBrandWCPayRequest'</span>, params, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.err_msg == <span class="string">"get_brand_wcpay_request:ok"</span>) &#123;</span><br><span class="line">        <span class="comment">// 支付成功</span></span><br><span class="line">        <span class="comment">// 微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。</span></span><br><span class="line">        success &amp;&amp; success(<span class="string">'ok'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.err_msg == <span class="string">"get_brand_wcpay_request:cancel"</span>) &#123;</span><br><span class="line">        <span class="comment">// 支付取消</span></span><br><span class="line">        cancel &amp;&amp; cancel(<span class="string">'cancel'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 支付失败或错误</span></span><br><span class="line">        fail &amp;&amp; fail(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>进行封装后的代码， 个人觉得还是封装的挺烂的， 但姑且可以用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微信支付</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @msg 设置微信js 桥的 支付相关配置</span></span><br><span class="line"><span class="comment"> * @param &#123;type&#125; </span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; success 成功回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; cancel 用户去取消回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; fail 支付失败或错误回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; localError 本地出现错误回调 - 会在 wxPay 方法中被拦截</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; params 支付的相关配置 - 由后台返回</span></span><br><span class="line"><span class="comment"> * @return: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWxBridgeConfig</span>(<span class="params">&#123; success, cancel, fail, ...params &#125;</span>) </span>&#123;</span><br><span class="line">  WeixinJSBridge.invoke(<span class="string">'getBrandWCPayRequest'</span>, params, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.err_msg == <span class="string">"get_brand_wcpay_request:ok"</span>) &#123;</span><br><span class="line">          <span class="comment">// 支付成功</span></span><br><span class="line">          <span class="comment">// 微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。</span></span><br><span class="line">          success &amp;&amp; success(<span class="string">'ok'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.err_msg == <span class="string">"get_brand_wcpay_request:cancel"</span>) &#123;</span><br><span class="line">          <span class="comment">// 支付取消</span></span><br><span class="line">          cancel &amp;&amp; cancel(<span class="string">'cancel'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 支付失败或错误</span></span><br><span class="line">          fail &amp;&amp; fail(<span class="string">'fail'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @msg 尝试调起微信支付</span></span><br><span class="line"><span class="comment"> * @param &#123;type&#125; </span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; success 成功回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; cancel 用户去取消回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; fail 支付失败或错误回调</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; localError 本地出现错误回调 - 会在 wxPay 方法中被拦截</span></span><br><span class="line"><span class="comment"> *   @param &#123; function &#125; params 支付的相关配置 - 由后台返回</span></span><br><span class="line"><span class="comment"> * @return: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">wxPay</span>(<span class="params">&#123; localError, ...params &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> JSBridgeInterval = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 如果 WeixinJSBridge 对象存在则进入配置</span></span><br><span class="line">      <span class="keyword">if</span> (!(<span class="keyword">typeof</span> WeixinJSBridge == <span class="string">"undefined"</span>)) &#123;</span><br><span class="line">          setWxBridgeConfig(params);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 等待sdk 加载完成， 如果sdk未加载完成就调用支付时  WeixinJSBridge 对象 不存在</span></span><br><span class="line">          JSBridgeInterval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!(<span class="keyword">typeof</span> WeixinJSBridge == <span class="string">"undefined"</span>)) &#123;</span><br><span class="line">                  clearInterval(JSBridgeInterval);</span><br><span class="line">                  setWxBridgeConfig(params);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    localError &amp;&amp; localError()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="浏览器中打开微信支付"><a href="#浏览器中打开微信支付" class="headerlink" title="浏览器中打开微信支付"></a>浏览器中打开微信支付</h2><p>浏览器中唤醒微信支付, 这就比较简单了， 当我们创建订单后只需要将网页跳转至后台返回的微信页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// res 指得是后台接口的返回， mweb_url这也是我们公司的字段， 和微信没有关系，只是demo</span></span><br><span class="line"><span class="built_in">window</span>.location.href = res.data.mweb_url</span><br></pre></td></tr></table></figure>
<h2 id="支付宝支付（浏览器中）"><a href="#支付宝支付（浏览器中）" class="headerlink" title="支付宝支付（浏览器中）"></a>支付宝支付（浏览器中）</h2><p>同样的， 支付宝也有jsBridge 这种方式， 但我们没有选择， 因为我们的主要面向是微信用户，  支付宝我们选择一种比较通用的方式就可以， 也就是浏览器中的支付方式</p>
<p>这种方式需要在创建订单后后台返回一个html 字符串， 这是一段form表单， 我们接收到这串字符串以后，使用下面这段打开唤醒支付宝， <code>alipayHtml</code>就是后台返回的表单字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="comment">// alipayHtml 是后台返回的字符串</span></span><br><span class="line">div.innerHTML = alipayHtml;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span><br></pre></td></tr></table></figure>
<p>如此就可以调用支付宝支付了</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构】什么叫中台</title>
    <url>/2019/09/24/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E5%8F%AB%E4%B8%AD%E5%8F%B0/</url>
    <content><![CDATA[<p>今天看到了一对很有趣的漫画， 讲述了什么叫中台的问题， 之前自己一直对中台这个概念很模糊， 找不清楚这个定位。</p>
<p>看完了漫画特地过来记录一下。做下笔记</p>
<h2 id="没有中台的时代"><a href="#没有中台的时代" class="headerlink" title="没有中台的时代"></a>没有中台的时代</h2><p>在没有中台的时代， 不管项目大小， 都可以分为 “前台“和”后台”</p>
<p><strong>什么是前台？</strong></p>
<p>首先，这里所说的“前台”和“前端”并不是一回事。所谓前台即包括各种和用户直接交互的界面，比如web页面，手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。</p>
<p><strong>什么是后台？</strong></p>
<p>后台并不直接面向用户，而是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供了一些简单的配置。</p>
<p>前台、后台、用户之间的关系，可以用下图简单表示：</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-20-55-16.png" alt="2019-09-24-20-55-16"></p>
<p>这样的架构带来的潜在问题就是，每次有新的独立项目了， 都要重新去搭建后台相关的技术支撑，许多项目都在重复造轮子， 项目也就变得越来越臃肿</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-10-42.png" alt="2019-09-24-21-10-42"></p>
<p>为了解决这个问题， 中台就因此诞生了</p>
<h2 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h2><p>最早提出中台这个概念的是一家芬兰的手机游戏公司叫SuperCell。</p>
<p>虽然可能没听过公司名字，但应该听过游戏吧， 大名鼎鼎的部落冲突<br><img src="http://img.nixiaolei.com/2019-09-24-21-13-11.png" alt="2019-09-24-21-13-11"></p>
<p>SuperCell公司就像是一个高产的游戏孵化器，在几年内开发出了10款以上的游戏，但是大部分用于试错的游戏都在研发过程中被腰斩了，最终呈献给用户的几款游戏都是经典中的经典。</p>
<p>是什么让SuperCell公司能够如此高效地试错和迭代呢？他们依靠的是强大的平台资源，支撑起各个游戏开发的小团队。</p>
<p>他们开发出的游戏看上去风格迥异，却存在许多共同之处。在业务上，共通的东西包括支付系统、用户系统等等，在技术上，共同的东西包括游戏引擎，内部开发工具等等。而这些共通的资源，都可以由一个强大的“中台”来提供：</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-17-03.png" alt="2019-09-24-21-17-03"></p>
<p>中台的架构思想改变的不只是项目结构，也影响了研发团队的组织形式。SuperCell公司把这种高效的组织形式称为“部落”。</p>
<p>紧随其后，国内互联网公司也纷纷开始了各自的中台战略。</p>
<p><strong>阿里巴巴提出了“大中台，小前台”的战略：</strong></p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-19-29.png" alt="2019-09-24-21-19-29"></p>
<h2 id="中台的具体划分"><a href="#中台的具体划分" class="headerlink" title="中台的具体划分"></a>中台的具体划分</h2><p>按照不同的角色和功能，中台可以分成4个维度：</p>
<h4 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h4><p>业务中台在前文中反复提及，就是把各个项目的共通业务进行下沉，整合成通用的服务平台：</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-21-17.png" alt="2019-09-24-21-21-17"></p>
<h4 id="技术中台"><a href="#技术中台" class="headerlink" title="技术中台"></a>技术中台</h4><p>技术平台，为了避免研发人员重复发明轮子，向各个项目提供通用的底层框架、引擎、中间件</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-21-55.png" alt="2019-09-24-21-21-55"></p>
<h4 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h4><p>数据中台，为各个项目进行各种数据采集和分析：</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-22-28.png" alt="2019-09-24-21-22-28"></p>
<h4 id="算法中台"><a href="#算法中台" class="headerlink" title="算法中台"></a>算法中台</h4><p>算法中台，为各个项目提供算法能力，比如推荐算法、搜索算法、图像识别、语音识别等等</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-21-23-23.png" alt="2019-09-24-21-23-23"></p>
<h2 id="何时使用中台架构"><a href="#何时使用中台架构" class="headerlink" title="何时使用中台架构"></a>何时使用中台架构</h2><p>适合业务较大的公司， 整合资源需要中台， 需要极速扩张的小公司没有必要考虑中台</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>原文写的很不错， 我这篇属于删减后的搬运工， 方便自己理解！请支持原作者！</p>
<p>原文链接</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rF7_xJBq4NJP6CmkW3HPpQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>中台</category>
      </categories>
      <tags>
        <tag>中台</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】为什么React 的方法需要bind</title>
    <url>/2019/09/24/%E3%80%90React%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88React-%E7%9A%84%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81bind/</url>
    <content><![CDATA[<p>今天下班的时候， 同事问我React 的中的方法为什么需要箭头函数包裹， 或者是bind 绑定一下this指向， 才能被调用， 我当时也是一愣啊， 虽然以前好像也去研究过这个问题， 但好像答案也并不是那么明确。 于是我就把当时我的想法跟他阐述了一下， 当时我是这么说的： </p>
<blockquote>
<p>this 在初始化时是指向的对象实例， 但调用方法的时候不是， 因为jsx不是真正的dom 它会被转化为虚拟dom, 所以事件是通过react代理的， 并且这个涉及到javascript的作用域问题， 正常的变量都会是词法作用域， 也就是在书写阶段就能确定该变量的作用域， 而this 则是一个怪咖，他是一个动态作用域， 它是在执行期间才会确定 this 指向， 俗话说就是谁调用就指向谁。 因此，事件被react 代理了注册了， 如果是正常情况的this 在调用期间自然无法获得原本的class 指向， 至于为什么 this 是undefind ， 这是因为 this 应该是指向到了 window 上， 而执行react 的代码中开启了严格模式所以 this 就变成了undefind</p>
</blockquote>
<p>上面这些， 咋一看好像没什么问题， 但我仔细一想好像又不太对劲， 问题真的是出在 React 代理注册事件的时候吗</p>
<p>让我们来一探究竟：</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-20-14-45.png" alt="2019-09-24-20-14-45"></p>
<p>这是React 官网的一段话， 大致意思是（用的翻译工具🐶）:</p>
<blockquote>
<p>你必须要小心的这JSX回调的this。 在JavaScript中，类方法不是默认绑定的。 如果你忘了绑定this.handleClick并把它传递到的onClick，这将是不确定的，当函数实际被调用的时候。</p>
</blockquote>
<blockquote>
<p>这不是React 的行为; 这是在JavaScript中的函数工作的原理的一部分。 通常，如果指的是方法，无需（）后，如onClick = {this.handleClick}，则应该bind 指向。</p>
</blockquote>
<blockquote>
<p>如果调用bind惹恼了你，可以使用箭头函数</p>
</blockquote>
<p>也就是说问题不是出在了React 身上， 而是出在了javascript 自身的执行机制上。 那让我们回归本质， 看看到底是怎么一回事吧。</p>
<p>让我们来看同样一段代码， 不同情况下的this指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">  fn(key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo.fn(<span class="string">'1'</span>)</span><br><span class="line"><span class="comment">// 这一步就类似我们在jsx中的事件赋值操作</span></span><br><span class="line"><span class="keyword">var</span> dFn = demo.fn</span><br><span class="line">dFn(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrowsFn = <span class="function"><span class="params">()</span> =&gt;</span> demo.fn(<span class="string">'3'</span>)</span><br><span class="line">arrowsFn()</span><br></pre></td></tr></table></figure>
<p><img src="http://img.nixiaolei.com/2019-09-24-20-25-26.png" alt="2019-09-24-20-25-26"></p>
<p>我们可以看到 ，2 的赋值方式导致了this指向的丢失， React 的事件挂载时我们也是如此操作， 这也就说明了是js 本身的问题而非 React 导致的， 尽管React 没有做相应的处理也有责任</p>
<p>让我们继续， 不是说React 中指向的是 undefind 吗， 那我们打开严格模式看看是不是如此: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> demo = &#123;</span><br><span class="line">  fn(key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo.fn(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">var</span> dFn = demo.fn</span><br><span class="line">dFn(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrowsFn = <span class="function"><span class="params">()</span> =&gt;</span> demo.fn(<span class="string">'3'</span>)</span><br><span class="line">arrowsFn()</span><br></pre></td></tr></table></figure>
<p>果然如此， this 指向变为了undefind</p>
<p><img src="http://img.nixiaolei.com/2019-09-24-20-30-04.png" alt="2019-09-24-20-30-04"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构】利用systemJs构建微前端</title>
    <url>/2019/09/17/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E5%88%A9%E7%94%A8systemJs%E6%9E%84%E5%BB%BA%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<p>微前端，其实就是微服务在前端的一种实践</p>
<h2 id="微前端的特性"><a href="#微前端的特性" class="headerlink" title="微前端的特性"></a>微前端的特性</h2><blockquote>
<p>取代 iframe</p>
</blockquote>
<ol>
<li>各个开发团队都可以自行选择技术栈， 不受同一项目中其他团队影响;</li>
<li>各个交付产物都可以被独立使用， 避免和其它交付产物耦合;</li>
<li>各个交付产物中的样式不会污染到其他组件;</li>
<li>各个交付产物都可以自由使用浏览器原生API， 而非要求使用封装后的API;</li>
</ol>
<h2 id="目前实现微前端的多种手段"><a href="#目前实现微前端的多种手段" class="headerlink" title="目前实现微前端的多种手段"></a>目前实现微前端的多种手段</h2><p>现阶段实现微前端的方式大致有以下六种：</p>
<ol>
<li>使用 HTTP 服务器的路由来重定向多个应用</li>
<li>在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA</li>
<li>通过组合多个独立应用、组件来构建一个单体应用</li>
<li>iFrame。使用 iFrame 及自定义消息传递机制</li>
<li>使用纯 Web Components 构建应用</li>
<li>结合 Web Components 构建</li>
</ol>
<h2 id="为什么不用-iframe"><a href="#为什么不用-iframe" class="headerlink" title="为什么不用 iframe"></a>为什么不用 iframe</h2><p>[ 不可控制 ] — iframe 嵌入的显示区大小不容易控制， 存在一定局限性<br>[ bfcache ] — URL的记录完全无效， 页面刷新不能够记忆， 刷新会返回首页， iframe 功能之间跳转也无效<br>[ 兼容性坑 ] — iframe 的样式显示， 兼容性等都具有局限性<br>[ 性能开销 ] — iframe 阻塞onload， 占用连接池， 多层嵌套页面崩溃</p>
<h2 id="整体实现思路"><a href="#整体实现思路" class="headerlink" title="整体实现思路"></a>整体实现思路</h2><p>利用systemJs 的模块加载能力，略微调整webpack 产出相关配置， 将各个项目按照 systemJs 的模块规则导出， 利用脚本将所有应用整合到项目总线上， 利用cdn的形式引入各个框架的运行内核，有效提高缓存能力。使用订阅/发布的方式提供项目的总线订阅能力， 用以各个不同项目之间的通信。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>这里推荐大家自己去搭建webpack 开发环境，<code>vue-cli</code>、 <code>create-react-app</code>虽好， 但很多时候并不能完全满足我们的需求。 而且你不明白它是怎么搭建起来的， 当有需要修改的时候就会束手无措。</p>
<p>当然本文的重点是微前端， 我重点贴出需要关键的配置代码</p>
<p>将 webpack 的 entry 改为你的组件, 然后加入 <code>webpack-system-register</code> 插件， 这个插件可以将webpack产出的代码变为 systemJs 所支持的模块格式.</p>
<blockquote>
<p>在使用 <code>webpack-system-register</code>插件时请关闭<code>html-webpack-plugin</code>， 否则会报错</p>
</blockquote>
<h2 id="构建一个观察者"><a href="#构建一个观察者" class="headerlink" title="构建一个观察者"></a>构建一个观察者</h2><blockquote>
<p>懒得上babel 转了， 所以直接写的es5的代码</p>
</blockquote>
<p>大家可以网上早开源的库，我这里选择构建这样的一个 订阅/发布者模式， 就叫eventBus好了， 用于框架之间的通信， 这需要团队之间遵守规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">fn, global</span>) </span>&#123;</span><br><span class="line">  global.EventBus = fn()</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">EventBus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observer = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听事件</span></span><br><span class="line">  EventBus.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 判断该系列事件之前是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!_this.observer[eventName]) &#123;</span><br><span class="line">      _this.observer[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加到该事件名称的队列中</span></span><br><span class="line">    _this.observer[eventName].push(callback);</span><br><span class="line">    <span class="comment">// 返回注销该事件的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 新的事件队列</span></span><br><span class="line">      <span class="keyword">var</span> newEventQueue = [];</span><br><span class="line">      <span class="comment">// 旧的事件队列</span></span><br><span class="line">      <span class="keyword">var</span> oldEventQueue = _this.observer[eventName];</span><br><span class="line">      <span class="comment">// 遍历事件队列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldEventQueue.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前回调事件</span></span><br><span class="line">        <span class="keyword">const</span> itemCallback = oldEventQueue[i];</span><br><span class="line">        <span class="comment">// 判断当前回调和订阅时的是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (callback !== itemCallback) &#123;</span><br><span class="line">          <span class="comment">// 不同则加入新的事件队列</span></span><br><span class="line">          newEventQueue.push(itemCallback);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖之前的事件队列</span></span><br><span class="line">      _this.observer[eventName] = newEventQueue;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发某一事件</span></span><br><span class="line">  EventBus.prototype.dispatch = <span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> eventQueue = <span class="keyword">this</span>.observer[eventName];</span><br><span class="line">    <span class="comment">// 确保该事件队列存在</span></span><br><span class="line">    <span class="keyword">if</span> (!eventQueue) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 挨个调用订阅的回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; eventQueue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> itemCallback = eventQueue[i];</span><br><span class="line">      <span class="comment">// 调用回调，传入参数， 进行this 的软绑定</span></span><br><span class="line">      itemCallback.apply(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> EventBus</span><br><span class="line">&#125;, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h2 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h2><p>分别用react 和 vue 实现一个点击按钮数字增加的小功能， 然后用上我们上面写的eventBus 这样的一个观察者，来进行订阅和发布， 打到框架和框架之间，项目和项目之间共享状态</p>
<h3 id="React-关键代码"><a href="#React-关键代码" class="headerlink" title="React 关键代码"></a>React 关键代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/APP.jsx'</span>,</span><br><span class="line">  <span class="comment">// ....... 省略其他代码</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> WebpackSystemRegister(&#123;&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vue-项目关键代码"><a href="#Vue-项目关键代码" class="headerlink" title="Vue 项目关键代码"></a>Vue 项目关键代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/App.vue'</span>,</span><br><span class="line">  <span class="comment">// ....... 省略其他代码</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> WebpackSystemRegister(&#123;&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建vue项目逻辑"><a href="#构建vue项目逻辑" class="headerlink" title="构建vue项目逻辑"></a>构建vue项目逻辑</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"vue-wrap"</span>&gt;</span><br><span class="line">    vue 组件</span><br><span class="line">    &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"vue-wrap-status"</span>&gt;vue组件内状态： &#123;&#123;vueCount&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button @click="addVue"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;hr /</span>&gt;</span><br><span class="line">    &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"vue-react-status"</span>&gt; react组件内状态： &#123;&#123;reactCount&#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="vue-react-trigger"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button @click="addReact"&gt;通信react &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      vueCount: 0,</span></span><br><span class="line"><span class="regexp">      reactCount: 0</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    window.eventBus.subscribe('addVueCount', (count) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.vueCount++</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    addVue() &#123;</span></span><br><span class="line"><span class="regexp">      this.vueCount++ </span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    addReact() &#123;</span></span><br><span class="line"><span class="regexp">      this.reactCount++ </span></span><br><span class="line"><span class="regexp">      window.eventBus.dispatch('addReactCount', this.reactCount)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style lang=<span class="string">"scss"</span>&gt;</span><br><span class="line">.vue&#123;</span><br><span class="line">  &amp;-wrap &#123;</span><br><span class="line">    border: <span class="number">3</span>px solid green;</span><br><span class="line">    color: green;</span><br><span class="line">    font-size: <span class="number">22</span>px;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;-react &#123;</span><br><span class="line">    &amp;-trigger &#123;</span><br><span class="line">      padding-bottom: <span class="number">20</span>px;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时的界面<br><img src="http://img.nixiaolei.com/2019-09-17-22-40-23.png" alt="2019-09-17-22-40-23"></p>
<h3 id="构建react项目逻辑"><a href="#构建react项目逻辑" class="headerlink" title="构建react项目逻辑"></a>构建react项目逻辑</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 订阅事件</span></span><br><span class="line">    <span class="built_in">window</span>.eventBus.subscribe(<span class="string">'addReactCount'</span>, (count) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        reactCount: count</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      reactCount: <span class="number">0</span>,</span><br><span class="line">      vueCount: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addReactHandle() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; reactCount &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      reactCount: reactCount + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addVueHandle() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; vueCount &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">const</span> newCount = vueCount + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 派发事件</span></span><br><span class="line">    <span class="built_in">window</span>.eventBus.dispatch(<span class="string">'addVueCount'</span>, newCount)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      vueCount: newCount</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"react-wrap"</span>&gt;</span><br><span class="line">        &lt;p&gt;React 组件&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;当前React 状态: &#123; this.state.reactCount &#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button onClick=&#123; () =&gt; <span class="keyword">this</span>.addReactHandle() &#125;&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr/</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;当前Vue状态: &#123; <span class="keyword">this</span>.state.vueCount &#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123; () =&gt; this.addVueHandle() &#125;&gt;通信vue&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时的界面</p>
<p><img src="http://img.nixiaolei.com/2019-09-17-22-37-15.png" alt="2019-09-17-22-37-15"></p>
<h2 id="整合至总线"><a href="#整合至总线" class="headerlink" title="整合至总线"></a>整合至总线</h2><p>首先我们想让总线项目同时具有 vue, react 的开发环境， 我们首先需要将其依赖导入。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/vue/2.6.10/vue.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// react</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/react/16.9.0-rc.0/umd/react.production.min.js"</span> crossorigin&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/react-dom/16.9.0-rc.0/umd/react-dom.production.min.js"</span> crossorigin&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>对了， 不能漏了最关键的systemJS<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/systemjs/3.1.6/system.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后将我们之前写好的eventBus 引入<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"./scripts/eventBus/eventBus.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>并将其绑定到 window<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.eventBus = <span class="keyword">new</span> EventBus()</span><br></pre></td></tr></table></figure></p>
<p>然后我们将vue 项目和 react项目分别打包出来， 放入总线项目中：<br>这里的index.js 就是项目打包产出的文件，<br>需要注意的是,jsx想要在浏览器中运行， 我们还需要引入babel,<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.staticfile.org/babel-standalone/7.0.0-beta.3/babel.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>并且script标签上要加上<code>type=&quot;text/babel&quot; data-type=&quot;react-app&quot;</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"vue"</span>&gt;</span><br><span class="line">    &lt;index&gt;<span class="xml"><span class="tag">&lt;/<span class="name">index</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div id="react"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: "#vue",</span></span><br><span class="line"><span class="regexp">  components: &#123;</span></span><br><span class="line"><span class="regexp">    "index": () =&gt; System.import("./</span>scripts/vue/index.js<span class="string">")</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script type="</span>text/babel<span class="string">" data-type="</span>react-app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  System.import("</span>./scripts/react/index.js<span class="string">").then(_ =&gt; &#123;</span></span><br><span class="line"><span class="string">    const domContainer = document.querySelector('#react');</span></span><br><span class="line"><span class="string">    const e = React.createElement;</span></span><br><span class="line"><span class="string">    const App = _.default;</span></span><br><span class="line"><span class="string">    ReactDOM.render(&lt;App /&gt;, domContainer);</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们打开看一下此时的效果。<br>不但保留了 vue , react 两个项目的各自逻辑功能， 而且还成功进行了组件之间的通信， 如图中， 点击的通信按钮会影另一个组件的内部状态。<br><img src="http://img.nixiaolei.com/microferesult.gif" alt="微前端实现结果"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>一个基本的微前端架构成功实现了， 接下来我们需要做的更多的事情， 就是：</p>
<ol>
<li>解决整合的难度及成本， 可以编写shell脚本或者是构建一个额外的打包配置</li>
<li>无法直观调试开发， 需要合并后， 才能看到， 无法热更新</li>
</ol>
<h2 id="项目代码地址"><a href="#项目代码地址" class="headerlink" title="项目代码地址"></a>项目代码地址</h2><blockquote>
<p><a href="https://github.com/nxl3477/note/tree/master/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">https://github.com/nxl3477/note/tree/master/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84</a></p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://juejin.im/post/5d7f702ce51d4561f777e258?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5d7f702ce51d4561f777e258?utm_source=gold_browser_extension</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】webpack5不完全尝鲜</title>
    <url>/2019/09/15/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack5%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%B0%9D%E9%B2%9C/</url>
    <content><![CDATA[<h2 id="如何安装webpack-5"><a href="#如何安装webpack-5" class="headerlink" title="如何安装webpack 5"></a>如何安装webpack 5</h2><blockquote>
<p>npm install webpack@next -D</p>
</blockquote>
<h2 id="📦打包一下"><a href="#📦打包一下" class="headerlink" title="📦打包一下"></a>📦打包一下</h2><p>我们还是去尝试打包这样一段代码<br><img src="http://img.nixiaolei.com/2019-09-15-17-44-55.png" alt="2019-09-15-17-44-55"></p>
<p>最终生成<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function">(<span class="params">modules, runtime</span>) =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="string">"use strict"</span>;</span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> 			i: moduleId,</span><br><span class="line"><span class="comment">/******/</span> 			l: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 			exports: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> 		modules[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// the startup function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">startup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> __webpack_require__(<span class="string">"./src/index.js"</span>);</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// run startup</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> startup();</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./src/index.js"</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/*! exports [maybe provided (runtime-defined)] [no usage info] */</span></span><br><span class="line"><span class="comment">/*! runtime requirements:  */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log(\"你好，webpack\")\n\n//# sourceURL=webpack:///./src/index.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>是不是比webpack4 少了好多</p>
<blockquote>
<p>webpack4 具体情况可以参考 站内文章 <code>【工程化】webpack-编译后文件解析</code></p>
</blockquote>
<p>少去了一大坨的恶心代码！</p>
<p>这是因为：</p>
<blockquote>
<p>webpack5放弃了对兼容做处理的相关代码， 转而交给用户去做， 以此将其代码量减少为之前的三分之一不到</p>
</blockquote>
<h2 id="固定的id"><a href="#固定的id" class="headerlink" title="固定的id"></a>固定的id</h2><blockquote>
<p>天下苦moduleIds 和 chunkIds 已久</p>
</blockquote>
<p>在webpack4 的时候， 我们的异步 chunkId 和moduleId 一直是一个大问题， 为什么这么说呢， </p>
<p>在此之前的各种 id 如下: </p>
<p><img src="http://img.nixiaolei.com/2019-09-15-22-12-09.png" alt="2019-09-15-22-12-09"></p>
<p>natural , size 一般会用在我们的动态引入的异步组件上， natural 是自然数， size 是尺寸大小， 一般动态文件都会变成这样: <code>0.js</code>, <code>1.js</code>,  看似很完美的东西, 实际上， 会带来一些问题</p>
<ol>
<li>不管是 natural 还是 size , 当一个组件模块被改变时就会影响到其他的模块的id,  比如: 一开始有a.js , b.js, c.js 对应 0.js , 1.js ,2.js  ,但是后来我们不需要a.js 了， 那现在就变成了: b.js , c.js 对应 0.js , 1.js。</li>
<li>1⃣️所说的id 所带来的改变， 随之而来的影响就是造成网站缓存的报废， 也就是说之前用户辛苦加载的缓存没有用了， 并且是全部报废， 一个文件的改动影响到全部， 整个代价太大了。 </li>
<li>更有，甚至可能会造成文件的引用错误， 因为之前0.js 对应的是 a.js , 1.js 对应的 b.js , 现在变了 0.js 对应了 b.js, 1.js 对应了 c.js, 浏览器直接走缓存 获取到这份js 文件， 就是引错文件了， 那项目不久炸了</li>
</ol>
<p>在webpack4 时期的曲线救国方案：</p>
<blockquote>
<p>使用魔法注释来告诉webpack 这个异步组件应该叫什么名字</p>
</blockquote>
<p>这确实是一个解决办法， 但是很麻烦， 大点的项目动则上百个组件， 一个一个维护成本实在有点大， 而且后期的修改都得注意， 所以， 虽然有用， 但是不好用</p>
<h3 id="webpack5-的福音"><a href="#webpack5-的福音" class="headerlink" title="webpack5 的福音"></a>webpack5 的福音</h3><blockquote>
<p>该方法的原理是通过分析文件， 来产生的简版md5</p>
</blockquote>
<p>webpack5 带来了一个新的chunkId 的实现方式 <code>deterministic</code> , </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    chunkIds: <span class="string">"deterministic”,</span></span><br><span class="line"><span class="string">    moduleIds: "</span>deterministic<span class="string">"   </span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>只需要这样， 就可以生成针对该文件的唯一chunkId, 太棒啦</p>
<p><img src="http://img.nixiaolei.com/2019-09-15-22-35-45.png" alt="2019-09-15-22-35-45"></p>
<h2 id="更好的缓存"><a href="#更好的缓存" class="headerlink" title="更好的缓存"></a>更好的缓存</h2><p>如下当使用持久缓存时，不再需要cache-loader。 对于 babel cacheDirectory 等也是如此。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    cache: &#123;</span><br><span class="line">        type: <span class="string">"filesystem"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考文献:</p>
<blockquote>
<p><a href="https://juejin.im/post/5c8761925188251a0844d3a4" target="_blank" rel="noopener">https://juejin.im/post/5c8761925188251a0844d3a4</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】webpack 编译后文件解析</title>
    <url>/2019/09/15/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack-%E7%BC%96%E8%AF%91%E5%90%8E%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>webpack 为什么这么神奇？ 为什么能把 es6的模块化，node js 的模块化变成能让浏览器支持的代码？？</p>
<p>让我们看看一个最简单的<code>bundle</code>文件， 一探究竟</p>
<h2 id="如何实现模块化"><a href="#如何实现模块化" class="headerlink" title="如何实现模块化"></a>如何实现模块化</h2><blockquote>
<p>webpack 打包后需要把所有模块的代码同步过来， 所以遵守的是commonJs 规范， </p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-09-15-14-21-44.png" alt="2019-09-15-14-21-44"></p>
<p>这是一个简简单单的代码，编译后的一个文件， 实际代码如下<br><img src="http://img.nixiaolei.com/2019-09-15-14-23-33.png" alt="2019-09-15-14-23-33"></p>
<p>这也证明了 webpack 不管你干了啥都会往你的代码里赛进这么一坨东西。</p>
<p>好的， 现在让我们把代码折叠起来然后删除没用的注释， 先不管细节，看看他的整体脉络<br><img src="http://img.nixiaolei.com/2019-09-15-14-39-09.png" alt="2019-09-15-14-39-09"></p>
<p>我们可以看到， 这就是我们最最熟悉的IIFE，  原来神秘的webapck 无非也就是做了一件事， 将现在的模块化转变成为上古时代的模块化。</p>
<p>并且一个个模块， 都已以其文件路径作为key , 具体的业务逻辑作为value ,  这里我们就可以清晰的看到， 一个<code>src/index.js</code> 的文件路径后面跟着的一个函数 ， 里面就大大的写着 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log(\"你好，webpack\")\n\n//# sourceURL=webpack:///./src/index.js?"</span>);</span><br></pre></td></tr></table></figure>
<p>这里顺带一嘴， 这里生成的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(\<span class="string">"你好，webpack\")\n</span></span><br></pre></td></tr></table></figure></p>
<p>这样字符串就是我们当初玩弄 AST 时，看到的 <code>raw</code>, 也就是带转译的元数据， 当然， 这里如果不实用整个就无法运行了，对吧</p>
<h4 id="为什么是eval"><a href="#为什么是eval" class="headerlink" title="为什么是eval"></a>为什么是eval</h4><p>webpack 在 development 模式下产出的就是 <code>eavl</code> ， 如果是 production 生产环境模式， 是绝对不会有这样的形式代码</p>
<p>生产环境下的产出:<br><img src="http://img.nixiaolei.com/2019-09-15-14-59-15.png" alt="2019-09-15-14-59-15"></p>
<p>那 webapck 为什么会这样选择呢?</p>
<ol>
<li>生成<code>eavl</code> 方便开发环境下的热更新</li>
<li>生产环境不使用 <code>eval</code> 是因为 eval的性能不高，并且不安全， 容易被人XSS</li>
</ol>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】如何编写一个自己的webpack插件</title>
    <url>/2019/09/14/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="webpack-实现插件的机制"><a href="#webpack-实现插件的机制" class="headerlink" title="webpack 实现插件的机制"></a>webpack 实现插件的机制</h2><p>[ 创建 ] – webpack在其内部对象上创建各种钩子<br>[ 注册 ] – 插件将自己的方法注册到对应钩子上， 交给webpack<br>[ 调用 ] – webpack 编译过程中， 会适时地触发相应钩子， 因此也就触发了插件的方法 </p>
<h2 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h2><p>不知道这么起步， 那咱就先去复制一个， 官网提供了一个最最最简易的demo</p>
<blockquote>
<p><a href="https://webpack.js.org/concepts/plugins/" target="_blank" rel="noopener">https://webpack.js.org/concepts/plugins/</a></p>
</blockquote>
<p>复制下来是这样的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每个插件必备的方法</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// compiler 是整个webpack编译的核心</span></span><br><span class="line">    <span class="comment">// tap 可以理解为触发订阅</span></span><br><span class="line">    compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'🍎The webpack build process is starting!!!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsoleLogOnBuildWebpackPlugin;</span><br></pre></td></tr></table></figure></p>
<p>把这个插件引入webpack , 虽然是成功跑起来了啊， 但是一脸蒙蔽， 完全不知道在干嘛也不行啊</p>
<p>首先每个插件都必须要有一个<code>apply</code> 方法， 它会接收一个<code>compiler</code> ， 这个<code>compiler</code> 是所有webpack的核心， 所以webpack 编译相关的内容自然也就在它上面了</p>
<p>接着，我们看到了 complier 上有一个hooks , 后面还有一大串， 那这个<code>hooks</code>是哪里来的呢， 怎么回事呢？</p>
<p>让我们去源码里一探究竟：</p>
<p><img src="http://img.nixiaolei.com/2019-09-14-23-39-17.png" alt="2019-09-14-23-39-17"></p>
<p>哦～ 原来所有 hooks 相关的方法都在这里了， 并且我们发现 compiler 是继承自 <code>Tapable</code></p>
<p>不光如此， 连接受的参数中的 <code>compilation</code> 也继承自 Tapable, compilation 代表了当次编译的chunk</p>
<p><img src="http://img.nixiaolei.com/2019-09-15-00-16-21.png" alt="2019-09-15-00-16-21"></p>
<p>那啥是 Tapable 啊？</p>
<h2 id="认识-Tapable"><a href="#认识-Tapable" class="headerlink" title="认识 Tapable"></a>认识 Tapable</h2><p>Tapble 是 webpack 的灵魂插件， 它是一个用于做消息通知的包.</p>
<p>多说无用， 让我们来单独玩一下 tapable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">//同步串行的钩子， 不用关心函数的返回值</span></span><br><span class="line">  SyncHook,</span><br><span class="line">  <span class="comment">// 同步串行的钩子 ， 上一个返回值不为null 跳过剩下的逻辑</span></span><br><span class="line">  SyncBailHook,</span><br><span class="line">  <span class="comment">// 同步串行， 上一个值可以传递给下一个值</span></span><br><span class="line">  SyncWaterfallHook,</span><br><span class="line">  SyncLoopHook,</span><br><span class="line">  AsyncParallelHook,</span><br><span class="line">  AsyncParallelBailHook,</span><br><span class="line">  AsyncSeriesHook,</span><br><span class="line">  AsyncSeriesBailHook,</span><br><span class="line">  AsyncSeriesWaterfallHook </span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> SyncHook([<span class="string">"name"</span>, <span class="string">"name2"</span>])</span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">queue.tap(<span class="string">"1"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, name2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1⃣️"</span>, name, name2)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">queue.tap(<span class="string">"2"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, name2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"2⃣️"</span>, name, name2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">queue.tap(<span class="string">"3"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, name2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"3⃣️"</span>, name, name2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发整个钩子</span></span><br><span class="line">queue.call(<span class="string">'webpack'</span>, <span class="string">"webpack-cli"</span>)</span><br></pre></td></tr></table></figure>
<p>此时的输出<br><img src="http://img.nixiaolei.com/2019-09-15-00-31-59.png" alt="2019-09-15-00-31-59"></p>
<p>可以看的出 ， 当queue 的call 方法被调用时， 之前挂载的 tap 方法都被触发了， 这其实就是前端里几乎无处不在的观察者模式</p>
<h2 id="附上一个之前写的webpack-插件"><a href="#附上一个之前写的webpack-插件" class="headerlink" title="附上一个之前写的webpack 插件"></a>附上一个之前写的webpack 插件</h2><p>这是之前用来处理swig模版编译的plugin<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 何时才能拦截最后生成的swig</span></span><br><span class="line"><span class="comment">// 2. 如何分清这个swig文件对应的Js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlAfterWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// compiler 是webpack的实例</span></span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">      <span class="comment">//  此处是实例运行期间， 可以吧 tap 当成是 on</span></span><br><span class="line">      <span class="comment">// 实例上有钩子， 将插件注册到webpack实例钩子上 （run初始运行阶段, compilation: 完成阶段）</span></span><br><span class="line">        compiler.hooks.compilation.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"🍉webpack 构建过程开始！"</span>);</span><br><span class="line">          <span class="comment">// 因为webpack的版本更新不友好， 所以新的插件挂载方式需要自己从源码中查找</span></span><br><span class="line">          <span class="comment">// 此阶段是 html-webpack-plugin 提供的，  所以必须在 html-webpack-plugin 之后执行</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 此处是将回调挂载到 webpack 执行过程中的某个阶段， 也就是生命周期</span></span><br><span class="line">          <span class="comment">// Plugin的顺序是 从上至下挂钩子， 但执行顺序不一定 </span></span><br><span class="line">          compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(pluginName, htmlPluginData =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> _html = htmlPluginData.html</span><br><span class="line">            <span class="keyword">const</span> jsResult = assetsHelp(htmlPluginData.assets) </span><br><span class="line">            <span class="comment">// 路径别名</span></span><br><span class="line">            _html = _html.replace(<span class="regexp">/views:/g</span>, <span class="string">"../../"</span>)</span><br><span class="line">            _html = _html.replace(<span class="regexp">/components:/g</span>, <span class="string">"../../../components/"</span>)</span><br><span class="line">            <span class="comment">// 指定位置插入js css</span></span><br><span class="line">            _html = _html.replace(<span class="regexp">/&lt;!--injectjs--&gt;/g</span>, jsResult.js.join(<span class="string">""</span>))</span><br><span class="line">            _html = _html.replace(<span class="regexp">/&lt;!--injectcss--&gt;/g</span>, jsResult.css.join(<span class="string">""</span>))</span><br><span class="line">            <span class="comment">// _html = _html.replace("&lt;!--injectjs--&gt;", jsResult.js.join(""))</span></span><br><span class="line">            htmlPluginData.html = _html</span><br><span class="line">            <span class="comment">// htmlPluginData.html = _html</span></span><br><span class="line">            </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【工程化】babel简单原理及简单实现</title>
    <url>/2019/09/14/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91babel%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>我们知道babel 的原理是通过转换为Ast的方式， 进行一系列的处理， 然后最终得到了我们看到的代码。</p>
<p>这就是它强大之处。</p>
<p>如果让你来实现一个babel 这样的转换代码工具， 你会如何去做呢？</p>
<p>是不是首先会想到使用正则呢， 但实际上， 正则无法很好的满足需求， 这是因为： </p>
<ol>
<li>需要针对各个类库编写相关正则</li>
<li>当类库内部实现改变则正则也要改变</li>
<li>正则的匹配需要区分注释情况， 有写代码被注释掉如果也被正则匹配了那就会影响实现， 比如<code>requireJs</code>就是使用正则匹配的， 导致注释掉相关方法还是调用了</li>
</ol>
<p>综上所诉， 最终我们的解决方案应该是 AST!</p>
<p>如何实现一个简单的babel 呢： </p>
<p>我们需要有将代码转换为 AST 的工具， 处理AST 的工具， AST 转回代码的工具！</p>
<p>让我们来做一个 es6 变量转为es5变量的小工具， 让我们开始动手吧</p>
<p>让我们先 从字符串转为AST：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>)</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>)</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">` const view = &#123;</span></span><br><span class="line"><span class="string">    a: 3,</span></span><br><span class="line"><span class="string">    init: () =&gt; &#123;</span></span><br><span class="line"><span class="string">      view.a = 5</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    render: () =&gt; &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> ast = esprima.parse(code)</span><br></pre></td></tr></table></figure>
<p>让我们看看上面构建的这段代码字符串会被转换为什么</p>
<p><img src="http://img.nixiaolei.com/2019-09-14-22-50-42.png" alt="2019-09-14-22-50-42"></p>
<p>看到了结果， 我们也看到了我们需要的关键字<code>const</code> ， 是不是我们只要把它改为var 就可以了呢， 哈哈， 动手试试吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">'esprima'</span>)</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">'estraverse'</span>)</span><br><span class="line"><span class="keyword">const</span> escodegen = <span class="built_in">require</span>(<span class="string">'escodegen'</span>)</span><br><span class="line"><span class="comment">// mock 一段代码</span></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">` const view = &#123;</span></span><br><span class="line"><span class="string">  a: 3,</span></span><br><span class="line"><span class="string">  init: () =&gt; &#123;</span></span><br><span class="line"><span class="string">    view.a = 5</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  render: () =&gt; &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="comment">// 将代码转为 ast</span></span><br><span class="line"><span class="keyword">const</span> ast = esprima.parse(code)</span><br><span class="line"><span class="built_in">console</span>.log(ast)</span><br><span class="line"><span class="comment">// 遍历ast 修改相关操作</span></span><br><span class="line">estraverse.traverse(ast, &#123;</span><br><span class="line">  enter(node) &#123;</span><br><span class="line">    <span class="keyword">if</span>( node.type === <span class="string">"VariableDeclaration"</span> ) &#123;</span><br><span class="line">      node.kind = <span class="string">'var'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 得到经过ast处理的 js 代码 </span></span><br><span class="line"><span class="keyword">const</span> reg_code = escodegen.generate(ast)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--------- 输出结果 ---------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(reg_code, <span class="literal">null</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>此时的输出:</p>
<p><img src="http://img.nixiaolei.com/2019-09-14-23-00-49.png" alt="2019-09-14-23-00-49"></p>
<p>可以看到最下面的字符串， const 被成功替换为了 var ， 完美！</p>
<p>一个最小最简陋的babel 就这么实现了！</p>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>工程化</tag>
        <tag>Ast</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】小程序中如何引入iconfont 字体图标</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5iconfont-%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/</url>
    <content><![CDATA[<p>icon引入小程序需要将字体文件转换成base64格式，所以</p>
<ol>
<li>先解压压缩包 找到ttf格式文件</li>
<li>上传到平台转化为base64格式 </li>
<li>下载压缩包 </li>
<li>将css文件名改为wxss </li>
<li>放入项目样式文件夹</li>
</ol>
<hr>
<p>字体文件转换成base64格式的链接  <a href="https://transfonter.org/" target="_blank" rel="noopener">https://transfonter.org/</a></p>
<p>参考文档</p>
<blockquote>
<p><a href="https://www.cnblogs.com/minimo/p/8795774.html" target="_blank" rel="noopener">https://www.cnblogs.com/minimo/p/8795774.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】vue-cli3  jest单元测试报错（不支持ES6)</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91vue-cli3-jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8A%A5%E9%94%99%EF%BC%88%E4%B8%8D%E6%94%AF%E6%8C%81ES6/</url>
    <content><![CDATA[<p>在使用公司项目想尝试单元测试的时候， 公司使用的是<code>jest</code>, 发现提示了ES6相关的语法错误提示， 网上百度好多， 各种尝试依旧未能解决</p>
<p>最后的解决办法: </p>
<p>用vue-cli3 重新创建了一个带单元测试的项目， 然后发现运行成功， 于是把该项目的单元测试相关依赖版本拷贝到公司项目里， 于是公司项目成功运行 ， ✌️</p>
<p>最后发现只需要把 <code>babel-jest</code>版本降一下就可以了，<br><img src="http://img.nixiaolei.com/2019-09-11-11-08-34.png" alt="2019-09-11-11-08-34"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;babel-jest&quot;: &quot;^23.6.0&quot;,</span><br></pre></td></tr></table></figure>
<p>如果不生效记得把 package.lock文件删了</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】ios无法播放部分mp4视频怎么办</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91ios%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E9%83%A8%E5%88%86mp4%E8%A7%86%E9%A2%91%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>今天遇到了， 安卓可以播放某个mp4视频，但是ios就是无法播放</p>
<p>抓耳挠腮半天， 才得知， 原来是视频的压缩级别的问题，ios对 mp4的压缩级别支持有限， </p>
<p>最后我转成<code>MPEG-4</code>编码格式， 完美运行（当然其他的编码格式也行， 我只是随便使用了下）</p>
<p>mac可以使用<code>handBreak</code>转一下</p>
<p>参考文档</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/31f0593496ef" target="_blank" rel="noopener">https://www.jianshu.com/p/31f0593496ef</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】a 标签下载视频却跳去播放的问题</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91a-%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91%E5%8D%B4%E8%B7%B3%E5%8E%BB%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>明明写了  a 标签， 也加了 download属性， 但是还是跳去播放视频了， 原来，如果想下载视频， 你得在 a 标签的视频链接地址后面带个参数<code>?filename=xxx</code></p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.aaa.com/video?filename=xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】mac 下 ssh 连接gitHub死活不成功的问题</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91mac-%E4%B8%8B-ssh-%E8%BF%9E%E6%8E%A5gitHub%E6%AD%BB%E6%B4%BB%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通</p>
<p>git clone  一直提示这样的错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cloning into &apos;xxx&apos;...</span><br><span class="line">zsh:1: command not found: connect</span><br><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure></p>
<p>或是这样的错误:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cloning into &apos;xxx&apos;</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure></p>
<p>不止配置了一遍gitHub 的 <code>ssh key</code> 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.</p>
<p>后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加</p>
<p>需要添加一下你创建的公钥， 告诉系统可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/你的ssh key名称(不带.pub)</span><br></pre></td></tr></table></figure>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure></p>
<p>于是， clone 顺利</p>
<p>附上创建密钥的命令:</p>
<blockquote>
<p>ssh-keygen -t rsa -C “<a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a>“</p>
</blockquote>
<p>参考文献:</p>
<blockquote>
<p><a href="http://shinancao.cn/2016/12/18/Programming-Git-1/" target="_blank" rel="noopener">http://shinancao.cn/2016/12/18/Programming-Git-1/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】jest进行单元测试时提示router-view 未注册报错了</title>
    <url>/2019/09/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91jest%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%97%B6%E6%8F%90%E7%A4%BArouter-view-%E6%9C%AA%E6%B3%A8%E5%86%8C%E6%8A%A5%E9%94%99%E4%BA%86/</url>
    <content><![CDATA[<p>当我想要克隆一个项目时， 出了点小意外， 使用https 使用非常顺畅， 但是换成 ssh的方式就出问题了。死活行不通</p>
<p>git clone  一直提示这样的错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cloning into &apos;xxx&apos;...</span><br><span class="line">zsh:1: command not found: connect</span><br><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure></p>
<p>或是这样的错误:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cloning into &apos;xxx&apos;</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure></p>
<p>不止配置了一遍gitHub 的 <code>ssh key</code> 敢确信绝对没问题， 寻遍整个互联网依旧没有找到答案.</p>
<p>后来我发现原因时因为： 我创建的 ssh公钥没有被系统所使用, 因为默认只有is_rsa, 如果你自定义了那就需要添加</p>
<p>需要添加一下你创建的公钥， 告诉系统可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/你的ssh key名称(不带.pub)</span><br></pre></td></tr></table></figure>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure></p>
<p>于是， clone 顺利</p>
<p>附上创建密钥的命令:</p>
<blockquote>
<p>ssh-keygen -t rsa -C “<a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a>“</p>
</blockquote>
<p>参考文献:</p>
<blockquote>
<p><a href="http://shinancao.cn/2016/12/18/Programming-Git-1/" target="_blank" rel="noopener">http://shinancao.cn/2016/12/18/Programming-Git-1/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redux】react、redux与函数式编程</title>
    <url>/2019/07/07/%E3%80%90React%E3%80%91react%E3%80%81redux%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>redux 本身是container ， state就是value ， action 就是 变形关系</p>
</blockquote>
<ol>
<li>可以将React看作输入为state， 输出为view的“纯”函数</li>
<li>范畴论将世界抽象为对象和对象之间的联系， Redux将所有事件抽象为 <code>action</code> (变形关系)</li>
<li>container 有_value  和 map 两个属性， 而修改 _value 的方法直有 map  , 在操作完 _value 后将新值放回 Container中</li>
<li>如何操作或修改_value 由f给出</li>
<li>store 是一个容器含有state 和 reducer , 这从store 的创建语句， 并且currentState在修改完后将新值依然存放在 store内。<br>如何修改 currentState 是根据用户操作 action</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store -&gt; container</span><br><span class="line">currentState -&gt; _value</span><br><span class="line">action -&gt; f</span><br><span class="line">currentReducer -&gt; map</span><br><span class="line">middleware -&gt; IO functior <span class="comment">// 解决异步操作的各种问题</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】immutable 内部实现原理</title>
    <url>/2019/07/03/%E3%80%90React%E3%80%91immutable-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h2><p>Immutable.js 采用了持久化数据结构（每次修改后我们都会得到一个新的版本，且旧版本可以完好保留），保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过结构共享(对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享)等方式大幅提高性能。</p>
<h2 id="原理解读"><a href="#原理解读" class="headerlink" title="原理解读"></a>原理解读</h2><ol>
<li>Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据<br>时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。</li>
<li>Immutable.js 实现了一个hash函数，可以把一个值转换成相应数字。接下来HAMT</li>
<li>Hash array maps trie 压缩treeImmutablejs 对于 Map，使用了这种方式优化，并且通过树宽与树高的压缩，形成了文中例图中的效果（10010 10000 聚合成了一个节点，并且移除了同级的空节点）。</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-07-03-20-25-37.png" alt="2019-07-03-20-25-37"></p>
<p><img src="http://img.nixiaolei.com/2019-07-03-20-43-09.png" alt="2019-07-03-20-43-09"></p>
<h2 id="查找原理"><a href="#查找原理" class="headerlink" title="查找原理"></a>查找原理</h2><p>可以看到上面那张图一样， 查找 <code>tea</code>, 先找到 <code>t</code> 再找到<code>e</code> ,再往下找到<code>a</code>， 根据这个查找路径， 找到对应的值</p>
<p>二进制的查找方式也是这个原理， 如下图所示， 左上角的值与二进制路径互相映射</p>
<p><img src="http://img.nixiaolei.com/2019-07-03-20-54-59.png" alt="2019-07-03-20-54-59"></p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><ol>
<li>数字分区（Digit partitioning）指我们把一个 key 作为数字对应到一棵前缀树上。</li>
<li>位分区（Bit Partitioning）数字分区的方法是有点耗时的，在每一层我们都要进行两次除法一次取<br>模，显然这样并不高效，位分区就是对其的一种优化。位分区是建立在数字分区的基础上的，所有以2的<br>整数次幂（2，4，8，16，32…）为基数的数字分区前缀树，都可以转为位分区。基于一些位运算相关<br>的知识，我们就能避免一些耗时的计算。数字分区把 key 拆分成一个个数字，而位分区把 key 分成一组<br>组 bit。以一个 32 路的前缀树为例，数字分区的方法是把 key 以 32 为基数拆分（实际上就是 32 进<br>制），而位分区是把它以 5 个 bits 拆分，因为32 = 25，那我们就可以把 32 进制数的每一位看做 5 个二<br>进制位 。</li>
</ol>
<h2 id="bitMap"><a href="#bitMap" class="headerlink" title="bitMap"></a>bitMap</h2><blockquote>
<p>bitMap学习链接：<a href="https://blog.csdn.net/moakun/article/details/79927791" target="_blank" rel="noopener">https://blog.csdn.net/moakun/article/details/79927791</a></p>
</blockquote>
<p>利用位运算来快速查找计算，  得出结果， immutable 也正是利用了这一点， 在代码逻辑的关键处大量的使用了位运算</p>
<h2 id="为什么选择32位"><a href="#为什么选择32位" class="headerlink" title="为什么选择32位"></a>为什么选择32位</h2><p>Immutable.js 的 Vector Trie 采用了 32 作为数组的长度，我们解释了由于采用了位分区，该数字只能<br>是2的整数次幂，所以不能是 31、33 等。但8、16、64等等呢？这是通过实际测试得出的，图中分别是<br>查找和更新的时间，看上去似乎 8 或 16 更好？考虑到平时的使用中，查找比更新频次高很多，所以<br>Immutable.js 选择了 32</p>
<p><img src="http://img.nixiaolei.com/2019-07-03-21-36-06.png" alt="2019-07-03-21-36-06"></p>
<h2 id="32位如何处理"><a href="#32位如何处理" class="headerlink" title="32位如何处理"></a>32位如何处理</h2><p>immutable 会把32位挨个转换为二进制， 因为 2^5 = 32， 类似如下图， 每一位都会转换为相应的二进制用于快速位运算</p>
<p><img src="http://img.nixiaolei.com/2019-07-03-21-36-54.png" alt="2019-07-03-21-36-54"></p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><ol>
<li><p>Bitmap 一种数据结构，代表了有限域中的稠集（dense set），每一个元素至少出现一次，没有其他<br>的数据和元素相关联。在索引，数据压缩等方面有广泛应用。</p>
</li>
<li><p>HashArrayMapNode，拥有的子节点数量 ＞16 ，拥有的数组长度为 32</p>
</li>
<li>BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap<br>压缩</li>
<li>ValueNode，叶子节点，存储 key 和 value</li>
<li>HashCollisionNode的节点去处理发生冲突的键值</li>
</ol>
<h2 id="经典的代码段"><a href="#经典的代码段" class="headerlink" title="经典的代码段"></a>经典的代码段</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算二进制中1的数量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popCount</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x -= (x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">  x = (x &amp; <span class="number">0x33333333</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">  x = (x + (x &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">  x += x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  x += x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> x &amp; <span class="number">0x7f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>immutable</category>
      </categories>
      <tags>
        <tag>immutable</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】Object、Array与Map的比较</title>
    <url>/2019/06/30/%E3%80%90JS%E3%80%91Object%E3%80%81Array%E4%B8%8EMap%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="Object-与-Map"><a href="#Object-与-Map" class="headerlink" title="Object 与 Map"></a>Object 与 Map</h2><blockquote>
<p>Object 在V8中的实现是 key - value 分别作为一个数组存储, 所以存储空间是元素的两倍</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-06-30-23-22-24.png" alt="2019-06-30-23-22-24"></p>
<h2 id="和Array对比"><a href="#和Array对比" class="headerlink" title="和Array对比"></a>和Array对比</h2><p><img src="http://img.nixiaolei.com/2019-06-30-23-26-13.png" alt="2019-06-30-23-26-13"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】Set是如何实现的</title>
    <url>/2019/06/30/%E3%80%90JS%E3%80%91Set%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    <content><![CDATA[<h2 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h2><p>Set一般是使用红黑树实现的, 红黑树是一种平衡查找二叉树, 它的查找时间复杂度为O(logN). 从O(N)变成O(logN), 而总体时间从O(N2)变成O(NlogN)</p>
<h2 id="V8中的实现-哈希实现"><a href="#V8中的实现-哈希实现" class="headerlink" title="V8中的实现(哈希实现)"></a>V8中的实现(哈希实现)</h2><p>Chrome V8的Set是哈希实现的, 他是一个哈希Set, 哈希的查找复杂度为O(1), 因此总的时间复杂度为O(N), Set/ Map都是这样</p>
<p>哈希的存储空间通常为数据大小的两倍. 典型的用空间换时间的算法.</p>
<h2 id="for-、Set和Map如何选型"><a href="#for-、Set和Map如何选型" class="headerlink" title="for 、Set和Map如何选型"></a>for 、Set和Map如何选型</h2><p><img src="http://img.nixiaolei.com/2019-06-30-22-30-29.png" alt="2019-06-30-22-30-29"></p>
<h2 id="面试标准回答"><a href="#面试标准回答" class="headerlink" title="面试标准回答"></a>面试标准回答</h2><p>一般情况是使用 红黑树实现的, 复杂度是 O(logN)</p>
<p>V8进行了优化, 复杂度降低至 O(1)</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】MessageChannel消息通道</title>
    <url>/2019/06/30/%E3%80%90JS%E3%80%91MessageChannel%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>宏任务! 点对点之间的通信</p>
<p>Channel Messaging API的Channel Messaging接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。</p>
<p>它会返回两个端口 <code>Port1</code>和 <code>Port2</code></p>
<p><img src="http://img.nixiaolei.com/2019-06-30-21-51-18.png" alt="2019-06-30-21-51-18"></p>
<h2 id="使用场景思考"><a href="#使用场景思考" class="headerlink" title="使用场景思考"></a>使用场景思考</h2><ol>
<li>Vue 中用作与 $nextTick 的备选方案,  是宏任务</li>
<li>用作与Fiber 的进程调度中</li>
<li>可以用在组件之间的通信</li>
<li>利用参数传递默认深拷贝的特性来做深拷贝.</li>
<li>与Iframe 通信</li>
</ol>
<h2 id="一段Demo"><a href="#一段Demo" class="headerlink" title="一段Demo"></a>一段Demo</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="keyword">var</span> otherWindow = ifr.contentWindow;</span><br><span class="line"></span><br><span class="line">ifr.addEventListener(<span class="string">"load"</span>, iframeLoaded, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iframeLoaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  otherWindow.postMessage(<span class="string">'Hello from the main page!'</span>, <span class="string">'*'</span>, [channel.port2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel.port1.onmessage = handleMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  para.innerHTML = e.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】关于requestIdleCallback函数的作用</title>
    <url>/2019/06/30/%E3%80%90JS%E3%80%91%E5%85%B3%E4%BA%8ErequestIdleCallback%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>requestIdleCallback 会在浏览器每一帧的空闲时期依次调用函数， </p>
<p>如果说， 一个浏览器的效率很高，有60fps的刷新频率， 也就是说该浏览器每一帧的刷新时间是16.6s， 如果说电脑比较卡， 那刷新频率可能就会下降， 会是 30fps(原则上30fps是肉眼能接收的最低频率)。 此时，每一帧也就是33.3s， 该函数的出发场景就是在帧与帧之间， 也可以是说帧的末尾， 实际上每一帧并不一定会完全消耗完 16.6s 甚至是 33.3s， 他会有剩余的时间留给浏览器去执行js，  requestIdleCallback 就是如此， 用它调用的函数会在浏览器的该帧期间，渲染过后的剩余时间内调用该回调，</p>
<p>这也是react 16 fiber架构的调度算法核心</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</a></p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-06-30-12-36-16.png" alt="2019-06-30-12-36-16"></p>
<p>并且我们还可以通过 <code>deadline.timeRemaining</code>方法来查看该帧期间的剩余时间</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先尝试搭建一个最简单的demo ,打印一下 deadline 、剩余时间 和 该函数的返回值<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">window</span>.requestIdleCallback(<span class="function">(<span class="params">deadline</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 剩余时间， 单位ms, 指的是该帧的剩余时间</span></span><br><span class="line">  <span class="built_in">console</span>.log(deadline.timeRemaining())</span><br><span class="line">  <span class="comment">// 表示该帧里面没有执行回调， 超时了</span></span><br><span class="line">  <span class="built_in">console</span>.log(deadline)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="comment">// 1. 即超时时间， 不提供的话浏览器会自己去算</span></span><br><span class="line">  <span class="comment">// 2. 如果给定 timeout ， 那到了时间， 都会立刻执行回调 callback</span></span><br><span class="line">  timeout: <span class="number">1000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id)</span><br></pre></td></tr></table></figure></p>
<p>返回结果:</p>
<p><img src="http://img.nixiaolei.com/2019-06-30-12-48-25.png" alt="2019-06-30-12-48-25"></p>
<p>我们可以看到：</p>
<ol>
<li>该函数的返回结果(id)的值： 1</li>
<li>浏览器本帧的剩余空闲时间: 1.2750000000000001</li>
<li>回调接收的 <code>deadline</code>方法， 里面有一个 didTimeout 属性</li>
</ol>
<h2 id="如何取消requestIdleCallback"><a href="#如何取消requestIdleCallback" class="headerlink" title="如何取消requestIdleCallback"></a>如何取消requestIdleCallback</h2><p>将 requestIdleCallback 的返回值（一个无符号长整数），可以把它传入 Window.cancelIdleCallback() 方法，来结束回调</p>
<h2 id="如何实现-polyfill"><a href="#如何实现-polyfill" class="headerlink" title="如何实现 polyfill"></a>如何实现 polyfill</h2><p>requestIdleCallback 这个方法浏览器的兼容相当差， 那怎么办， React16 Fiber中也使用了， 别人是如何解决的呢？</p>
<p>答案是： <code>requestAnimationFrame</code></p>
<p><img src="http://img.nixiaolei.com/2019-06-30-12-59-21.png" alt="2019-06-30-12-59-21"></p>
<p>利用回调接收的 DOMHighResTimeStamp 参数， 计算出每一帧所花费的时间， 自己去实现一个 <code>requestIdleCallback</code> 的polyfill ,  简直完美</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】Fiber架构</title>
    <url>/2019/06/30/%E3%80%90React%E3%80%91Fiber%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Fiber-是什么"><a href="#Fiber-是什么" class="headerlink" title="Fiber 是什么"></a>Fiber 是什么</h2><p>Fiber 是一个名词， 在计算机科学中除了进程（Process） 和线程（Thread）的概念还有一个概念叫做Fiber, 英文含义就是“纤维”， 意指比Thread更细的线， 也就是比线程（Thread）控制得更精密的并发处理机制。Fiber可以提升复杂React应用的可响应性和性能。 Fiber 即是React 新的调度算法（ reconciliation algorithm） 现有React 中， 更新过程是同步的，当组件树比较庞大的时候， 浏览器主线程被React占用。用户此时输入Input 会造成页面卡顿。</p>
<p>Fiber使用协作式多任务处理任务。 将原来的整个Virtual Dom 的更新任务拆分成一个个小的任务。 每次做完一个小任务之后， 放弃一下自己的执行将线程空闲出来， 看看有没有其他的任务。如果有的话， 就暂停本次仍无， 执行其他的任务， 如果没有的话，就继续下一个任务。</p>
<h2 id="React16与Fiber"><a href="#React16与Fiber" class="headerlink" title="React16与Fiber"></a>React16与Fiber</h2><ol>
<li><p>react16升级了reconcile 算法架构， 从stack升级为fiber 架构。每次组件的state更新都会出发reconcile的执行也是一个递归过程， 而且一开始知道递归完所有节点才停止， 因此称为stack算法。由于js是单线程的， 因此此时就可能会影响用户的输入或者Ui的渲染帧频造成卡顿， 降低用户体验。而fiber 架构则不一样， 底层是基于 requestdleCallback来调度diff算法的执行， 它的特点顾名思义就是利用空闲时间来完成任务。 注意这里的空闲时间就是相对于那些优先级更高的任务（比如用户输入、 Ui渲染）来说的。</p>
</li>
<li><p>requestIdelCallback Polyfill 使用了一个33毫秒， 这个时间是React 认为的一个可以接收的最大值， 如果运行设备能做到大与30fps， 那么它会去调整这个值（通常情况下可以调整到16.6ms）。 调整策略是用当前每帧的总时间与实际每帧的时间进行比较， 当实际时间小于当前时间且稳定( 前后两次都小于当前时间 )， 那么就会认为这个值是有效的， 然后将没帧时间调整为该值（取前后两次中时间大的值）， 还有就是requestAnimationFrame 回调的第一个参数， 每一帧的起始时间， 最终借助requestAnimationFrame 让一批扁平任务恰好控制在一块一块的33ms这样的时间片内执行即可</p>
</li>
</ol>
<h2 id="Fiber的两个阶段"><a href="#Fiber的两个阶段" class="headerlink" title="Fiber的两个阶段"></a>Fiber的两个阶段</h2><p>由reconciler和 renderer两个概念引出的是Phase的概念， Phase指的是React组件渲染时的阶段。</p>
<ol>
<li><p>Reconcile 阶段。 此阶段中， 依序遍历组件， 通过diff算法， 判断组件是否需要更新， 给需要更新的组件加上tag， 遍历完之后， 将所有带有tag的组件加到一个数组中。 这个阶段的任务可以被打断。</p>
</li>
<li><p>Commit 阶段。 根据Reconcile 阶段生成的数组， 遍历更新DOM， 这个阶段需要一次性执行完。（无法被打断）</p>
</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-06-30-13-11-52.png" alt="2019-06-30-13-11-52"></p>
<h3 id="如何打断任务"><a href="#如何打断任务" class="headerlink" title="如何打断任务"></a>如何打断任务</h3><p>Fiber的打断方式就是使用<code>cancelIdleCallback</code>方法取消掉回调</p>
<h2 id="Fiber如何排列任务"><a href="#Fiber如何排列任务" class="headerlink" title="Fiber如何排列任务"></a>Fiber如何排列任务</h2><blockquote>
<p>利用双向链表， 按照任务的优先级设定任务的过期时间，然后根据任务的过期时间，插入到双向链表中</p>
</blockquote>
<p>React Fiber 把更新过程碎片化， 每执行完一段更新过程， 就把控制权交还给React 负责仍无协调的模块， 看看有没有其他紧急任务要做， 如果没有就继续去更新， 如果由紧急任务， 那就去做紧急任务。Fiber分为2个阶段， </p>
<ol>
<li><p>第一阶段Reconciliation Phase( componentWillMount、componentWillReceiveProps、 shouldComponentUpdate、componentWillUpdate)  </p>
</li>
<li><p>第二阶段Commit Phase(componentDidMount、componentDidUpdate、componentWillUnmount )第一阶段可能会被打断， 也就意味着第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！</p>
</li>
</ol>
<hr>
<p>getDerivedStateFromProps在处在Render Phase阶段， 每次的更新都要触发。这个生命周期是纯函数、静态方法为了隔离实例(禁止this.refs等)单纯且高效， getSnapshotBeforeUpdate到了commit 阶段，因此这个函数只会运行一次</p>
<h2 id="概述Fiber原理"><a href="#概述Fiber原理" class="headerlink" title="概述Fiber原理"></a>概述Fiber原理</h2><p>Fiber 核心思想是渲染和js执行之间的调度,  为了在进行复杂的js代码时不阻碍到用户体验, 比如React 在执行某些代码时, input 的框没有办法在用户执行时及时的做出响应, 这就会让用户觉得这个网页卡死了!,  Fiber 就是为了解决这个问题而生的</p>
<p>Fiber 可以说是参考了操作系统管理进程的方式, 分时调度, 给每个进程一定的执行时间来回切换,   而Fiber 是让js任务与浏览器渲染之间来回切换, 以防止出现无响应的情况.</p>
<p>那Fiber 会如何做呢:</p>
<p>首先, Fiber 会模拟一个requestIdleCallback 方法, 是利用requestAnimationFrame 实现的polyfill 方法,  利用该方法回调中接收的参数来判定每一帧留下的空闲期,   然后给每一个任务都判定级别, 轻重缓急, 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ImmediatePriority = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> UserBlockingPriority = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> NormalPriority = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> LowPriority = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> IdlePriority = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>每个优先级都对应着不一样的 deadline(超时时间):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Times out immediately</span></span><br><span class="line"><span class="keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="comment">// 250ms以后过期</span></span><br><span class="line"><span class="keyword">var</span> USER_BLOCKING_PRIORITY = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="comment">// 永不过期 - 为什么是12天， 因为v8整数上限</span></span><br><span class="line"><span class="keyword">var</span> IDLE_PRIORITY = maxSigned31BitInt;</span><br></pre></td></tr></table></figure>
<p>规定好每个不同优先级任务的 超时时间后, 我们就可以对每个任务进行排队了, 那如何排队最灵活呢?  首先Fiber 会构建一个 <code>循环双向链</code> , 将每个任务都作为一个节点, 并根据超时时间作为排序的依据, 每当有新任务进入时, 从头挨个对比每个节点, 直至遇到超时时间大于该任务自身的节点, 将其插入到该位置, 如果整个链表中都没有找到超时时间大于该任务的节点, 那么就他就作为了链表的末尾节点, 并将 Next 指向链表的首节点. 又或者,如果首节点就符合条件, 那该节点就转而变成了首节点</p>
<p>Fiber对浏览器的帧率有个最低下限的取值, 也就是33 ( 根据每秒30帧得出 ),  但是这个值也并不是写死的, 它会去跑两次方法尝试计算, 如果两次计算所花费的时间小于这个值, 也就是用两次测试来判断浏览器性能, 如果浏览器性能超出预期, 那么就会使用着两次计算结果的最大值. 这是Fiber在进行动态的压帧. 根据性能提供最优的时间.</p>
<p>优先次序排列好了, 执行间隔也确定了, 那剩下的事情就是执行了,  执行呢就是我们刚刚说的, 利用<code>requestAnimationFrame</code> 计算出每一帧的空档期,  这里需要注意, Fiber 还留有一手备用, 那就是 <code>setTimeout</code>. 为什么要使用<code>setTimeout</code> 呢, 这是因为, <code>requestAnimationFrame</code>有个致命的问题, 当用户切换浏览器tab页以后, <code>requestAnimationFrame</code> 就会停止执行, 所以Fiber就会转而切换至使用<code>setTimeout</code> 代替.  并且在 <code>requestAnimationFrame</code> 执行时打断了 <code>setTimeout</code> , 在<code>setTimeout</code> 执行时打断了<code>requestAnimationFrame</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">  rAFID = localRequestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每一次系统执行的performance.now 默认间隔是16.7</span></span><br><span class="line">    <span class="comment">// cancel the setTimeout</span></span><br><span class="line">    localClearTimeout(rAFTimeoutID);</span><br><span class="line">    callback(timestamp);</span><br><span class="line">  &#125;);</span><br><span class="line">  rAFTimeoutID = localSetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">    localCancelAnimationFrame(rAFID);</span><br><span class="line">    callback(exports.unstable_now());</span><br><span class="line">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Fiber在每一帧的具体执行期间,会尽可能多的执行任务, 也就是说一个任务执行完如果时间还没到还会再找下一个任务,  并使用<code>MessageChannel</code>来进行分配任务, 并且有时候会有浏览器渲染任务较重时,如重排, 导致了占用时间超时, 那么Fiber会强制执行以超时的那些任务, 因为这些任务实在不能再拖了, 再拖下去,整个程序就废了, 所以必须现在执行完毕,  执行完的任务就会退出链表, 当本次查找到的超时任务都执行完毕后, Fiber 又会再去遍历一遍链表看看还有没有新的超时任务, 如果有那就接着执行掉, 执行完了同理, 又去再查找一遍, 一直重复, 直至没有超时任务了, 然后让出线程让浏览器渲染.  </p>
<p>到这里就是Fiber 调度的主要原理, 写的很糙, 可能直有我自己能看懂了</p>
<h2 id="Fiber-源码-注释"><a href="#Fiber-源码-注释" class="headerlink" title="Fiber 源码 + 注释"></a>Fiber 源码 + 注释</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @license React v0.13.6</span></span><br><span class="line"><span class="comment"> * scheduler.development.js</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) Facebook, Inc. and its affiliates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This source code is licensed under the MIT license found in the</span></span><br><span class="line"><span class="comment"> * LICENSE file in the root directory of this source tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老袁解析react fiber</span></span><br><span class="line"><span class="comment"> * 1.获取当前系统的开始时间</span></span><br><span class="line"><span class="comment"> * 2.设置任务的优先级</span></span><br><span class="line"><span class="comment"> * 3.根据优先级别设置对应的过期时间</span></span><br><span class="line"><span class="comment"> * 4.根据过期时间进行双向链表的排序</span></span><br><span class="line"><span class="comment"> * 5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled</span></span><br><span class="line"><span class="comment"> * 6.按照每一帧之后的空闲开始进行更新 requestAnimationFrameWithTimeout</span></span><br><span class="line"><span class="comment"> * 7.animationTick是线索 计算帧过期时间并压缩帧</span></span><br><span class="line"><span class="comment"> * 8.配合MessageChannel进行具体的调度任务</span></span><br><span class="line"><span class="comment"> * 9.prevScheduledCallback == flushWork最终执行调度</span></span><br><span class="line"><span class="comment"> * 原则：有过期的执行全部过期 没过期尽可能多的执行</span></span><br><span class="line"><span class="comment"> * 剩下没执行完轮回到5 如果插入了高优先级的立即执行</span></span><br><span class="line"><span class="comment"> *  */</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> enableSchedulerDebugging = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eslint-disable no-var */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Use symbols?</span></span><br><span class="line">    <span class="comment">//yideng 2.设置任务的优先级</span></span><br><span class="line">    <span class="keyword">var</span> ImmediatePriority = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> UserBlockingPriority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> NormalPriority = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> LowPriority = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">var</span> IdlePriority = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// var ImmediatePriority = 1;  //最高优先级</span></span><br><span class="line">    <span class="comment">// var UserBlockingPriority = 2; //用户阻塞型优先级</span></span><br><span class="line">    <span class="comment">// var NormalPriority = 3; //普通优先级</span></span><br><span class="line">    <span class="comment">// var LowPriority = 4; // 低优先级</span></span><br><span class="line">    <span class="comment">// var IdlePriority = 5; // 空闲优先级</span></span><br><span class="line">    <span class="comment">//==========接下来是对五种优先级别设置的五个过期时间=============</span></span><br><span class="line">    <span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line">    <span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line">    <span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line">    <span class="comment">//3.根据优先级别设置对应的过期时间</span></span><br><span class="line">    <span class="comment">//32位系统V8引擎里最大的整数 据粗略计算这个时间大概是12.427天</span></span><br><span class="line">    <span class="comment">//tab页开着12天才会过期</span></span><br><span class="line">    <span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>;</span><br><span class="line">    <span class="comment">// 立马过期 ==&gt; ImmediatePriority</span></span><br><span class="line">    <span class="comment">// Times out immediately</span></span><br><span class="line">    <span class="keyword">var</span> IMMEDIATE_PRIORITY_TIMEOUT = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Eventually times out</span></span><br><span class="line">    <span class="comment">// 250ms以后过期</span></span><br><span class="line">    <span class="keyword">var</span> USER_BLOCKING_PRIORITY = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">var</span> NORMAL_PRIORITY_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">var</span> LOW_PRIORITY_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// Never times out</span></span><br><span class="line">    <span class="comment">// 永不过期 - 为什么是12天， 因为v8整数上限</span></span><br><span class="line">    <span class="keyword">var</span> IDLE_PRIORITY = maxSigned31BitInt;</span><br><span class="line">    <span class="comment">/*每个任务在添加到链表里的时候，都会通过 performance.now() + timeout</span></span><br><span class="line"><span class="comment">    来得出这个任务的过期时间，随着时间的推移，当前时间会越来越接近这个过期时间，</span></span><br><span class="line"><span class="comment">    所以过期时间越小的代表优先级越高。如果过期时间已经比当前时间小了，</span></span><br><span class="line"><span class="comment">    说明这个任务已经过期了还没执行，需要立马去执行(asap)。*/</span></span><br><span class="line">    <span class="comment">// Callbacks are stored as a circular, doubly linked list.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个任务节点</span></span><br><span class="line">    <span class="keyword">var</span> firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentDidTimeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Pausing the scheduler is useful for debugging.</span></span><br><span class="line">    <span class="keyword">var</span> isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentPriorityLevel = NormalPriority;</span><br><span class="line">    <span class="keyword">var</span> currentEventStartTime = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> currentExpirationTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is set when a callback is being executed, to prevent re-entrancy.</span></span><br><span class="line">    <span class="keyword">var</span> isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//yideng 1.获取当前系统的开始时间-performance.now</span></span><br><span class="line">    <span class="keyword">var</span> hasNativePerformanceNow =</span><br><span class="line">      <span class="keyword">typeof</span> performance === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> performance.now === <span class="string">"function"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ensureHostCallbackIsScheduled</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isExecutingCallback) &#123;</span><br><span class="line">        <span class="comment">// Don't schedule work yet; wait until the next time we yield.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule the host callback using the earliest expiration in the list.</span></span><br><span class="line">      <span class="keyword">var</span> expirationTime = firstCallbackNode.expirationTime;</span><br><span class="line">      <span class="comment">// 加锁</span></span><br><span class="line">      <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cancel the existing host callback.</span></span><br><span class="line">        cancelHostCallback();</span><br><span class="line">      &#125;</span><br><span class="line">      requestHostCallback(flushWork, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flushFirstCallback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> flushedNode = firstCallbackNode;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remove the node from the list before calling the callback. That way the</span></span><br><span class="line">      <span class="comment">// list is in a consistent state even if the callback throws.</span></span><br><span class="line">      <span class="keyword">var</span> next = firstCallbackNode.next;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode === next) &#123;</span><br><span class="line">        <span class="comment">// This is the last callback in the list.</span></span><br><span class="line">        firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> lastCallbackNode = firstCallbackNode.previous;</span><br><span class="line">        firstCallbackNode = lastCallbackNode.next = next;</span><br><span class="line">        next.previous = lastCallbackNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      flushedNode.next = flushedNode.previous = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now it's safe to call the callback.</span></span><br><span class="line">      <span class="keyword">var</span> callback = flushedNode.callback;</span><br><span class="line">      <span class="keyword">var</span> expirationTime = flushedNode.expirationTime;</span><br><span class="line">      <span class="keyword">var</span> priorityLevel = flushedNode.priorityLevel;</span><br><span class="line">      <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">      <span class="keyword">var</span> previousExpirationTime = currentExpirationTime;</span><br><span class="line">      currentPriorityLevel = priorityLevel;</span><br><span class="line">      currentExpirationTime = expirationTime;</span><br><span class="line">      <span class="keyword">var</span> continuationCallback;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        continuationCallback = callback();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">        currentExpirationTime = previousExpirationTime;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A callback may return a continuation. The continuation should be scheduled</span></span><br><span class="line">      <span class="comment">// with the same priority and expiration as the just-finished callback.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> continuationNode = &#123;</span><br><span class="line">          callback: continuationCallback,</span><br><span class="line">          priorityLevel: priorityLevel,</span><br><span class="line">          expirationTime: expirationTime,</span><br><span class="line">          next: <span class="literal">null</span>,</span><br><span class="line">          previous: <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insert the new callback into the list, sorted by its expiration. This is</span></span><br><span class="line">        <span class="comment">// almost the same as the code in `scheduleCallback`, except the callback</span></span><br><span class="line">        <span class="comment">// is inserted into the list *before* callbacks of equal expiration instead</span></span><br><span class="line">        <span class="comment">// of after.</span></span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> nextAfterContinuation = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.expirationTime &gt;= expirationTime) &#123;</span><br><span class="line">              <span class="comment">// This callback expires at or after the continuation. We will insert</span></span><br><span class="line">              <span class="comment">// the continuation *before* this callback.</span></span><br><span class="line">              nextAfterContinuation = node;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (nextAfterContinuation === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No equal or lower priority callback was found, which means the new</span></span><br><span class="line">            <span class="comment">// callback is the lowest priority callback in the list.</span></span><br><span class="line">            nextAfterContinuation = firstCallbackNode;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextAfterContinuation === firstCallbackNode) &#123;</span><br><span class="line">            <span class="comment">// The new callback is the highest priority callback in the list.</span></span><br><span class="line">            firstCallbackNode = continuationNode;</span><br><span class="line">            ensureHostCallbackIsScheduled();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> previous = nextAfterContinuation.previous;</span><br><span class="line">          previous.next = nextAfterContinuation.previous = continuationNode;</span><br><span class="line">          continuationNode.next = nextAfterContinuation;</span><br><span class="line">          continuationNode.previous = previous;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flushImmediateWork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// Confirm we've exited the outer most event handler</span></span><br><span class="line">        currentEventStartTime === <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">      ) &#123;</span><br><span class="line">        isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            flushFirstCallback();</span><br><span class="line">          &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// Keep flushing until there are no more immediate callbacks</span></span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            firstCallbackNode.priorityLevel === ImmediatePriority</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// There's still work remaining. Request another callback.</span></span><br><span class="line">            ensureHostCallbackIsScheduled();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Exit right away if we're currently paused</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isExecutingCallback = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> previousDidTimeout = currentDidTimeout;</span><br><span class="line">      currentDidTimeout = didTimeout;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果是任务过期了 赶紧排队把过期的任务给执行了</span></span><br><span class="line">        <span class="keyword">if</span> (didTimeout) &#123;</span><br><span class="line">          <span class="comment">// Flush all the expired callbacks without yielding.</span></span><br><span class="line">          <span class="keyword">while</span> (</span><br><span class="line">            firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// TODO Wrap in feature flag</span></span><br><span class="line">            <span class="comment">// Read the current time. Flush all the callbacks that expire at or</span></span><br><span class="line">            <span class="comment">// earlier than that time. Then read the current time again and repeat.</span></span><br><span class="line">            <span class="comment">// This optimizes for as few performance.now calls as possible.</span></span><br><span class="line">            <span class="keyword">var</span> currentTime = exports.unstable_now();</span><br><span class="line">            <span class="keyword">if</span> (firstCallbackNode.expirationTime &lt;= currentTime) &#123;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                flushFirstCallback();</span><br><span class="line">              &#125; <span class="keyword">while</span> (</span><br><span class="line">                firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                firstCallbackNode.expirationTime &lt;= currentTime &amp;&amp;</span><br><span class="line">                !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">              );</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//当前帧有富余时间，while的逻辑是只要有任务且当前帧没过期就去执行任务。</span></span><br><span class="line">          <span class="comment">//执行队首任务，把队首任务从链表移除，并把第二个任务置为队首任务。执行任务可能产生新的任务，再把新任务插入到任务链表</span></span><br><span class="line">          <span class="comment">// Keep flushing callbacks until we run out of time in the frame.</span></span><br><span class="line">          <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (enableSchedulerDebugging &amp;&amp; isSchedulerPaused) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              flushFirstCallback();</span><br><span class="line">              <span class="comment">//shouldYieldToHost代表当前帧过期了，取反的话就是没过期。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (firstCallbackNode !== <span class="literal">null</span> &amp;&amp; !shouldYieldToHost());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        isExecutingCallback = <span class="literal">false</span>;</span><br><span class="line">        currentDidTimeout = previousDidTimeout;</span><br><span class="line">        <span class="comment">//最后，如果还有任务的话，再启动一轮新的任务执行调度</span></span><br><span class="line">        <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// There's still work remaining. Request another callback.</span></span><br><span class="line">          ensureHostCallbackIsScheduled();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">         <span class="comment">//最最后，如果还有任务且有最高优先级的任务，就都执行一遍。</span></span><br><span class="line">        flushImmediateWork();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_runWithPriority</span>(<span class="params">priorityLevel, eventHandler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        <span class="keyword">case</span> NormalPriority:</span><br><span class="line">        <span class="keyword">case</span> LowPriority:</span><br><span class="line">        <span class="keyword">case</span> IdlePriority:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          priorityLevel = NormalPriority;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">      <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">      currentPriorityLevel = priorityLevel;</span><br><span class="line">      currentEventStartTime = exports.unstable_now();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> eventHandler();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">        currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">        flushImmediateWork();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_next</span>(<span class="params">eventHandler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> priorityLevel = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">        <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">        <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">        <span class="keyword">case</span> NormalPriority:</span><br><span class="line">          <span class="comment">// Shift down to normal priority</span></span><br><span class="line">          priorityLevel = NormalPriority;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Anything lower than normal priority should remain at the current level.</span></span><br><span class="line">          priorityLevel = currentPriorityLevel;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">      <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">      currentPriorityLevel = priorityLevel;</span><br><span class="line">      currentEventStartTime = exports.unstable_now();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> eventHandler();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">        currentEventStartTime = previousEventStartTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Before exiting, flush all the immediate work that was scheduled.</span></span><br><span class="line">        flushImmediateWork();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_wrapCallback</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> parentPriorityLevel = currentPriorityLevel;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// This is a fork of runWithPriority, inlined for performance.</span></span><br><span class="line">        <span class="keyword">var</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">        <span class="keyword">var</span> previousEventStartTime = currentEventStartTime;</span><br><span class="line">        currentPriorityLevel = parentPriorityLevel;</span><br><span class="line">        currentEventStartTime = exports.unstable_now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">          currentEventStartTime = previousEventStartTime;</span><br><span class="line">          flushImmediateWork();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//yideng 4.根据过期时间进行双向链表的排序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">callback, deprecated_options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> startTime =</span><br><span class="line">        currentEventStartTime !== <span class="number">-1</span></span><br><span class="line">          ? currentEventStartTime</span><br><span class="line">          : exports.unstable_now();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> expirationTime;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> deprecated_options === <span class="string">"object"</span> &amp;&amp;</span><br><span class="line">        deprecated_options !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> deprecated_options.timeout === <span class="string">"number"</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Remove this branch once we lift expiration times out of React.</span></span><br><span class="line">        <span class="comment">//如果没有传递过去时间的话直接按照默认的传递</span></span><br><span class="line">        expirationTime = startTime + deprecated_options.timeout;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentPriorityLevel) &#123;</span><br><span class="line">          <span class="keyword">case</span> ImmediatePriority:</span><br><span class="line">            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> UserBlockingPriority:</span><br><span class="line">            expirationTime = startTime + USER_BLOCKING_PRIORITY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> IdlePriority:</span><br><span class="line">            expirationTime = startTime + IDLE_PRIORITY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> LowPriority:</span><br><span class="line">            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> NormalPriority:</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//yideng 双向的链表</span></span><br><span class="line">      <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">        callback: callback, <span class="comment">//任务具体的内容</span></span><br><span class="line">        priorityLevel: currentPriorityLevel, <span class="comment">//任务优先级</span></span><br><span class="line">        expirationTime: expirationTime, <span class="comment">//任务的过期时间</span></span><br><span class="line">        next: <span class="literal">null</span>, <span class="comment">//下一个节点</span></span><br><span class="line">        previous: <span class="literal">null</span> <span class="comment">//上一个节点</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Insert the new callback into the list, ordered first by expiration, then</span></span><br><span class="line">      <span class="comment">// by insertion. So the new callback is inserted any other callback with</span></span><br><span class="line">      <span class="comment">// equal expiration.</span></span><br><span class="line">      <span class="comment">//yideng仿照之前的双向节点的例子 插入指定节点</span></span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This is the first callback in the list.</span></span><br><span class="line">        firstCallbackNode = newNode.next = newNode.previous = newNode;</span><br><span class="line">        <span class="comment">//排完顺序之后按照指定的规则执行任务</span></span><br><span class="line">        <span class="comment">//那么什么是合适的时间呢？也就是之前讨论过的每一帧绘制完成之后的空闲时间</span></span><br><span class="line">        <span class="comment">//5.排完序了 然后如何执行呢？？？ensureHostCallbackIsScheduled</span></span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一直查找链表, 直至某个节点的next === firtNode</span></span><br><span class="line">        <span class="keyword">var</span> next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> node = firstCallbackNode;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 对比过期时间</span></span><br><span class="line">          <span class="keyword">if</span> (node.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点的过期时间 比 新来的callback 过期时间要晚 , 则将next指向当前的节点</span></span><br><span class="line">            <span class="comment">// The new callback expires before this one.</span></span><br><span class="line">            next = node;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          node = node.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (node !== firstCallbackNode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// next === null 就表示始终未找到某个节点比新来的回调过期时间要晚, 这就表示他是最晚的, 他是链表的末尾, 所以把他的next指向首节点</span></span><br><span class="line">        <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// No callback with a later expiration was found, which means the new</span></span><br><span class="line">          <span class="comment">// callback has the latest expiration in the list.</span></span><br><span class="line">          next = firstCallbackNode;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// next === firstCallbackNode 表示找到符合条件的节点， 但是该节点是首节点， 这就表示 新的回调 比 firtCallbackNode 的优先级还要高的话， 就将他作为</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstCallbackNode) &#123;</span><br><span class="line">          <span class="comment">// The new callback has the earliest expiration in the entire list.</span></span><br><span class="line">          firstCallbackNode = newNode;</span><br><span class="line">          ensureHostCallbackIsScheduled();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> previous = next.previous;</span><br><span class="line">        previous.next = next.previous = newNode;</span><br><span class="line">        newNode.next = next;</span><br><span class="line">        newNode.previous = previous;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_pauseExecution</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      isSchedulerPaused = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_continueExecution</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      isSchedulerPaused = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (firstCallbackNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        ensureHostCallbackIsScheduled();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_getFirstCallbackNode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstCallbackNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_cancelCallback</span>(<span class="params">callbackNode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> next = callbackNode.next;</span><br><span class="line">      <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Already cancelled.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (next === callbackNode) &#123;</span><br><span class="line">        <span class="comment">// This is the only scheduled callback. Clear the list.</span></span><br><span class="line">        firstCallbackNode = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove the callback from its position in the list.</span></span><br><span class="line">        <span class="keyword">if</span> (callbackNode === firstCallbackNode) &#123;</span><br><span class="line">          firstCallbackNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> previous = callbackNode.previous;</span><br><span class="line">        previous.next = next;</span><br><span class="line">        next.previous = previous;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      callbackNode.next = callbackNode.previous = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_getCurrentPriorityLevel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currentPriorityLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unstable_shouldYield</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        !currentDidTimeout &amp;&amp;</span><br><span class="line">        ((firstCallbackNode !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">          firstCallbackNode.expirationTime &lt; currentExpirationTime) ||</span><br><span class="line">          shouldYieldToHost())</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The remaining code is essentially a polyfill for requestIdleCallback. It</span></span><br><span class="line">    <span class="comment">// works by scheduling a requestAnimationFrame, storing the time for the start</span></span><br><span class="line">    <span class="comment">// of the frame, then scheduling a postMessage which gets scheduled after paint.</span></span><br><span class="line">    <span class="comment">// Within the postMessage handler do as much work as possible until time + frame</span></span><br><span class="line">    <span class="comment">// rate. By separating the idle call into a separate event tick we ensure that</span></span><br><span class="line">    <span class="comment">// layout, paint and other browser work is counted against the available time.</span></span><br><span class="line">    <span class="comment">// The frame rate is dynamically adjusted.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We capture a local reference to any global, in case it gets polyfilled after</span></span><br><span class="line">    <span class="comment">// this module is initially evaluated. We want to be using a</span></span><br><span class="line">    <span class="comment">// consistent implementation.</span></span><br><span class="line">    <span class="keyword">var</span> localDate = <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This initialization code may run even on server environments if a component</span></span><br><span class="line">    <span class="comment">// just imports ReactDOM (e.g. for findDOMNode). Some environments might not</span></span><br><span class="line">    <span class="comment">// have setTimeout or clearTimeout. However, we always expect them to be defined</span></span><br><span class="line">    <span class="comment">// on the client. https://github.com/facebook/react/pull/13088</span></span><br><span class="line">    <span class="keyword">var</span> localSetTimeout =</span><br><span class="line">      <span class="keyword">typeof</span> setTimeout === <span class="string">"function"</span> ? setTimeout : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">var</span> localClearTimeout =</span><br><span class="line">      <span class="keyword">typeof</span> clearTimeout === <span class="string">"function"</span> ? clearTimeout : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't expect either of these to necessarily be defined, but we will error</span></span><br><span class="line">    <span class="comment">// later if they are missing on the client.</span></span><br><span class="line">    <span class="keyword">var</span> localRequestAnimationFrame =</span><br><span class="line">      <span class="keyword">typeof</span> requestAnimationFrame === <span class="string">"function"</span></span><br><span class="line">        ? requestAnimationFrame</span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">var</span> localCancelAnimationFrame =</span><br><span class="line">      <span class="keyword">typeof</span> cancelAnimationFrame === <span class="string">"function"</span></span><br><span class="line">        ? cancelAnimationFrame</span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// requestAnimationFrame does not run when the tab is in the background. If</span></span><br><span class="line">    <span class="comment">// we're backgrounded we prefer for that work to happen so that the page</span></span><br><span class="line">    <span class="comment">// continues to load in the background. So we also schedule a 'setTimeout' as</span></span><br><span class="line">    <span class="comment">// a fallback.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Need a better heuristic for backgrounded work.</span></span><br><span class="line">    <span class="comment">// ↑这句话表示，使用setTimeout 也是无奈之举， 之后会更优化， 当下是迫于浏览器不支持</span></span><br><span class="line">    <span class="keyword">var</span> ANIMATION_FRAME_TIMEOUT = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">var</span> rAFID;</span><br><span class="line">    <span class="keyword">var</span> rAFTimeoutID;</span><br><span class="line">    <span class="comment">//yideng 如果tab不激活的话 使用SetTimeout进行处理 如果正常情况直接干掉timeout</span></span><br><span class="line">    <span class="comment">//6.按照每一帧之后的空闲开始进行更新requestAnimationFrameWithTimeout</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 这里又使用了 setTimeout 又使用了RequestAnimationFrame 并且还互相清除， </span></span><br><span class="line">    <span class="comment">// 是因为 RequestAnimationFrame 有一个落点， 就是当浏览器切到其他tab页的时候会暂停执行</span></span><br><span class="line">    <span class="keyword">var</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// schedule rAF and also a setTimeout</span></span><br><span class="line">      rAFID = localRequestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每一次系统执行的performance.now 默认间隔是16.7</span></span><br><span class="line">        <span class="comment">// cancel the setTimeout</span></span><br><span class="line">        localClearTimeout(rAFTimeoutID);</span><br><span class="line">        callback(timestamp);</span><br><span class="line">      &#125;);</span><br><span class="line">      rAFTimeoutID = localSetTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// cancel the requestAnimationFrame</span></span><br><span class="line">        localCancelAnimationFrame(rAFID);</span><br><span class="line">        callback(exports.unstable_now());</span><br><span class="line">      &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasNativePerformanceNow) &#123;</span><br><span class="line">      <span class="keyword">var</span> Performance = performance;</span><br><span class="line">      exports.unstable_now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Performance.now();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exports.unstable_now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate.now();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestHostCallback;</span><br><span class="line">    <span class="keyword">var</span> cancelHostCallback;</span><br><span class="line">    <span class="keyword">var</span> shouldYieldToHost;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> globalValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      globalValue = <span class="built_in">window</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      globalValue = global;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (globalValue &amp;&amp; globalValue._schedMock) &#123;</span><br><span class="line">      <span class="comment">// Dynamic injection, only for testing purposes.</span></span><br><span class="line">      <span class="keyword">var</span> globalImpl = globalValue._schedMock;</span><br><span class="line">      requestHostCallback = globalImpl[<span class="number">0</span>];</span><br><span class="line">      cancelHostCallback = globalImpl[<span class="number">1</span>];</span><br><span class="line">      shouldYieldToHost = globalImpl[<span class="number">2</span>];</span><br><span class="line">      exports.unstable_now = globalImpl[<span class="number">3</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      <span class="comment">// If Scheduler runs in a non-DOM environment, it falls back to a naive</span></span><br><span class="line">      <span class="comment">// implementation using setTimeout.</span></span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">"undefined"</span> ||</span><br><span class="line">      <span class="comment">// Check if MessageChannel is supported, too.</span></span><br><span class="line">      <span class="keyword">typeof</span> MessageChannel !== <span class="string">"function"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,</span></span><br><span class="line">      <span class="comment">// fallback to a naive implementation.</span></span><br><span class="line">      <span class="keyword">var</span> _callback = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> _flushCallback = <span class="function"><span class="keyword">function</span>(<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            _callback(didTimeout);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _callback = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">cb, ms</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Protect against re-entrancy.</span></span><br><span class="line">          setTimeout(requestHostCallback, <span class="number">0</span>, cb);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          _callback = cb;</span><br><span class="line">          setTimeout(_flushCallback, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      cancelHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _callback = <span class="literal">null</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      shouldYieldToHost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">console</span> !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Remove fb.me link</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> localRequestAnimationFrame !== <span class="string">"function"</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(</span><br><span class="line">            <span class="string">"This browser doesn't support requestAnimationFrame. "</span> +</span><br><span class="line">              <span class="string">"Make sure that you load a "</span> +</span><br><span class="line">              <span class="string">"polyfill in older browsers. https://fb.me/react-polyfills"</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> localCancelAnimationFrame !== <span class="string">"function"</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(</span><br><span class="line">            <span class="string">"This browser doesn't support cancelAnimationFrame. "</span> +</span><br><span class="line">              <span class="string">"Make sure that you load a "</span> +</span><br><span class="line">              <span class="string">"polyfill in older browsers. https://fb.me/react-polyfills"</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> scheduledHostCallback = <span class="literal">null</span>; <span class="comment">//代表任务链表的执行器</span></span><br><span class="line">      <span class="keyword">var</span> isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> timeoutTime = <span class="number">-1</span>; <span class="comment">//代表最高优先级任务firstCallbackNode的过期时间</span></span><br><span class="line">      <span class="keyword">var</span> isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> frameDeadline = <span class="number">0</span>; <span class="comment">//代表一帧的过期时间，通过rAF回调入参t加上activeFrameTime来计算</span></span><br><span class="line">      <span class="comment">// We start out assuming that we run at 30fps but then the heuristic tracking</span></span><br><span class="line">      <span class="comment">// will adjust this value to a faster fps if we get more frequent animation</span></span><br><span class="line">      <span class="comment">// frames.</span></span><br><span class="line">      <span class="keyword">var</span> previousFrameTime = <span class="number">33</span>; <span class="comment">// 一帧的渲染时间33ms，这里假设 1s 30帧</span></span><br><span class="line">      <span class="keyword">var</span> activeFrameTime = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">      shouldYieldToHost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frameDeadline &lt;= exports.unstable_now();</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We use the postMessage trick to defer idle work until after the repaint.</span></span><br><span class="line">      <span class="comment">//如下是整个的执行流程，</span></span><br><span class="line">      <span class="comment">//8.配合MessageChannel进行具体的调度任务</span></span><br><span class="line">      <span class="comment">//8-1.在每一帧开始的rAF的回调里记录每一帧的开始时间，并计算每一帧的过期时间，</span></span><br><span class="line">      <span class="comment">//8-2.通过messageChannel发送消息。在帧末messageChannel的回调里接收消息，</span></span><br><span class="line">      <span class="comment">//8-3.根据当前帧的过期时间和当前时间进行比对来决定当前帧能否执行任务，</span></span><br><span class="line">      <span class="comment">//8-4.如果能的话会依次从任务链表里拿出队首任务来执行</span></span><br><span class="line">      <span class="comment">//8-5.执行尽可能多的任务后如果还有任务，下一帧再重新调度。</span></span><br><span class="line">      <span class="keyword">var</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">      <span class="keyword">var</span> port = channel.port2;</span><br><span class="line">      <span class="comment">//下面的代码逻辑决定当前帧要不要执行任务</span></span><br><span class="line">      <span class="comment">// 1、如果当前帧没过期，说明当前帧有富余时间，可以执行任务</span></span><br><span class="line">      <span class="comment">// 2、如果当前帧过期了，说明当前帧没有时间了，这里再看一下当前任务firstCallbackNode</span></span><br><span class="line">      <span class="comment">//是否过期，如果过期了也要执行任务；如果当前任务没过期，说明不着急，那就先不执行去</span></span><br><span class="line">      channel.port1.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">        <span class="keyword">var</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">        scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">        timeoutTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> currentTime = exports.unstable_now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> didTimeout = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// There's no time left in this idle period. Check if the callback has</span></span><br><span class="line">          <span class="comment">// a timeout and whether it's been exceeded.</span></span><br><span class="line">          <span class="keyword">if</span> (prevTimeoutTime !== <span class="number">-1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Exceeded the timeout. Invoke the callback even though there's no</span></span><br><span class="line">            <span class="comment">// time left.</span></span><br><span class="line">            <span class="comment">//任务过期</span></span><br><span class="line">            didTimeout = <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No timeout.</span></span><br><span class="line">            <span class="comment">//当前帧由于浏览器渲染等原因过期了，那就去下一帧再处理</span></span><br><span class="line">            <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">              <span class="comment">// Schedule another animation callback so we retry later.</span></span><br><span class="line">              isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">              requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Exit without invoking the callback.</span></span><br><span class="line">            scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">            timeoutTime = prevTimeoutTime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">          isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            prevScheduledCallback(didTimeout);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//7.animationTick是线索 计算帧过期时间并压缩帧</span></span><br><span class="line">      <span class="keyword">var</span> animationTick = <span class="function"><span class="keyword">function</span>(<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//有任务再进行递归，没任务的话不需要工作</span></span><br><span class="line">          <span class="comment">// Eagerly schedule the next animation callback at the beginning of the</span></span><br><span class="line">          <span class="comment">// frame. If the scheduler queue is not empty at the end of the frame, it</span></span><br><span class="line">          <span class="comment">// will continue flushing inside that callback. If the queue *is* empty,</span></span><br><span class="line">          <span class="comment">// then it will exit immediately. Posting the callback at the start of the</span></span><br><span class="line">          <span class="comment">// frame ensures it's fired within the earliest possible frame. If we</span></span><br><span class="line">          <span class="comment">// waited until the end of the frame to post the callback, we risk the</span></span><br><span class="line">          <span class="comment">// browser skipping a frame and not firing the callback until the frame</span></span><br><span class="line">          <span class="comment">// after that.</span></span><br><span class="line">          requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// No pending work. Exit.</span></span><br><span class="line">          isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// rafTime 就是 requestAnimationFrame 回调接收的时间</span></span><br><span class="line">        <span class="keyword">var</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime;</span><br><span class="line">        <span class="comment">//用连续的两次时间 被不断的压缩activeFrameTime</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          nextFrameTime &lt; activeFrameTime &amp;&amp;</span><br><span class="line">          previousFrameTime &lt; activeFrameTime</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nextFrameTime &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="comment">// Defensive coding. We don't support higher frame rates than 120hz.</span></span><br><span class="line">            <span class="comment">// If the calculated frame time gets lower than 8, it is probably a bug.</span></span><br><span class="line">            nextFrameTime = <span class="number">8</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// If one frame goes long, then the next one can be short to catch up.</span></span><br><span class="line">          <span class="comment">// If two frames are short in a row, then that's an indication that we</span></span><br><span class="line">          <span class="comment">// actually have a higher frame rate than what we're currently optimizing.</span></span><br><span class="line">          <span class="comment">// We adjust our heuristic dynamically accordingly. For example, if we're</span></span><br><span class="line">          <span class="comment">// running on 120hz display or 90hz VR display.</span></span><br><span class="line">          <span class="comment">// Take the max of the two in case one of them was an anomaly due to</span></span><br><span class="line">          <span class="comment">// missed frame deadlines.</span></span><br><span class="line">          activeFrameTime =</span><br><span class="line">            nextFrameTime &lt; previousFrameTime</span><br><span class="line">              ? previousFrameTime</span><br><span class="line">              : nextFrameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          previousFrameTime = nextFrameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算当前帧的截止时间，用开始时间加上每一帧的渲染时间</span></span><br><span class="line">        frameDeadline = rafTime + activeFrameTime;</span><br><span class="line">        <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">          isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//port2 负责发送数据</span></span><br><span class="line">          <span class="comment">//port2监听消息的回调来做任务调度的具体工作</span></span><br><span class="line">          port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 接收两个参数， flushwork 和 过期时间</span></span><br><span class="line">      requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class="line">        scheduledHostCallback = callback;</span><br><span class="line">        <span class="comment">// 过期时间</span></span><br><span class="line">        timeoutTime = absoluteTimeout;</span><br><span class="line">        <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// Don't wait for the next frame. Continue working ASAP, in a new event.</span></span><br><span class="line">          port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">          <span class="comment">// If rAF didn't already schedule one, we need to schedule a frame.</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> If this rAF doesn't materialize because the browser throttles, we</span></span><br><span class="line">          <span class="comment">// might want to still have setTimeout trigger rIC as a backup to ensure</span></span><br><span class="line">          <span class="comment">// that we keep performing work.</span></span><br><span class="line">          isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">          requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      cancelHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">        isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">        timeoutTime = <span class="number">-1</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exports.unstable_ImmediatePriority = ImmediatePriority;</span><br><span class="line">    exports.unstable_UserBlockingPriority = UserBlockingPriority;</span><br><span class="line">    exports.unstable_NormalPriority = NormalPriority;</span><br><span class="line">    exports.unstable_IdlePriority = IdlePriority;</span><br><span class="line">    exports.unstable_LowPriority = LowPriority;</span><br><span class="line">    exports.unstable_runWithPriority = unstable_runWithPriority;</span><br><span class="line">    exports.unstable_next = unstable_next;</span><br><span class="line">    exports.unstable_scheduleCallback = unstable_scheduleCallback;</span><br><span class="line">    exports.unstable_cancelCallback = unstable_cancelCallback;</span><br><span class="line">    exports.unstable_wrapCallback = unstable_wrapCallback;</span><br><span class="line">    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;</span><br><span class="line">    exports.unstable_shouldYield = unstable_shouldYield;</span><br><span class="line">    exports.unstable_continueExecution = unstable_continueExecution;</span><br><span class="line">    exports.unstable_pauseExecution = unstable_pauseExecution;</span><br><span class="line">    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表实现"><a href="#双向链表实现" class="headerlink" title="双向链表实现"></a>双向链表实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.双向链表是指每个节点有previous和next两个属性来分别指向前后两个节点。</span></span><br><span class="line"><span class="comment">// 2.循环的意思是，最后一个节点的next指向第一个节点，</span></span><br><span class="line"><span class="comment">// 下面假设有一群人需要按照年龄进行排队，小孩站前边，大人站后边。</span></span><br><span class="line"><span class="comment">// 在一个过程内会不断有人过来，我们需要把他插到正确的位置。删除的话只考虑每次把排头的人给去掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//person的类型定义</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">  name: string; <span class="comment">//姓名</span></span><br><span class="line">  age: number; <span class="comment">//年龄，依赖这个属性排序</span></span><br><span class="line">  next: Person; <span class="comment">//紧跟在后面的人,默认是null</span></span><br><span class="line">  previous: Person; <span class="comment">//前面相邻的那个人,默认是null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> firstNode = <span class="literal">null</span>; <span class="comment">//一开始链表里没有节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertByAge</span>(<span class="params">newPerson: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((firstNode = <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="comment">//如果 firstNode为空，说明newPerson是第一个人，</span></span><br><span class="line">    <span class="comment">//把它赋值给firstNode，并把next和previous属性指向自身，自成一个环。</span></span><br><span class="line">    firstNode = newPerson.next = newPerson.previous = newPerson;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//队伍里有人了，新来的人要找准自己的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> next = <span class="literal">null</span>; <span class="comment">//记录newPerson插入到哪个人前边</span></span><br><span class="line">    <span class="keyword">var</span> person = firstNode; <span class="comment">// person 在下边的循环中会从第一个人开始往后找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (person.age &gt; newPerson.age) &#123;</span><br><span class="line">        <span class="comment">//如果person的年龄比新来的人大，说明新来的人找到位置了，他恰好要排在person的前边，结束</span></span><br><span class="line">        next = person;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//继续找后面的人</span></span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node !== firstNode); <span class="comment">//这里的while是为了防止无限循环，毕竟是环形的结构</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//找了一圈发现 没有person的age比newPerson大，说明newPerson应该放到队伍的最后,也就是说newPerson的后面应该是firstNode。</span></span><br><span class="line">      next = firstNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next === firstNode) &#123;</span><br><span class="line">      <span class="comment">//找第一个的时候就找到next了，说明newPerson要放到firstNode前面，这时候firstNode就要更新为newPerson</span></span><br><span class="line">      firstNode = newPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是newPerson的插入操作，给next及previous两个人的前后链接都关联到newPerson</span></span><br><span class="line">    <span class="keyword">var</span> previous = next.previous;</span><br><span class="line">    previous.next = next.previous = newPerson;</span><br><span class="line">    newPerson.next = next;</span><br><span class="line">    newPerson.previous = previous;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFirstPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (firstNode === <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">//队伍里没有人，返回</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> next = firstNode.next; <span class="comment">//第二个人</span></span><br><span class="line">  <span class="keyword">if</span> (firstNode === next) &#123;</span><br><span class="line">    <span class="comment">//这时候只有一个人</span></span><br><span class="line">    firstNode = <span class="literal">null</span>;</span><br><span class="line">    next = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastPerson = firstNode.previous; <span class="comment">//找到最后一个人</span></span><br><span class="line">    firstNode = lastPerson.next = next; <span class="comment">//更新新的第一人</span></span><br><span class="line">    next.previout = lastPerson; <span class="comment">//并在新的第一人和最后一人之间建立连接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Fiber</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】理解Dom-diff</title>
    <url>/2019/06/23/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%90%86%E8%A7%A3Dom-diff/</url>
    <content><![CDATA[<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>比较两棵DOM树的差异是 Virtual Dom 算法最核心的部分， 这也是所谓的Virtual Dom的 diff算法。 两个树的完全的diff算法是一个时间复杂度为 O（n^3） 的问题。 但是在前端当中， 你很少会跨越层级地移动Dom元素。 所以 Virtual Dom只会对同一个层级的元素进行对比。 下面的div指挥和同一层级的div对比， 第二层级的智慧跟第二层级对比。 这样算法复杂度就可以达到O(n)。</p>
<p><img src="http://img.nixiaolei.com/2019-06-23-21-55-03.png" alt="2019-06-23-21-55-03"></p>
<h2 id="对比方式"><a href="#对比方式" class="headerlink" title="对比方式"></a>对比方式</h2><p>实际的代码中， 会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记， 在深度优先遍历的时候， 每遍历到一个节点就把该节点和新的树进行对比。 如果有差异的话就记录到一个对象里面。</p>
<p><img src="http://img.nixiaolei.com/2019-06-23-21-57-26.png" alt="2019-06-23-21-57-26"></p>
<h2 id="实践一下"><a href="#实践一下" class="headerlink" title="实践一下"></a>实践一下</h2><p>所谓的<code>dom-diff</code> 抛去具体的dom处理逻辑， 其核心思想还是比较简单的， 其实就是一个深度优先遍历。</p>
<p>我们就来尝试实现一下一个简单的dom-diff</p>
<p>首先</p>
<h3 id="模拟dom结构"><a href="#模拟dom结构" class="headerlink" title="模拟dom结构"></a>模拟dom结构</h3><p>以面向对象的编程方式， 构建出一个dom节点所必要的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, props, children) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再实现一个创建虚拟dom节点的快捷方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(type, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有了创建方法， 那现在就可以试着创建几个dom了，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> virtualDom1 = createElement(<span class="string">"ul"</span>, &#123;</span><br><span class="line">  class: "list"</span><br><span class="line">&#125;, [</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"1"</span>]),</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"2"</span>]),</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"3"</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> virtualDom2 = createElement(<span class="string">"ul"</span>, &#123;</span><br><span class="line">  class: "list-new"</span><br><span class="line">&#125;, [</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"a"</span>]),</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"444"</span>]),</span><br><span class="line">  createElement(<span class="string">"li"</span>, &#123; <span class="attr">class</span>: <span class="string">"item"</span>&#125;, [<span class="string">"c"</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>这是两串模拟<code>ul &gt; li</code>的代码， 相信聪明的你可以看的出来</p>
<h3 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h3><p>既然构建好了简单的虚拟dom， 接下来要做的无非就是比对了</p>
<p>在对比差异的过程中， 我们还要记录最终的差异结果， 把当前修复批次记录下来， 用于之后同一处理</p>
<p>开始比对之前， 我们要先搞清楚整体的逻辑， 我们应该比对哪些差异？</p>
<ol>
<li>标签类型的差异， 有可能是<code>p</code>， 有可能是<code>div</code>， 还有可能是纯文本</li>
<li>dom的属性改变了 ， 有可能是class变了， 有可能是自定义属性变了</li>
<li>dom的内容改变了， 这就是最基本的变化了， dom的内容发生了改变</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'./util.js'</span></span><br><span class="line"><span class="comment">// 生成的补丁包</span></span><br><span class="line"><span class="keyword">let</span> patchs = &#123;&#125;</span><br><span class="line"><span class="comment">// 记录</span></span><br><span class="line"><span class="keyword">let</span> globalIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dom-diff的主要入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  dfswalk(oldTree, newTree, globalIndex)</span><br><span class="line">  <span class="keyword">return</span> patchs</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度优先遍历 -- 递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfswalk</span>(<span class="params">oldTree, newTree, globalIndex</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 记录当前批次的修改队列</span></span><br><span class="line">  <span class="keyword">let</span> currentPatchs = []</span><br><span class="line">  <span class="comment">// 如果旧节点是文本</span></span><br><span class="line">  <span class="keyword">if</span>( _.isString(oldTree) ) &#123;</span><br><span class="line">    <span class="comment">// 如果新树也是字符串 并且 但是不和新树相同</span></span><br><span class="line">    <span class="keyword">if</span>(_.isString(newTree) &amp;&amp; oldTree !== newTree) &#123;</span><br><span class="line">      <span class="comment">// 将当前的更改追加入当前需要修改的队列中</span></span><br><span class="line">      currentPatchs.push(&#123;</span><br><span class="line">        type: <span class="string">"TEXT"</span>,</span><br><span class="line">        text: newTree</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类型相同的</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>( oldTree.type === newTree.type ) &#123;</span><br><span class="line">    <span class="comment">// 调用对比属性的函数</span></span><br><span class="line">    diffProps(oldTree.props, newTree.props)</span><br><span class="line">    <span class="comment">// 比节点 =&gt; 尾调用优化</span></span><br><span class="line">    diffChildren(oldTree.children, newTree.children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果本次检测到了修改 把每一次diff的结果放到patchs</span></span><br><span class="line">  <span class="keyword">if</span>(currentPatchs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 记录到对应的节点上sdcxz</span></span><br><span class="line">    patchs[globalIndex] = currentPatchs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两个dom的 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对比props</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责循环新旧domde的子节点， 以旧节点的索引去匹配去匹配相应位置的新节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildrens, newChildrens</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历旧dom ,对比相同索引的新dom</span></span><br><span class="line">  oldChildrens.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 被循环后又去调用新旧dom的比对</span></span><br><span class="line">    dfswalk(child, newChildrens[index], ++globalIndex)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  diff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-对dom-diff的优化"><a href="#Vue-对dom-diff的优化" class="headerlink" title="Vue 对dom-diff的优化"></a>Vue 对dom-diff的优化</h2><p>vue 在对比 oldTree 和 newTree 时会分别给新旧树的对比中会分配两个指针，分别是<code>oldStart</code>、<code>oldEnd</code> 、 <code>newStart</code>、<code>newEnd</code> ， 然后 start 指针和 end 指针都会在每次对比后相互靠近， 直至相遇， 具体对比规则如下</p>
<p><img src="http://img.nixiaolei.com/2019-06-29-21-05-31.png" alt="2019-06-29-21-05-31"></p>
<ol>
<li>先对比头头、 尾尾是否一致</li>
<li>对比头尾、 尾头， 如果相同，则头尾先互相拷贝插入， 然后删除旧的</li>
<li>如果 <code>newStart</code> 和 <code>oldStart</code> 相对比， <code>newStart</code>有但<code>oldStart</code>没有此节点， 则将 <code>newStart</code> 对应的节点插入至 <code>oldStart</code>节点的前面， 并且将 <code>newStart</code>指针前进一格， 而<code>oldStart</code>指针不动， 直至找到匹配<br><img src="http://img.nixiaolei.com/2019-06-29-20-58-31.png" alt="2019-06-29-20-58-31"></li>
<li>如果<code>oldEnd</code> 和 newEnd 不同时， 则将oldEnd 的元素先打上删除标记， 然后前进一格，  newEnd 元素则停留在原处，直至找到匹配<br><img src="http://img.nixiaolei.com/2019-06-29-21-22-26.png" alt="2019-06-29-21-22-26"></li>
<li>对比阶段， 对比类型， 如果类型不同就直接放弃没必要继续对比了</li>
</ol>
<p>最终start 与 end 交汇后， 遍历一遍 oldTree ,将标记为删除的节点删除掉</p>
<h3 id="Vue-为什么需要key"><a href="#Vue-为什么需要key" class="headerlink" title="Vue 为什么需要key"></a>Vue 为什么需要key</h3><p>首先， 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>
<p>并且， diff算法就可以快速切正确的找到此节点， 找到正确的位置插入新的节点，</p>
<p>降低节点查找时间， 当有插入节点需要时， 有Key 的话就可以 类似于索引访问的形式直达目标节点，  而不是遍历一遍所有节点来查找目标节点</p>
<p><strong>利用key的小技巧</strong><br>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:</p>
<p>完整地触发组件的生命周期钩子<br>触发过渡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>key是为了降低diff时的节点查找复杂度， 并且如果节点的key都不相同或者是说key都变了，那就直接判定为dom发生变化， 渲染新的</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DomDiff</tag>
      </tags>
  </entry>
  <entry>
    <title>【英语学习】基础语法</title>
    <url>/2019/06/22/%E3%80%90%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>英语语法分为：</p>
<ol>
<li>句法部分</li>
<li>语法部分</li>
</ol>
<h2 id="句法部分"><a href="#句法部分" class="headerlink" title="句法部分"></a>句法部分</h2><p>十大词类、 两大句型、八大句子成分、主从句单复词</p>
<h3 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h3><blockquote>
<p>名词、 动词、形容词、副词、数词、代词、语气词、感叹词、 介词、 连词</p>
</blockquote>
<ol>
<li>名词<blockquote>
<p>事物的名称叫名词</p>
</blockquote>
</li>
</ol>
<p>万事万物–实体， 非实体都有其名</p>
<ol start="2">
<li>动词<blockquote>
<p>动作的名称就叫动词</p>
</blockquote>
</li>
</ol>
<p>表示事物之间的变化或自身内在的变化的词就是动词。</p>
<ol start="3">
<li>形容词<blockquote>
<p>形容名词的词， 叫形容词</p>
</blockquote>
</li>
</ol>
<p>名词太单调了， 需要形容词围绕名词进行各种修饰， 如形状、色彩、大小、美丑等。</p>
<ol start="4">
<li>副词<blockquote>
<p>形容动词的词， 就叫副词</p>
</blockquote>
</li>
</ol>
<p>动词太单调了， 需要副词围绕动词进行各种修饰， 如描绘动作的程度、 频率、 方式、 时间等</p>
<ol start="5">
<li>数次<blockquote>
<p>给名词计数的词， 就叫数词</p>
</blockquote>
</li>
</ol>
<p>分为基数词， 1、2、3、4、5 第1、第2、第3、第4、第5等</p>
<ol start="6">
<li>代词<blockquote>
<p>代替名词的词就叫代词</p>
</blockquote>
</li>
</ol>
<p>如： 你、我、她、它、你们的、 我们的、他们的等等</p>
<ol start="7">
<li>介词<blockquote>
<p>表示两个名词之间时空关系的词， 就叫介词</p>
</blockquote>
</li>
</ol>
<p>如 “鸡蛋在(in)篮子里” “鸡蛋在(on)桌子上” “鸡蛋在(under)桌子下”</p>
<ol start="8">
<li>冠词<blockquote>
<p>特指或泛指某一名词事物的就叫冠词</p>
</blockquote>
</li>
</ol>
<p>如： a/an不定冠词， the 定冠词</p>
<ol start="9">
<li><p>连词</p>
<blockquote>
<p>连接两个性质相同的词、 短句、 句子的词叫连词</p>
</blockquote>
</li>
<li><p>叹词<br>语气助词叫叹词</p>
</li>
</ol>
<p>这十大词类又可以分为</p>
<p><code>名词类</code>， 即以名词为核心的词类。<br>  如： 名词、 代词、 形容词、 数词、 冠词、介词</p>
<p>和<code>动词类</code>:<br>  如:  动词、 副词</p>
<h3 id="动词原形"><a href="#动词原形" class="headerlink" title="动词原形"></a>动词原形</h3><blockquote>
<p>动词原形是不含有<code>时间信息</code>也不含有<code>状态信息</code>的动词的本源， 是脱离了时空概念的动作本身。</p>
</blockquote>
<p>下图中， 中间这个<code>eat</code> 就是动词原形<br><img src="http://img.nixiaolei.com/2019-06-23-00-19-37.png" alt="2019-06-23-00-19-37"></p>
<p>这就像一粒种子可以变换为4种状态</p>
<ol>
<li><p>非谓语动词<br>有状态但是没有时间</p>
</li>
<li><p>谓语动词<br>有时间有状态</p>
</li>
</ol>
<p>一句话解释:</p>
<blockquote>
<p>如果以人作为比喻， 那么动词原形是受精卵， 非谓语动词是胎儿</p>
</blockquote>
<p>动词原形只是个概念， 它不能出现于任何句子， 任何短语之中， 动词原形只能作为词典条目</p>
<h3 id="动词有什么“态”"><a href="#动词有什么“态”" class="headerlink" title="动词有什么“态”"></a>动词有什么“态”</h3><blockquote>
<p>动词的“态”就是动作发展的“阶段”</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-06-23-11-36-32.png" alt="2019-06-23-11-36-32"></p>
<p><img src="http://img.nixiaolei.com/2019-06-23-11-45-28.png" alt="2019-06-23-11-45-28"></p>
<p>动词原形穿上“态”这件衣服就成了非谓语动词</p>
<p><strong>给非谓语动词穿上时态这件衣服</strong></p>
<p><img src="http://img.nixiaolei.com/2019-06-23-11-48-52.png" alt="2019-06-23-11-48-52"></p>
<h3 id="谓语动词"><a href="#谓语动词" class="headerlink" title="谓语动词"></a>谓语动词</h3><p>英语的谓语动词， 第一个词一定表达时间， 最后一个词一定表达状态，</p>
<p>如:<code>is eating</code>， <code>is</code>就是时间， <code>eating</code> 就是状态</p>
<h2 id="语法部分"><a href="#语法部分" class="headerlink" title="语法部分"></a>语法部分</h2><p>谓语动词的变化、 非谓语动词的变化</p>
<h2 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h2><p>英语到底有多少种时态</p>
<p><img src="http://img.nixiaolei.com/2019-06-23-18-23-07.png" alt="2019-06-23-18-23-07"></p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Node】了解koa源码</title>
    <url>/2019/06/16/%E3%80%90Node%E3%80%91%E4%BA%86%E8%A7%A3koa%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>想要查看源码， 首先我们<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i Koa -S</span><br></pre></td></tr></table></figure></p>
<p>打开<code>node_modules</code>， 找到koa目录下的application 文件，</p>
<p>我们可以看到平时使用的 app 及其相关方法就在这里, 删除了不必要的代码后， 我们看看简易版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      <span class="keyword">this</span>[util.inspect.custom] = <span class="keyword">this</span>.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toJSON() &#123;</span><br><span class="line">    <span class="keyword">return</span> only(<span class="keyword">this</span>, [</span><br><span class="line">      <span class="string">'subdomainOffset'</span>,</span><br><span class="line">      <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="string">'env'</span></span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inspect() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toJSON();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  callback() &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createContext(req, res) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">    <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">    <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">    context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">    context.req = request.req = response.req = req;</span><br><span class="line">    context.res = request.res = response.res = res;</span><br><span class="line">    request.ctx = response.ctx = context;</span><br><span class="line">    request.response = response;</span><br><span class="line">    response.request = request;</span><br><span class="line">    context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">    context.state = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default error handler.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Error&#125; err</span></span><br><span class="line"><span class="comment">   * @api private</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  onerror(err) &#123;</span><br><span class="line">    <span class="keyword">const</span> msg = err.stack || err.toString();</span><br><span class="line">    <span class="built_in">console</span>.error(msg.replace(<span class="regexp">/^/gm</span>, <span class="string">'  '</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">  <span class="keyword">const</span> code = ctx.status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="灵魂部分"><a href="#灵魂部分" class="headerlink" title="灵魂部分"></a>灵魂部分</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="comment">// 检测中间件类型</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>) <span class="comment">// 执行整这个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      index = i</span><br><span class="line">      <span class="comment">// 取出当前中间件</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="comment">// 如果索引跟中间件长度一样了,实际上就等于访问完了, fn是空,  next 也是空, 这里应该是保证一下next 确实不存在</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="comment">// 最后一个中间件没有 next 就熄火了</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// fn 就是中间件,  中间件接收两个参数, context 和 Next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出的一个整体结构就是<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">      <span class="built_in">Promise</span>.resolve() <span class="comment">// 中间件全部执行完毕</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.nixiaolei.com/2019-06-16-23-33-51.png" alt="2019-06-16-23-33-51"></p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>Koa</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】递归、尾递归与尾调用</title>
    <url>/2019/06/16/%E3%80%90JS%E3%80%91%E9%80%92%E5%BD%92%E3%80%81%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%B0%BE%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>所谓的尾调用， 尾调用是我们平时实现递归操作的一种方式, 通过在函数末尾调用另一个函数， 来抹除上一个函数的堆栈记录， 可以理解为是一种任务承接的方式</p>
<p>demo:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">index, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index-- === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  g(index, total + index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"> index, total </span>) </span>&#123;</span><br><span class="line">  f( index, total )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>尾递归和普通递归的区别就是， 尾递归的递归方式是在函数最后一步操作调用自身， 并将本轮计算结果以参数形式传入</p>
<p>demo:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index-- === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loop(index, total + index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop(<span class="number">100</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>在ES6中， 我们将迎来尾递归优化， 通过尾递归优化， javascript代码在解释成机器码的时候， 将会向while看齐， 也就是说， 同时拥有数学表达能力和<code>while</code>的效能。</p>
<p>ES6的“尾调用优化”的原理就是覆盖掉自身的函数执行记录， 也就是将递归变为循环， 只保存一个调用记录，这样就不会发生爆栈的情况了</p>
<h3 id="浏览器的实现情况"><a href="#浏览器的实现情况" class="headerlink" title="浏览器的实现情况"></a>浏览器的实现情况</h3><p>虽然是ES6的规范， 浏览器也实现了， 但实际上平时使用时“尾调用优化”是默认关闭的。 为什么！因为浏览器不敢开哦。 因为一旦开了尾调用优化， 就等于放弃了存留函数的堆栈信息， 当开发者调错时会十分困难， 找不到正确的堆栈信息， 当然可以利用js的元编程强行开启</p>
<h3 id="其他避免爆栈手段"><a href="#其他避免爆栈手段" class="headerlink" title="其他避免爆栈手段"></a>其他避免爆栈手段</h3><ul>
<li>使用<code>蹦床函数</code>， 将递归拉平</li>
<li>直接将递归改写成循环</li>
<li>使用元编程强行开启浏览器的“尾递归优化”</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>尾递归</tag>
        <tag>尾调用</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】什么是AO-VO</title>
    <url>/2019/06/10/%E3%80%90JS%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AFAO-VO-GO/</url>
    <content><![CDATA[<h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><blockquote>
<p>glbal Context 全局执行上下文</p>
</blockquote>
<p>首先在js执行的时候会创建一个GO， 被压入 ESC Stack 栈底</p>
<h2 id="EC"><a href="#EC" class="headerlink" title="EC"></a>EC</h2><blockquote>
<p>execution 执行上下文</p>
</blockquote>
<p>在每个函数执行的时候会创建一个EC（执行上下文）</p>
<p>在函数执行上下文中， 还会有两个东西被创建出来： AO、VO</p>
<h3 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h3><blockquote>
<p>Activation Object 活动对象</p>
</blockquote>
<p>AO是在函数执行的阶段</p>
<ol>
<li>arguments的callee length</li>
<li>内部定义的函数</li>
<li>绑定对应环境变量</li>
<li>内部定义的变量</li>
</ol>
<p>AO的阶段又可以细分为:</p>
<ol>
<li>定义阶段</li>
<li>执行阶段</li>
</ol>
<h4 id="浏览器解析阶段"><a href="#浏览器解析阶段" class="headerlink" title="浏览器解析阶段"></a>浏览器解析阶段</h4><p>这就是浏览器解析js的时候， 当v8拿到函数的时候， 都给你先编译成比较慢的字节码， 然后对字节码进行优化， 接着经过<code>静态分析</code>进行本地替换那些频繁使用到的字节码段， 替换成优化后的字节码，为什么不都进行优化， 因为优化后的字节码体积会比较大。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>创建作用域链（Scope Chain）<br>创建变量，函数和参数。<br>定义<code>this</code>但不确认</p>
<p>让我们通过这段代码看一下AO的具体情况:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>那此时这个 test 函数的AO情况如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EC(test) = &#123;</span><br><span class="line">  <span class="comment">// 自己维护的scopeChain 作用域链</span></span><br><span class="line">  scopeChain: &#123; Scope &#125;, <span class="comment">// 指向下面的Scope</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预解析的原理</span></span><br><span class="line">  AO(test): &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: undefind,</span><br><span class="line">    c: undefind,</span><br><span class="line">    e: undefind</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">this</span>: <span class="string">'先定义但不确认'</span>,</span><br><span class="line">  Scope: [AO, glbalContext.vo]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EC(test) = &#123;</span><br><span class="line">  scopeChain: &#123; Scope &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预解析的原理</span></span><br><span class="line">  AO(test): &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      <span class="number">0</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="number">1</span>: <span class="number">22</span>,</span><br><span class="line">      length: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: undefind,</span><br><span class="line">    c: undefind,</span><br><span class="line">    e: undefind</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">this</span>: <span class="string">'this指向函数执行栈栈顶'</span>,</span><br><span class="line">  Scope: [AO, glbalContext.vo]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><blockquote>
<p>Variable object 变量对象</p>
</blockquote>
<p>每个函数都有自己的VO对象， 存储着这些</p>
<ol>
<li>函数声明（不包含函数表达式）</li>
<li>函数的形参</li>
<li>变量的声明</li>
</ol>
<p>总的来说篇， VO要比AO的范围大得多， VO是负责把各个调用的函数串联起来的。 他是外部的， 而AO是函数自身内部的</p>
<p>距离， 当执行 <code>fun1</code>:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">VO(fun1) = AO <span class="comment">// 执行到fun1 时可以在VO中的fun1就是此时的AO</span></span><br></pre></td></tr></table></figure></p>
<p>又或者再举个例子，有这样一段代码要执行<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">30</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时我们来看一下VO的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VO中的 GO </span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  test: <span class="string">'&lt;reference to function&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VO 中的 test函数</span></span><br><span class="line"></span><br><span class="line">VO(test) = &#123;</span><br><span class="line">  x: <span class="number">30</span>, <span class="comment">// 传入的参数</span></span><br><span class="line">  b: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面的这些也就构成了 ECS Stack 函数执行栈</p>
<h3 id="ESC-Stack"><a href="#ESC-Stack" class="headerlink" title="ESC Stack"></a>ESC Stack</h3><blockquote>
<p>executions statck  执行上下文栈</p>
</blockquote>
<p>很多个函数存在一起的时候会存在一个ESC Stack</p>
<p>所谓的 stack 它就是一个栈， 先进入</p>
<p>当js开始运行时就创建一个 <code>globalContext</code> 压入栈底， 也就是单体内置对象<code>Global</code>, 在浏览器中通常是 <code>window</code></p>
<p>被压入栈的情况大致如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStatck = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当一段代码执行了好多函数时， 比如这样一段代码:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun2()</span><br><span class="line">&#125;</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure></p>
<p>实际入栈过程是这样的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStatck = [</span><br><span class="line">  fun3,</span><br><span class="line">  fun2,</span><br><span class="line">  fun1,</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当一个函数入栈， 它所属的变量也随之入栈， 当函数出栈， 变量也就跟着出栈了， 每个函数都会拥有各自的 EC（函数执行上下文）， 也就有各自的 AO、VO, </p>
<blockquote>
<p>你肯定会疑惑闭包呢， 函数出栈了， 那闭包去哪了<br>其实，js的闭包是存在堆里的， 跟普通函数不一样， 所以不会跟着出栈函数一起被回收</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>js执行机制</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】递归算法</title>
    <url>/2019/06/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>核心思想：通过重复将问题分解为同类的子问题而解决问题的方法。</li>
<li>特点：<ul>
<li>函数可以通过调用自身来进行递归</li>
<li>递归可以完全取代循环</li>
</ul>
</li>
<li>递归由下面两部分组成：<ul>
<li>（1）递归主体，就是要循环解决问题的代码</li>
<li>（2）递归的跳出条件，递归不能一直递归下去，需要完成一定条件后跳出</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】枚举算法基本概念</title>
    <url>/2019/06/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>核心思想：枚举所有的可能。</li>
<li>本质：就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件<ul>
<li>(1)可预先确定候选答案的数量；</li>
<li>(2)候选答案的范围在求解之前必须有一个确定的集合。</li>
</ul>
</li>
<li>特点：<ul>
<li>枚举算法简单粗暴，暴力的枚举所有可能，尽可能地尝试所有的方法。</li>
<li>速度可能很慢，却是我们最应该优先考虑的。</li>
<li>实现最简单，并且得到的结果总是正确的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】什么是算法</title>
    <url>/2019/06/08/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>算法是完成某个特定任务的过程。  通常数据结构作为工具来辅助进行算法， 所以有了一个流传甚广的公式： 程序 = 数据结构 + 算法</p>
<ul>
<li>算法不是数学， 但是可以用数学来描述</li>
<li>我们要做一件事情， 整个过程本身就是算法</li>
<li>我们最常用的增删改查是算法的一部分</li>
<li>算法可以用自然语言、 流程图、 伪代码和计算机语言等手段来表示</li>
<li>在面向对象语言中， 算法通常通过类的方法实现</li>
</ul>
<h2 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h2><p>算法的五大特征：</p>
<ul>
<li>有穷性： 算法必须能在执行有限个步骤后终止</li>
<li>确切性： 每一步骤必须由确切的定义</li>
<li>输入项： 有0个或多个输入， 用来规定初始情况， 所谓0 个输入是指算法本身定出了初始条件</li>
<li>输出项： 有一个或多个输出， 是对输入数据处理后的结果。 没有输出的算法毫无意义</li>
<li>可行性： 算法执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，每个计算步骤都可以在有限时间内完成（也称之为有效性。）</li>
</ul>
<h2 id="如何衡量算法的好坏"><a href="#如何衡量算法的好坏" class="headerlink" title="如何衡量算法的好坏"></a>如何衡量算法的好坏</h2><ul>
<li>算法的好坏主要通过算法复杂度来衡量<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
</li>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
</ul>
<h2 id="常见的复杂度"><a href="#常见的复杂度" class="headerlink" title="常见的复杂度"></a>常见的复杂度</h2><ul>
<li>常数阶 O(1)</li>
<li>对数阶 O(logN)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(nlogN)</li>
<li>平方阶 O(n^2)</li>
<li>立方阶 O(n^3)</li>
<li>k次方阶 O(n ^ k)</li>
<li>指数阶O(2 ^ n)</li>
</ul>
<p><img src="http://img.nixiaolei.com/fuzadu.png" alt="复杂度"></p>
<h2 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h2><blockquote>
<p>logN 就是类似循环操作的逆运算，每次计算都将计算量减少一半</p>
</blockquote>
<ul>
<li>随着问题规模 n 的不断增加， 时间复杂度不断增大， 算法的执行效率越低</li>
<li>一般做算法复杂度分析的时候， 遵循下面的技巧:<ul>
<li>有几重循环， 一般来说就是O(n), 两重就是O（n^2）, 依此类推</li>
<li>如果有二分， 则为O（logN）</li>
<li>保留最高项， 去除常数项</li>
</ul>
</li>
</ul>
<p>计算例子<br><img src="http://img.nixiaolei.com/2019-06-08-23-13-24.png" alt="2019-06-08-23-13-24"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】什么是图</title>
    <url>/2019/06/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE/</url>
    <content><![CDATA[<p>由顶点的集合（不能是空集） 和边的集合组成的结构， 表现的是多对多的关系</p>
<ul>
<li>数学基础是： 图论</li>
<li>几个基本概念：<ul>
<li>顶点（在树里叫节点）</li>
<li>边</li>
<li>权</li>
<li>有向图和无向图</li>
</ul>
</li>
</ul>
<p><img src="http://img.nixiaolei.com/tu.png" alt="图"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】什么是树</title>
    <url>/2019/06/02/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91/</url>
    <content><![CDATA[<p>树是由若干个有限节点组成的一个具有层次关系的集合</p>
<h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><ul>
<li>数学基础是: 图论</li>
<li>一棵树中每两个点之间都有且只有一条路</li>
<li>一颗有N个点的树有N-1条边</li>
</ul>
<h2 id="结构与名称"><a href="#结构与名称" class="headerlink" title="结构与名称"></a>结构与名称</h2><p><img src="http://img.nixiaolei.com/structure-tree.png" alt="树的结构图"></p>
<p>像图中的圈我们称之为“节点”， 节点与节点之间的线称之为“边”， 最起始的节点叫“根”</p>
<p>一个节点下面的节点成为该节点的子节点， 该节点是其子节点的父节点</p>
<p>节点的层级用“深”来表示， 并且以0开始计数</p>
<p>当节点不再分叉时， 末尾的节点称为“叶子节点”</p>
<p>一个节点的子节点数量称为“度”， 如果一个节点有3个子节点， 那么它的度为3， 当度为0时就是叶子节点</p>
<p>一个节点到另一个节点之间的连线 称为“路径”</p>
<h2 id="树和非树的典型"><a href="#树和非树的典型" class="headerlink" title="树和非树的典型"></a>树和非树的典型</h2><blockquote>
<p>空树是指，有了树的结构， 但是还没有填充节点</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/treeAndNoTree.png" alt="树和非树"></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><blockquote>
<p>树的遍历分为，两大类， 四小类</p>
</blockquote>
<p>按照某种规则， 不重复地访问某种树的所有节点</p>
<ul>
<li>先序遍历(深度优先)</li>
<li>中序遍历(深度优先)</li>
<li>后续遍历(深度优先)</li>
<li>层序遍历(广度优先)</li>
</ul>
<blockquote>
<p>先、 中、后都是针对的根节点来说的， 并且树是一种自相似的结构， 可以采用递归， 所以比较好记忆</p>
</blockquote>
<h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><blockquote>
<p>左、中、右</p>
</blockquote>
<p>优先访问根节点， 然后访问其左子树， 如果左子节点还有其左子节点， 再继续往下访问其左子节点， 直至没有， 然后访问其节点的父节点， 最后访问其父节点的右子节点， 就这样一层一层向上，直至根节点的整个左子树遍历完， 去对右子树做同样的操作</p>
<p><img src="http://img.nixiaolei.com/tree-first-order.png" alt="先序遍历"></p>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h3><blockquote>
<p>中、左、右</p>
</blockquote>
<p>优先访问左子树， 然后访问根节点，  最后访问右节点</p>
<p><img src="http://img.nixiaolei.com/tree-zhong-order.png" alt="中序遍历"></p>
<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><blockquote>
<p>左、 右、 中</p>
</blockquote>
<p>优先访问左子树、 然后访问右子树， 最后访问根节点</p>
<p><img src="http://img.nixiaolei.com/tree-after-order.png" alt="后序遍历"></p>
<h3 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h3><p>广度优先逐层访问节点， 直至该层没有， 然后再往下扎</p>
<p><img src="http://img.nixiaolei.com/cengxu.png" alt="层序遍历"></p>
<h2 id="树的衍生"><a href="#树的衍生" class="headerlink" title="树的衍生"></a>树的衍生</h2><p>无序树: 树中任意节点的子节点之间没有顺序关系， 这种树称为无序树， 也称为自由树</p>
<p>有序树： 树中任意节点的子结点之间有顺序关系</p>
<p>二叉树： 每个节点最多含有两个子树的树称为二叉树</p>
<p>完全二叉树： 除了最后一层， 其他各层节点数都达到最大</p>
<p>满二叉树： 每一层上的节点数都是最大节点数</p>
<p>霍夫曼树： 带权路径最短的二叉树， 也叫最优二叉树</p>
<h2 id="排序算法的复杂度与稳定性"><a href="#排序算法的复杂度与稳定性" class="headerlink" title="排序算法的复杂度与稳定性"></a>排序算法的复杂度与稳定性</h2><p><img src="http://img.nixiaolei.com/2019-06-09-21-32-43.png" alt="2019-06-09-21-32-43"></p>
<h2 id="关于查找算法"><a href="#关于查找算法" class="headerlink" title="关于查找算法"></a>关于查找算法</h2><p><img src="http://img.nixiaolei.com/2019-06-09-21-36-02.png" alt="2019-06-09-21-36-02"> </p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表之'串'</title>
    <url>/2019/06/02/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B-%E4%B8%B2/</url>
    <content><![CDATA[<p>比如： 字符串、 字节流</p>
<ol>
<li><p>串的概念<br>字符串简称串，是一种特殊的线性表，它的数据元素仅由一个字符组成。</p>
</li>
<li><p>串的定义<br>串(String)是由零个或多个字符组成的有限序列，又称字符串。</p>
</li>
</ol>
<p><img src="http://img.nixiaolei.com/jiegou-chuan.png" alt="数据结构"></p>
<p>串的特殊在于， 在一个大的线性表中对一个小线性表操作</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【canvas】如何处理Retina屏模糊问题</title>
    <url>/2019/05/21/%E3%80%90canvas%E3%80%91%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Retina%E5%B1%8F%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="什么是Retina屏？"><a href="#什么是Retina屏？" class="headerlink" title="什么是Retina屏？"></a>什么是Retina屏？</h2><p>所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto Aura上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。</p>
<h2 id="canvas在Retina-屏幕模糊怎么办"><a href="#canvas在Retina-屏幕模糊怎么办" class="headerlink" title="canvas在Retina 屏幕模糊怎么办"></a>canvas在Retina 屏幕模糊怎么办</h2><blockquote>
<p>DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵数码影像，指每一英寸长度中，取样、可显示或输出点的数目。</p>
</blockquote>
<p>利用获取设备的dpi, 将canvas 画布扩大至dpi的倍数， 然后将其缩小， 就可以得到清晰的canvas 效果</p>
]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】如何测试Js代码性能</title>
    <url>/2019/05/11/%E3%80%90JS%E3%80%91%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95Js%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>使用 benchmark.js 进行前端代码基准测试</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】V8引擎里for和forEach</title>
    <url>/2019/05/11/%E3%80%90JS%E3%80%91V8%E5%BC%95%E6%93%8E%E9%87%8Cfor%E5%92%8CforEach/</url>
    <content><![CDATA[<p>一般是for 循环比较快,  但是V8中每个数组自带的方法一定程度上是对数组数量级的优化, 在一定数量的数据下, forEach 要优于 for 循环, 所以看场景选择吧, 具体请看v8源码</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】webpack + ts + antd 按需加载无效处理</title>
    <url>/2019/05/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91webpack-ts-antd-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%A0%E6%95%88%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>webpack加 babel 本来搭配 babel-plugin-import 可以实现插件的按需引入， 但是时代在变化啊， 现在流行ts 了， 你一定会想在你的项目中加入它， 你也一定会搜索到 ‘ts-loader’ 的种种，  但效果不尽如人意， 使用了’ts-loader’ 之后， 你会发现， 按需引入怎么配置都失败了，</p>
<p>于是你一定会尝试这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.tsx?$/,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">    use: [</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        loader: &apos;ts-loader&apos;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先把ts 转成 es6, 然后用<code>babel</code>把ES6 转为 es5</p>
<p>但现在不是那种上古洪荒时代了， babel 统一添加， 让我们可以不需要在编译两轮了</p>
<p>在 babel 7 中，我们使用新的 @babel/preset-typescript (其集成了 @babel/plugin-transform-typescript)</p>
<p>我们的 .babelrc 配置将变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/env&quot;,</span><br><span class="line">    &quot;@babel/react&quot;,</span><br><span class="line">    &quot;@babel/typescript&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考地址:</p>
<blockquote>
<p><a href="https://github.com/frontend9/fe9-library/issues/23" target="_blank" rel="noopener">https://github.com/frontend9/fe9-library/issues/23</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jishuwen.com/d/2MbR/zh-tw" target="_blank" rel="noopener">https://www.jishuwen.com/d/2MbR/zh-tw</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表之顺序表</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的</p>
<p>并且当你需要在顺序表中插入数据时， 需要将插入目标位置后面的数据全部向后挪动， 这非常的耗费性能，  链表则不用， 只需要切换一下指针即可</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表之链表</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表如果按存储结构来分， 是属于链式存储结构</p>
<p>链表的每一项数据元素之间有<code>衔接关系</code>(圈起来要考)</p>
<blockquote>
<p>链表的优势在于灵活，不受申请时的内存大小约束，链表插入数据， 只需要切换一下指针即可</p>
</blockquote>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表分为： </p>
<ol>
<li>单向链表</li>
<li>双向链表</li>
</ol>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>链表在每一个数据元素中分为两个部分， 一个用来存储自身的数据， 另一部分存储下一项的指针（称为后继指针）</p>
<p><img src="http://img.nixiaolei.com/2019-05-01-23-26-30.png" alt="单向链表"></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表顾名思义， 就是支持两个方向的链表（前驱和后继）</p>
<p><img src="http://img.nixiaolei.com/2019-05-01-23-38-23.png" alt="双向链表"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表之队列</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种被限制操作的线性表。</p>
<p>FIFO（First In First Out）， 遵循选入先出</p>
<p>用途：<br>消息队列、视频弹幕</p>
<p><img src="http://img.nixiaolei.com/2019-05-01-23-12-36.png" alt="队列"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】什么是线性表</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性结构中的数据元素之间是一对一的关系。也就是数据元素一个接一个<br>地排列。</p>
<ol>
<li>用来存放特定的某一个类型的元素</li>
<li>物理结构为顺序表和链表（链式结构）</li>
</ol>
<p>关于存放特定类型元素的解释:</p>
<blockquote>
<p>Java等语言的泛型实际上也是在遵守这一规则， 因为他们的基类相同<br>JS也是如此， 因为js万物皆对象， 存储时都会被一个容器给包裹了， 所以类型相同</p>
</blockquote>
<h3 id="顺序表与链表对比"><a href="#顺序表与链表对比" class="headerlink" title="顺序表与链表对比"></a>顺序表与链表对比</h3><ul>
<li>顺序表: 不灵活，省内存</li>
<li>链表： 灵活， 多耗一点内存</li>
</ul>
<p>顺序表的优势在于比链表要更节省内存， 因为无需存储额外的指针</p>
<p>但缺点在于， 线性表申请完内存后， 无法进行缩放内存， 你需要用多大你就一次性连续申请多大， 如果你后期需要变更， 只能申请新的</p>
<h3 id="线性表的衍生结构"><a href="#线性表的衍生结构" class="headerlink" title="线性表的衍生结构"></a>线性表的衍生结构</h3><blockquote>
<p>可在本站中搜索</p>
</blockquote>
<ol>
<li>栈</li>
<li>队列</li>
<li>串</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】什么是集合</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数据结构中的集合关系就类似于数学中的集合。</p>
<ol>
<li>集合中的数据成员是无序的。</li>
<li>每个数据成员在集合中不能重复，仅且只出现一次。</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-05-01-22-59-42.png" alt="集合"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表之'栈'</title>
    <url>/2019/05/01/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%8B&#39;%E6%A0%88&#39;/</url>
    <content><![CDATA[<p>栈是一种被限制操作的线性表。</p>
<p>LIFO（Last In First Out），后入先出</p>
<p>用途：</p>
<ol>
<li>解决括号匹配检查</li>
<li>浏览器的后退或编辑器的undo功能</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-05-01-23-03-21.png" alt="栈"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法基础学习笔记</title>
    <url>/2019/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="http://img.nixiaolei.com/2019-05-01-22-26-25.png" alt="数据结构基本概念"></p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>只要能被数字化就可以称为数据</p>
<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>可以完整的描述一件东西，通常是产生在内存中的文件， 链表、队列等都算数据对象</p>
<h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>存在于数据对象中的一份一份的数据，就是数据元素</p>
<h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>用来描述某一特征的，  可以参考对象的属性， 但不完全相同</p>
<h2 id="浅析数据结构"><a href="#浅析数据结构" class="headerlink" title="浅析数据结构"></a>浅析数据结构</h2><p>数据元素相互之间的关系称为结构。数据结构是与算法紧密结合的</p>
<ul>
<li>逻辑结构：反映数据元素之间的逻辑关系。</li>
<li>存储结构：数据结构在计算机中的表示。</li>
<li>算法：对数据的操作</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-05-01-22-37-55.png" alt="浅析数据结构"></p>
<p><img src="http://img.nixiaolei.com/2019-05-01-22-38-59.png" alt="浅析数据结构02"></p>
<h3 id="基本逻辑结构"><a href="#基本逻辑结构" class="headerlink" title="基本逻辑结构"></a>基本逻辑结构</h3><p><img src="http://img.nixiaolei.com/2019-05-01-22-54-54.png" alt="逻辑结构分类"></p>
<h3 id="内存与存储结构"><a href="#内存与存储结构" class="headerlink" title="内存与存储结构"></a>内存与存储结构</h3><p>按照在内存中存储的方式来区分， 简单了解计一些算机中内存相关的知识：</p>
<ol>
<li>内存的原理与构造。</li>
<li>地址、指针与引用。</li>
<li>存储结构与内存管理</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学基础入门</title>
    <url>/2019/05/01/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】二叉树学习笔记</title>
    <url>/2019/04/24/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>树由边和节点组成</p>
</blockquote>
<h2 id="概念和用途"><a href="#概念和用途" class="headerlink" title="概念和用途"></a>概念和用途</h2><ul>
<li>树是一种非线性的数据结构， 分层存储。</li>
<li>树被用来存储具有层级关系的数据， 还被用来存储有序列表。</li>
<li>二叉树进行查找特别快， 为二叉树添加或删除元素也也别快</li>
<li>集合中不允许相同成员存在。</li>
</ul>
<h2 id="关键概念定义"><a href="#关键概念定义" class="headerlink" title="关键概念定义"></a>关键概念定义</h2><ol>
<li>树由一组以边连接的节点组成</li>
<li>一棵树最上面的节点称为根节点， 如果一个节点下面连接多个节点， 那么该节点称为父节点，  它下面的节点被称为子节点。 一个节点可以有0个、 1个或多个子节点。 没有任何子节点的节点称为叶子节点。</li>
<li>二叉树是一种特殊的树， 子节点个属不超过两个。</li>
<li>从一个节点走到另一个节点的这一组称为路径</li>
<li>以某种特定顺序访问树中的所有节点称为<code>树的遍历</code></li>
<li>树分为几个层次， 根节点是第0层， 它的子节点是第一层， 一次类推。 我们定义<code>树</code>的层数就是树的<code>深度</code> 。</li>
<li>每个节点都有一个与之相关的值， 该值有时被称为键。</li>
<li>一个父节点的两个子节点分别称为左节点和右节点。 二叉查找树是一种特殊的二叉树， 相对较小的值保存在左节点， 较大的值保存在右节点， 这一特性使得查找效率很高。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>vuecli3脚手架环境变量</title>
    <url>/2019/04/24/vuecli3%E8%84%9A%E6%89%8B%E6%9E%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote>
<p>环境变量, 在开发和生产环境中会经常使用到</p>
</blockquote>
<h3 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a>举一个例子</h3><blockquote>
<p>在开发过程中我们使用一个本地的接口<br>但是在我们打包上线的时候, 我们会使用线上的接口<br>这时候我们就可以通过环境变量来配置</p>
</blockquote>
<h3 id="如何创建环境变量"><a href="#如何创建环境变量" class="headerlink" title="如何创建环境变量"></a>如何创建环境变量</h3><blockquote>
<p>进入脚手架根目录 , 新建一个 .env 文件  , 这就是一个环境变量文件     </p>
</blockquote>
<p><strong>.env</strong>              优先级最低的配置文件, 两种环境都可以用<br><strong>.env.development</strong>  开发环境, 时优先使用的环境变量<br><strong>.env.production</strong>   生产环节, 打包时使用的环境变量     </p>
<h4 id="环境变量语法"><a href="#环境变量语法" class="headerlink" title="环境变量语法"></a>环境变量语法</h4><blockquote>
<p>VUE_APP_衔接上一个名字=’你的变量’</p>
</blockquote>
<p>如: </p>
<blockquote>
<p>VUE_APP_URL=’<a href="https://baidu.com&#39;" target="_blank" rel="noopener">https://baidu.com&#39;</a></p>
</blockquote>
<h3 id="如何在组件中获取环境变量"><a href="#如何在组件中获取环境变量" class="headerlink" title="如何在组件中获取环境变量"></a>如何在组件中获取环境变量</h3><blockquote>
<p>process.env.VUE_APP_URL<br>然后挂载到当前组件的data 上 ,如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        url: process.env.VUE_APP_URL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的add命令与npm的小区别</title>
    <url>/2019/04/24/vue%E7%9A%84add%E5%91%BD%E4%BB%A4%E4%B8%8Enpm%E7%9A%84%E5%B0%8F%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响,</p>
<p>那就选择 </p>
<blockquote>
<p>vue add xxx</p>
</blockquote>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件<br>那就选择 </p>
<blockquote>
<p>npm install xxx</p>
</blockquote>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3脚手架配置px2rem适配方案</title>
    <url>/2019/04/24/vue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AEpx2rem%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i lib-flexible --save</span><br><span class="line">npm install px2rem-loader</span><br></pre></td></tr></table></figure>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>main.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;lib-flexible/flexible&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>index.html</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="根目录新建-vue-config-js-文件"><a href="#根目录新建-vue-config-js-文件" class="headerlink" title="根目录新建 vue.config.js 文件"></a>根目录新建 vue.config.js 文件</h2><blockquote>
<p>复制如下代码， 重启， 搞定</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(&apos;css&apos;)</span><br><span class="line">        .test(/\.css$/)</span><br><span class="line">        .oneOf(&apos;vue&apos;)</span><br><span class="line">        .resourceQuery(/\?vue/)</span><br><span class="line">        .use(&apos;px2rem&apos;)</span><br><span class="line">          .loader(&apos;px2rem-loader&apos;)</span><br><span class="line">          .options(&#123;</span><br><span class="line">            remUnit: 75</span><br><span class="line">          &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>【CI】理解持续集成</title>
    <url>/2019/04/20/%E3%80%90CI%E3%80%91%E7%90%86%E8%A7%A3%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="前端项目持续集成"><a href="#前端项目持续集成" class="headerlink" title="前端项目持续集成"></a>前端项目持续集成</h1><h2 id="为什么需要持续集成"><a href="#为什么需要持续集成" class="headerlink" title="为什么需要持续集成"></a>为什么需要持续集成</h2><ol>
<li>持续集成是通过平台串联各个开发环节， 实现和沉淀工作自动化的方法。</li>
<li>线上代码和代码仓库不同步， 影响迭代和团队协作。</li>
<li>静态资源发布依赖人工，浪费开发人力。</li>
<li>缺少自动化测试，产品质量得不到保障。</li>
<li>文案简单修改上限，需要技术介入。</li>
</ol>
<h2 id="CI-持续集成"><a href="#CI-持续集成" class="headerlink" title="CI 持续集成"></a>CI 持续集成</h2><blockquote>
<p>continuous integration</p>
</blockquote>
<p>在持续集成环境中， 开发人员将会频繁的提交代码到主干。 这些新提交的代码最终合并到主线之前， 都需要通过编译和自动化测试流进行验证。这样做是基于之前持续集成过程中很重视自动化测试验证结果， 以保障所有的提交在合并主干之后的质量问题， 对可能出现的一些问题进行预警。</p>
<p><strong>自己的描述</strong></p>
<p>在所有向主分支修改的操作就需要线进行编译和自动化测试的监测， 测试会生成报表， 根据这个报表的结果来决定是否向主分支合并， 如果报表未通过就会被打回来（还会邮件通知领导）， 这样可以防止出现破坏主分支的情况出现</p>
<p>相比于持续交付、 持续部署， 持续集成更与我们前端息息相关， 并且大公司的QA是不受理未通过测试的提交的。</p>
<h2 id="CD-1-持续交付"><a href="#CD-1-持续交付" class="headerlink" title="CD (1) 持续交付"></a>CD (1) 持续交付</h2><blockquote>
<p>Continuous Delivery</p>
</blockquote>
<ul>
<li><p>持续交付就是讲我们的应用发布出去的过程。 这个过程可以确保我们尽可能快的实现交付。 这就意味着除了自动化测试， 我们还需要有自动化的发布流， 以及通过一个按钮就可以随时随地实现应用的部署上限。</p>
</li>
<li><p>通过持续交付， 您可以决定每天， 每周， 每两周发布一次， 这完全可以根据自己的业务进行设置。</p>
</li>
<li><p>但是， 如果您真的希望体验持续交付的优势，就需要先进行小批量的发布， 尽快部署到生产线，以便在出现问题时方便进行故障排除。</p>
</li>
</ul>
<p><strong>自己的描述</strong> </p>
<p>在已具备完善的持续集成后， 就可以改善发布过程， 通过一个按钮就进行发布</p>
<p>但是， 如果您真的希望体验持续交付的优势，就需要先进行小批量的发布， 尽快部署到生产线，以便在出现问题时方便进行故障排除。<br>也就是CI一通过就直接部署上线</p>
<h2 id="CD-2-持续部署"><a href="#CD-2-持续部署" class="headerlink" title="CD (2) 持续部署"></a>CD (2) 持续部署</h2><blockquote>
<p>Continuous Deployment</p>
</blockquote>
<ul>
<li><p>如果我们想更加深入一点的话， 就是持续部署了。通过这个方式，任何修改通过了所有已有的工作流就会直接和客户见面。  没有人为干预( 没有一键部署按钮 )， 只有当一个修改在工作流中构建失败才能阻止它部署到产品线。</p>
</li>
<li><p>持续部署是很优秀的方式， 可以加速与客户的反馈循环，但是会给团队带来压力， 因为不再有“发布日”了。 开发人员可以专注于构建软件， 他们看到他们的修改在完成工作后的几分钟就上线了。 基本上， 当开发人员在主分支中合并一个提交时， 这个分支将被构建、测试， 如果一切顺利， 则部署到生产环境中。</p>
</li>
</ul>
<p><strong>自己的描述</strong></p>
<p>自动实时的部署上限， 是最优的解决办法， 但持续部署的要求是团队非常成熟， 并且上线前是需要经过QA测试的，所以实际情况下很难实现， 一般的团队也很难接收，风险很大</p>
<h2 id="开发环节"><a href="#开发环节" class="headerlink" title="开发环节"></a>开发环节</h2><blockquote>
<p>作为持续集成， 这些开发环节一一不可缺少。</p>
</blockquote>
<p>首先在项目初级阶段，会拉上我们前端咨询功能的可行性。 商讨完成后UI、UE出设计图， 然后交给开发， 开发马不停蹄的实现， 然后将代码和素材， 开发文档都上传到代码仓库， 一般公司都会使用gitLab, gitLab的hooks钩子挂载到CI服务器平台(如Jenkins)， 然后在CI服务器上编写一些脚本构建项目（如：webpack、fis）， 当代码提交到仓库， CI平台就会监测到， 拉取仓库代码进行打包， 然后运行自动化测试， 并发送提测通知， 将项目发布到内网环境（QA和RD的机器上）， 所以CI平台必须免密登录的权限， 否则无法部署。</p>
<p><img src="http://img.nixiaolei.com/2019-11-20-12-32-32.png" alt="2019-11-20-12-32-32"></p>
<h2 id="整个持续集成流程与结构"><a href="#整个持续集成流程与结构" class="headerlink" title="整个持续集成流程与结构"></a>整个持续集成流程与结构</h2><ol>
<li>统一代码仓库通过分支管理合并主干, 如： SVN</li>
<li>自动化构建工具， 编译、部署、测试、监控、本机、开发上线环境。 如： FIS3、Webpack、jdists、package.json、chai、supertest、mocha、selenium-webdriver</li>
<li>持续集成平台。如： Jenkins、Travis CI</li>
<li>部署工具。如：rsync、shelljs、yargs。</li>
<li>运营同学有权限操作运营页面保存即可上限。</li>
</ol>
<h2 id="SVN-GIT版本管理工具使用原则"><a href="#SVN-GIT版本管理工具使用原则" class="headerlink" title="SVN/ GIT版本管理工具使用原则"></a>SVN/ GIT版本管理工具使用原则</h2><ul>
<li>不能随意修改主分支内容( master / Trunk )</li>
<li>新分支(branch)应从主分支切出</li>
<li>向主分支提交代码前,必须先 拉取最新的主分支代码合至分支（pull &amp;&amp; merge）， 并解决冲突</li>
<li>向主分支合并时及时的打<code>Tags</code> </li>
</ul>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>前端持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>【编程思想】简述IOC控制反转</title>
    <url>/2019/04/20/%E3%80%90%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%91%E7%AE%80%E8%BF%B0IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>
<h2 id="我的描述"><a href="#我的描述" class="headerlink" title="我的描述"></a>我的描述</h2><p>原本的程序， 当你这段代码需要用到某个模块时，  你就需要手动的去引入这个模块， 当模块被修改， 或被移动位置， 你的引用方式也要做出相应的修改，  此时你会觉得非常受限， 也非常容易出错。</p>
<p>因此， 有了控制反转这个概念</p>
<p>我们先把所有依赖收集到 容器中， 然后， 你需要什么就拿什么， 所有都是已经准备好的， 不用你再手动去引入，</p>
<blockquote>
<p> “所有的对象创建与销毁交给IOC容器， 其余的程序只需要依赖于容器就可以了”</p>
</blockquote>
<p>换句话说就是: 从我要什么去找什么 -&gt;   我要什么你就自动给我什么</p>
<p>我来掌控主动权</p>
<p><code>awilix-koa</code> 这个库就是专门为Node.js 做的 一种 DI 实现</p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】Flux架构是什么</title>
    <url>/2019/04/16/%E3%80%90React%E3%80%91Flux%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>为了避免<code>React</code>的<code>state</code>混乱， 让<code>React</code>专注于<code>ui</code>,  <code>Flux</code>就应运而生了</p>
<p>Flux是一种架构思想， 专门解决软件的结构问题。他跟MVC架构是同一类东西， 但是更加简单和清晰。</p>
<h2 id="Flux构成"><a href="#Flux构成" class="headerlink" title="Flux构成"></a>Flux构成</h2><ul>
<li><code>View</code>视图层 </li>
<li><code>Action</code>(动作): 视图层发出的消息(比如mouseClick)</li>
<li><code>Dispatcher</code>(派发器): 用来接收<code>Actions</code>, 执行回调函数</li>
<li><code>Store</code>(数据层): 用来存放应用的状态， 一旦发生变动， 就提醒<code>Views</code>要更新页面</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-16-22-00-28.png" alt="Flux构成"></p>
<p>Flux 的最大特点，就是数据的”单向流动”。</p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个”change”事件</li>
<li>View 收到”change”事件后，更新页面</li>
</ol>
<p>上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。</p>
<h2 id="Flux与Redux"><a href="#Flux与Redux" class="headerlink" title="Flux与Redux"></a>Flux与Redux</h2><p>因为<code>Flux</code>的不好理解， 所以社区做出了很多的努力， 常用的<code>Redux</code>就是<code>Flux</code>的其中一种实现</p>
<p>优质文献</p>
<blockquote>
<p><a href="https://www.cnblogs.com/fliu/articles/5245923.html" target="_blank" rel="noopener">阮一峰的flux</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】fiber带来的API</title>
    <url>/2019/04/15/%E3%80%90React%E3%80%91%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84fiber%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://github.com/koba04/react-fiber-resources" target="_blank" rel="noopener">github地址</a><br>↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</p>
<h2 id="React-Fiber异步渲染"><a href="#React-Fiber异步渲染" class="headerlink" title="React Fiber异步渲染"></a>React Fiber异步渲染</h2><h3 id="unstable-ConcurrentMode"><a href="#unstable-ConcurrentMode" class="headerlink" title="unstable_ConcurrentMode"></a>unstable_ConcurrentMode</h3><p><code>React.unstable_ConcurrentMode</code> 是一个使子组件中的更新异步的组件，这意味着更新被视为低优先级。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ConcurrentMode = React.unstable_ConcurrentMode;</span><br><span class="line">&lt;ConcurrentMode&gt;</span><br><span class="line">  &lt;App /&gt; <span class="comment">// Low Priority by default</span></span><br><span class="line">&lt;<span class="regexp">/ConcurrentMode&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="flushSync"><a href="#flushSync" class="headerlink" title="flushSync"></a>flushSync</h3><p>如果您想在组件内部使用同步更新，则可以使用ReactDOM.flushSync(cb)。在ReactDOM.flushSync回调内部，更新被视为同步优先级，这是v16的默认优先级。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">flushSync(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    num: newNum,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】拥抱函数组件的Hooks</title>
    <url>/2019/04/14/%E3%80%90React%E3%80%91%E6%8B%A5%E6%8A%B1%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84Hooks/</url>
    <content><![CDATA[<p>React16带来了惊人的改变， amazing~</p>
<h2 id="hooks带来的好处和特点"><a href="#hooks带来的好处和特点" class="headerlink" title="hooks带来的好处和特点"></a>hooks带来的好处和特点</h2><ol>
<li>只能在函数组件中使用</li>
<li>函数组件后期的业务变更无需修改为class组件</li>
<li>告别了麻烦<code>this</code> 和难记的生命周期</li>
<li>合并了生命周期<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的作用</li>
<li>可以包装自己的<code>hooks</code>，基于纯命令式的<code>API</code></li>
<li>更好的完成状态之间的共享， 解决原来class组件内部封装问题。 也解决高阶组件嵌套过深</li>
<li><code>useReducer</code>集成<code>redux</code></li>
<li><code>useEffect</code>接受脏操作等到<code>react</code>更新了<code>dom</code>后， 它再依次执行我们定义的副作用函数。 这里就是一个<code>io</code>且是异步的</li>
</ol>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>先来看看最常用的两个hooks： <code>useState</code>, <code>useEffect</code> </p>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><blockquote>
<p>传入一个初始值， 返回 <code>count</code>、<code>setCount</code>,<br><code>count</code>用来读， <code>setCount</code>用来写  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      count: &#123; count &#125;</span><br><span class="line">      &#123;<span class="comment">/* 点击事件触发setCount方法 */</span>&#125;</span><br><span class="line">      &lt;button onclick=&#123; setCount &#125;&gt;增加Count&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时页面就是这个样子的<br><img src="http://img.nixiaolei.com/2019-04-14-22-35-19.png" alt="当前页面状态"></p>
<p>然后我点击一次按钮<br><img src="http://img.nixiaolei.com/2019-04-14-22-43-40.png" alt="点击后"></p>
<p>此时<code>count</code>就发生了变化变为了<code>1</code>， 就好像我们使用了<code>setState</code>方法一样神奇</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote>
<p>副作用， 如果你对函数式编程有一定的了解， 那应该能明白这个词</p>
</blockquote>
<p>它主要用来承担<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>的作用</p>
<p>它传入一个函数，用于在组件<code>render</code>时触发， 其中需要返回一个函数，返回的函数在组件卸载时被触发<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"更新渲染阶段"</span>)</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`标题-<span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"卸载阶段"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在<code>useState</code>例子基础上我们添加了<code>useEffect</code>后， 效果如下：</p>
<p><img src="http://img.nixiaolei.com/effect.gif" alt="useEffect"></p>
<p>我们可以看到， 刷新页面后首先出现的是”更新渲染阶段”，<br>当我们点击了按钮后， 立即出现了“卸载阶段”， 然后出现了”更新渲染阶段”</p>
<p>这就证明该副作用是在每次组件更新时都会被触发的。</p>
<h4 id="自定义触发"><a href="#自定义触发" class="headerlink" title="自定义触发"></a>自定义触发</h4><p><code>useEffect</code>不仅能够替代那些个老生命周期， 还能够自定义根据某个值来触发</p>
<p><code>useEffect</code>的能接收两个参数， 第一个就是刚刚我们尝试的回调， 第二个参数可传可不传， 他是一个数组， </p>
<p>如果你不传，就和上面的例子一样， 默认全部触发，<br>如果你传入的是一个空数组<code>[]</code>，那就只在第一次渲染时触发<br>如果你数组里制定了值， 那就只在这些值变化时触发</p>
<hr>
<p>比如我要指定只有 <code>count</code>变化时才会触发<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"更新渲染阶段"</span>)</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`标题-<span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"卸载阶段"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">api</th>
<th style="text-align:center">ability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">state</td>
<td style="text-align:center">返回有状态值, 以及更新这个状态值的函数</td>
</tr>
<tr>
<td style="text-align:center">useEffect</td>
<td style="text-align:center">接收包含命令式， 可能有副作用代码的函数</td>
</tr>
<tr>
<td style="text-align:center">useContext</td>
<td style="text-align:center">接受上下文对象（从React.createContext返回的值）</td>
</tr>
<tr>
<td style="text-align:center">useReducer</td>
<td style="text-align:center">useState的替代方案</td>
</tr>
<tr>
<td style="text-align:center">useCallback</td>
<td style="text-align:center">返回一个回忆的memoized版本，</td>
</tr>
<tr>
<td style="text-align:center">useMemo</td>
<td style="text-align:center">纯的一个记忆函数</td>
</tr>
<tr>
<td style="text-align:center">useRef</td>
<td style="text-align:center">返回一个可变的ref对象</td>
</tr>
<tr>
<td style="text-align:center">useImperativeMethods</td>
<td style="text-align:center">自定义使用ref时公开给父组件的实例值之前</td>
</tr>
<tr>
<td style="text-align:center">useMutationEffect</td>
<td style="text-align:center">更新兄弟组件之前， 它dom改变前执行</td>
</tr>
<tr>
<td style="text-align:center">useLayoutEffect</td>
<td style="text-align:center">Dom改变后同步触发</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】react生命周期的变化</title>
    <url>/2019/04/13/%E3%80%90React%E3%80%91react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p><code>React16</code>带来了新的生命周期， 为了更好的贴合<code>fiber</code>架构， 移除了几个旧的生命周期， 这几个生命周期也确实不太常用</p>
<p>我们先来看看老的生命周期</p>
<h2 id="react15生命周期"><a href="#react15生命周期" class="headerlink" title="react15生命周期"></a>react15生命周期</h2><p><img src="http://img.nixiaolei.com/2019-04-13-10-14-55.png" alt="react15生命周期"></p>
<p>光看没用呀，记不住，我们来实际看一下它的打印顺序。<br>初次加载时：<br><img src="http://img.nixiaolei.com/2019-04-13-10-08-51.png" alt="react15打印生命周期01"></p>
<p>点击按钮更新组件，使得传入<code>Props</code>发生改变，触发子组件的生命周期<br><img src="http://img.nixiaolei.com/2019-04-13-10-19-11.png" alt="react15打印生命周期02"></p>
<h2 id="react16生命周期"><a href="#react16生命周期" class="headerlink" title="react16生命周期"></a>react16生命周期</h2><p><img src="http://img.nixiaolei.com/2019-04-14-17-50-09.png" alt="React16生命周期"></p>
<h3 id="废弃的三个生命周期："><a href="#废弃的三个生命周期：" class="headerlink" title="废弃的三个生命周期："></a>废弃的三个生命周期：</h3><ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>如果你在<code>react16</code>中还继续使用这几个什么周期， 他就会提示你这是不安全的<br><img src="http://img.nixiaolei.com/2019-04-14-19-02-00.png" alt="warning"></p>
<h3 id="新增的两个生命周期"><a href="#新增的两个生命周期" class="headerlink" title="新增的两个生命周期:"></a>新增的两个生命周期:</h3><blockquote>
<p>为了配合<code>fiber</code></p>
<ul>
<li>getDerivedStateFromProps</li>
<li>getSnapshotBeforeUpdate</li>
</ul>
</blockquote>
<p>我这个人说话比较简单， 我就简介的说一下这两个生命周期主要的功能及解决的问题， 具体的长篇大论不好描述，也不是我擅长的事情， 我在下面给出了两份不错的文章， 方便自己回忆细节， 也方便大家理解</p>
<h4 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h4><blockquote>
<p>用来取代<code>componentWillReceiveProps</code>, 是一个静态方法</p>
</blockquote>
<blockquote>
<p>接收两个参数 nextProps, preProps<br>是一个将接收到的<code>props</code>映射到<code>state</code>的方法<br>具体映射规则根据该方法的返回值，</p>
</blockquote>
<p>比如，如果这样，返回一个<code>name</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevProps) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">"张三"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随即我们打印一下<code>state</code><br><img src="http://img.nixiaolei.com/2019-04-14-21-19-29.png" alt="映射props"><br>我们发现，返回的<code>name</code> 确实出现在了<code>state</code>, 尽管这是我创造出来的， 而不是<code>props</code>上传入的</p>
<p>如果我们不想它映射到<code>state</code>, 我们可以返回一个<code>null</code></p>
<p><img src="http://img.nixiaolei.com/2019-04-14-21-22-06.png" alt="不映射props"></p>
<p>根据这个特性利用传入的<code>nextProps, prevProps</code>两个参数， 我们就可以做类似 <code>shouldComponentUpdate</code>的操作</p>
<h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h4><blockquote>
<p>该方法获取上一次<code>render</code>时的镜像</p>
</blockquote>
<blockquote>
<p>接收 prevProps, prevState 两个参数</p>
</blockquote>
<p>新的<code>getSnapshotBeforeUpdate</code>生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给<code>componentDidUpdate</code>。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）</p>
<p>与<code>componentDidUpdate</code>一起，这个新的生命周期将覆盖旧版<code>componentWillUpdate</code>的所有用例。</p>
<p>来看一下每次的打印结果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`---第<span class="subst">$&#123;times++&#125;</span>次renders---`</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prevProps'</span>, prevProps)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prevState'</span>, prevState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://img.nixiaolei.com/2019-04-14-21-41-52.png" alt="查看镜像"></p>
<p>关于这两个生命周期， 有两个个比较好的文章：</p>
<ul>
<li><a href="https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization" target="_blank" rel="noopener">理论型文章</a></li>
<li><a href="https://www.jianshu.com/p/50fe3fb9f7c3" target="_blank" rel="noopener">使用型文章</a></li>
</ul>
<p>参考文献:</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/50fe3fb9f7c3" target="_blank" rel="noopener">https://www.jianshu.com/p/50fe3fb9f7c3</a><br><a href="https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization" target="_blank" rel="noopener">https://blog.csdn.net/nnxxyy1111/article/details/80832525#%E4%BB%80%E4%B9%88%E6%98%AFmemoization</a><br><a href="https://www.zcfy.cc/article/update-on-async-rendering" target="_blank" rel="noopener">https://www.zcfy.cc/article/update-on-async-rendering</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】react16新增错误处理生命周期</title>
    <url>/2019/04/12/%E3%80%90React%E3%80%91react16%E6%96%B0%E5%A2%9E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><code>React16</code>新增了一个用于错误处理的生命周期，</p>
<p>有了这个法宝，我们就能针对组件的错误做很多事情啦， 来看看怎么用</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Errorfun</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>( props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 捕捉错误和错误上报程序库一起使用</span></span><br><span class="line">  componentDidCatch(err, info) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span>.state.hasError ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Somthing error <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello React</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】react16中如何使用ref </title>
    <url>/2019/04/12/%E3%80%90React%E3%80%91react16%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ref/</url>
    <content><![CDATA[<p>在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。</p>
<blockquote>
<p>新版的<code>ref</code>内部使用<code>Symbol</code>来作为标识， 可以猜测出，<code>React</code>的用意是想避免<code>string ref</code>可能引起重复的问题</p>
</blockquote>
<h2 id="关联ref"><a href="#关联ref" class="headerlink" title="关联ref"></a>关联ref</h2><p>使用新版本的ref<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Reftest</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建ref</span></span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 打印ref</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.myRef)</span><br><span class="line">    <span class="keyword">this</span>.myRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 挂载 ref</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="传递和转发ref"><a href="#传递和转发ref" class="headerlink" title="传递和转发ref"></a>传递和转发ref</h2><p>利用 <code>React.forwardRef</code> 传递复用 <code>ref</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TargetComponent = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default class Reftest extends Component &#123;</span></span><br><span class="line"><span class="xml">  constructor(props) &#123;</span></span><br><span class="line"><span class="xml">    super(props);</span></span><br><span class="line"><span class="xml">    // 创建ref</span></span><br><span class="line"><span class="xml">    this.myRef = React.createRef();</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">    // 改变value</span></span><br><span class="line"><span class="xml">    this.myRef.current.value = "传递ref成功"</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    // 挂载 ref, 让组件也保持ref写法</span></span><br><span class="line">    return &lt;TargetComponent ref=&#123;this.myRef&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下: </p>
<p><img src="http://img.nixiaolei.com/2019-04-12-23-44-48.png" alt="ref复用"></p>
<p>参考文献:</p>
<ul>
<li><a href="https://blog.csdn.net/qq_24147051/article/details/81218688" target="_blank" rel="noopener">https://blog.csdn.net/qq_24147051/article/details/81218688</a></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】使用Context避免多层嵌套</title>
    <url>/2019/04/12/%E3%80%90React%E3%80%91%E4%BD%BF%E7%94%A8Context%E9%81%BF%E5%85%8D%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<p>用过redux + react-redux的同学，应该会觉得新的Context API很眼熟。而有看过react-redux源码的同学就知道，react-redux本身就是基于旧版本的Context API实现的。</p>
<p>既然已经有了现成的解决方案，为什么还会有新的Context API呢？</p>
<ol>
<li>现有Context API的实现存在一定问题：比如当父组件的shouldComponentUpdate性能优化，可能会导致消费了context数据的子组件不更新。</li>
<li>降低复杂度：类似redux全家桶这样的解决方案，给项目引入了一定的复杂度，尤其是对方案了解不足的同学，遇到问题可能一筹莫展。新Context API的引入，一定程度上可以减少不少项目对redux全家桶的依赖。</li>
<li>解决多层组件嵌套</li>
</ol>
<h2 id="创建一个上下文"><a href="#创建一个上下文" class="headerlink" title="创建一个上下文"></a>创建一个上下文</h2><p>利用新的<code>API</code>创建一个上下文， 接收返回的<code>Provider</code>, <code>Consumer</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(<span class="string">"default"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="定义父容器"><a href="#定义父容器" class="headerlink" title="定义父容器"></a>定义父容器</h2><p>在此父容器内部使用<code>Provider</code>包裹住插槽传入的子组件， 传入<code>Provider</code>的值和<code>state</code>挂钩， 并且我将两个值都实现了双向绑定，以便于查看使用<code>context</code>方法传递的变量能否及时刷新  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        姓名：</span><br><span class="line">        &lt;input  onChange=&#123; e=&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: e.target.value &#125;)&#125; value=&#123;name&#125; /&gt;</span><br><span class="line">        年龄:</span><br><span class="line">        &lt;input  onChange=&#123; e=&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">age</span>: e.target.value &#125;)&#125;  value=&#123;age&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Provider value=&#123;&#123; name, age &#125;&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建两个子组件"><a href="#创建两个子组件" class="headerlink" title="创建两个子组件"></a>创建两个子组件</h2><p>两个子组件分别用接收一个参数， 当然你也可以接收多个的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我用来展示name</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child01</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; (</span><br><span class="line">          &lt;div&gt;&#123;value.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我用来展示age</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child02</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; (</span><br><span class="line">          &lt;div&gt;&#123;value.age&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件整合"><a href="#组件整合" class="headerlink" title="组件整合"></a>组件整合</h2><p>用<code>Parent</code>组件将两个<code>Child</code>包裹， 也就是上面说的插槽<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Parent &gt;</span><br><span class="line">    &lt;Child01 /&gt;</span><br><span class="line">    &lt;Child02 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Parent&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure></p>
<p>最终效果:</p>
<p><img src="http://img.nixiaolei.com/reactContext.gif" alt="最终效果"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(<span class="string">"default"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        姓名：</span><br><span class="line">        &lt;input  onChange=&#123; e=&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: e.target.value &#125;)&#125; value=&#123;name&#125; /&gt;</span><br><span class="line">        年龄:</span><br><span class="line">        &lt;input  onChange=&#123; e=&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">age</span>: e.target.value &#125;)&#125;  value=&#123;age&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Provider value=&#123;&#123; name, age &#125;&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child01</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; (</span><br><span class="line">          &lt;div&gt;&#123;value.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child02</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; (</span><br><span class="line">          &lt;div&gt;&#123;value.age&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Consumer&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line">  &lt;Parent &gt;</span><br><span class="line">    &lt;Child01 /&gt;</span><br><span class="line">    &lt;Child02 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Parent&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】react16.6中如何处理异步&&按需加载</title>
    <url>/2019/04/11/%E3%80%90React%E3%80%91react16.6%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5&amp;&amp;%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>当前大部分 <code>React</code> 应用需要使用 <code>code splitting</code> 的时候，都选择使用优秀的 <code>react-loadable</code> 来处理检测代码段是否已加载。然而，随着<code>React v16.6</code> 的发布，我们有一个非常难得的机会 ，可以删除我们的第三方依赖！</p>
<p><a href="https://reactjs.org/docs/code-splitting.html" target="_blank" rel="noopener">React.Suspense</a>是一个新添加到核心React库中的功能，他的功能基本和 <code>react-loadable</code> 一致，所以不用多说，让我们来看看用 <code>React.Suspense</code> 替换 <code>react-loadable</code>。</p>
<p><code>Suspense</code> 的好处是不一定只能处理组件的按需加载， 也能用来处理其他的异步事件</p>
<h2 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h2><blockquote>
<p>自己实现流程</p>
</blockquote>
<p>首先创建一个<code>Promise</code> ， 模拟一个异步请求<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'data resolved'</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现处理<code>promise</code>异步的逻辑<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense, Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="comment">// 创建Fetcher </span></span><br><span class="line"><span class="keyword">var</span> cached = &#123;&#125;</span><br><span class="line"><span class="comment">// 接收一个为promise 的参数</span></span><br><span class="line"><span class="keyword">const</span> createFetcher = <span class="function"><span class="params">promiseTask</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将ref 复制为 cached</span></span><br><span class="line">  <span class="keyword">let</span> ref = cached</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个 promise</span></span><br><span class="line">    <span class="keyword">const</span> task = promiseTask()</span><br><span class="line">    <span class="comment">// task</span></span><br><span class="line">    task.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ref 复制为 res, 也就是promise 的返回结果</span></span><br><span class="line">      ref = res</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//  ------注意此处的 console --------</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入ref === cached的判断'</span>)</span><br><span class="line">    <span class="comment">// 如果 ref 没有发生改变， 仍旧和cached相等</span></span><br><span class="line">    <span class="keyword">if</span> (ref === cached) &#123;</span><br><span class="line">      <span class="comment">// 抛出 task </span></span><br><span class="line">      <span class="keyword">throw</span> task</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到结果输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'🍎'</span>, ref)</span><br><span class="line">    <span class="comment">// 正常返回 ref ， 此时已是promise 的结果</span></span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将异步事件传入刚刚定义的<code>createFtecher</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requestData = createFetcher(fetchApi)</span><br></pre></td></tr></table></figure></p>
<p>创建一个函数组件， 用于显示处理好的异步结果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuspenseComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = requestData()</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"name"</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点来了， 使用<code>Suspense</code>组件包裹住， 使用<code>fallback</code>参数传入未加载完成的时候的样式, 我们这里传入一个<code>loading</code>的文字意思意思<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;<span class="regexp">/div&gt;&#125; &gt;</span></span><br><span class="line"><span class="regexp">        &lt;SuspenseComp /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>来看一下效果， 在经过一段事件的Loading 后成功的显示除了我们在<code>setTimeout</code>中返回的文字</p>
<p><img src="http://img.nixiaolei.com/suspense01.gif" alt="实现效果"></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>仔细观看上面的效果图</p>
<p>我们看到<code>进入ref === cached的判断</code> 这条语句出现了二次， 继而才出现了最终结果<code>data resolved</code>，<br>还记得在<code>createFetcher</code>函数中抛出的<code>task</code>吗， 它就是利用这样一种方法， 抛出错误，让<code>Suspense</code> 来接收， 如果抛出了错误， 就隔一会继续来一次， </p>
<p>其实就可以理解为轮询</p>
<h2 id="处理组件"><a href="#处理组件" class="headerlink" title="处理组件"></a>处理组件</h2><p>组件就比上面简单多了, </p>
<p><code>React</code>就提供了一个 <code>lazy</code>方法</p>
<p>我们只需要这样即可， 非常的快捷<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./xxx"</span>))</span><br></pre></td></tr></table></figure></p>
<p>来看看实际如何使用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入`lazy` 和 `Suspense`</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, Component, lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载异步组件</span></span><br><span class="line"><span class="keyword">const</span> LazyComp = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy"</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;<span class="regexp">/div&gt;&#125; &gt;</span></span><br><span class="line"><span class="regexp">          &#123; /</span>* lazy 组件 *<span class="regexp">/ &#125;</span></span><br><span class="line"><span class="regexp">          &lt;LazyComp /</span>&gt; </span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被加载的lazy组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        my name lazy</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>来， 让我们看一下效果</p>
<p><img src="http://img.nixiaolei.com/lasy01.gif" alt="实现效果"></p>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>那上面两个例子中的组件<code>SuspenseComp</code> 和  <code>LazyComp</code> 都放在<code>Suspense</code> 里面呢，到底是各管各的还是一起完成呢？ 让我们实践一下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;<span class="regexp">/div&gt;&#125; &gt;</span></span><br><span class="line"><span class="regexp">        &lt;SuspenseComp /</span>&gt;</span><br><span class="line">        &lt;LazyComp /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果如下:<br><img src="http://img.nixiaolei.com/lazy02.gif" alt="实现效果"></p>
<p>我们可以看到,尽管<code>SuspenseComp</code> 和<code>LazyComp</code> 加载速度不同, 但是它仍旧是等待<code>Suspense</code> 中的所有组件都加载完成后才显示出来</p>
<h2 id="处理异步-Hooks版本"><a href="#处理异步-Hooks版本" class="headerlink" title="处理异步-Hooks版本"></a>处理异步-Hooks版本</h2><p>Hooks 处理异步只需要短短的几行，就有了相同的效果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useFetch &#125; <span class="keyword">from</span> <span class="string">'react-hooks-fetch'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuspenseComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;error, data&#125; = useFetch(<span class="string">"a.php"</span>)</span><br><span class="line">  <span class="keyword">if</span>( error ) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>出错了🙂<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">if</span>( !data ) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>result&#123;data.title&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真香</p>
<h2 id="非Hooks版本全部代码"><a href="#非Hooks版本全部代码" class="headerlink" title="非Hooks版本全部代码"></a>非Hooks版本全部代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense, Component, lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// React 自带的lazy组件，自己会编译 （避免被webpack打包成js）</span></span><br><span class="line"><span class="keyword">const</span> LazyComp = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./lazy"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'data resolved'</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Fetcher </span></span><br><span class="line"><span class="keyword">var</span> cached = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> createFetcher = <span class="function"><span class="params">promiseTask</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> ref = cached</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个promise</span></span><br><span class="line">    <span class="keyword">const</span> task = promiseTask()</span><br><span class="line">    task.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      ref = res</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入ref === cached的判断'</span>)</span><br><span class="line">    <span class="keyword">if</span> (ref === cached) &#123;</span><br><span class="line">      <span class="keyword">throw</span> task</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到结果输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'🍎'</span>, ref)</span><br><span class="line">    <span class="keyword">return</span> ref</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestData = createFetcher(fetchApi)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuspenseComp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = requestData()</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"name"</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;<span class="regexp">/div&gt;&#125; &gt;</span></span><br><span class="line"><span class="regexp">          &lt;SuspenseComp /</span>&gt;</span><br><span class="line">          &lt;LazyComp /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Test</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>原生实现一个ajax</title>
    <url>/2019/04/10/%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAajax/</url>
    <content><![CDATA[<h1 id="原生-AJAX"><a href="#原生-AJAX" class="headerlink" title="原生 AJAX"></a>原生 AJAX</h1><h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><ul>
<li>Asynchronous  JavaScript &amp; XML    请求XML的异步技术</li>
<li>web开发的一种技术</li>
<li>异步发送 &amp; 请求数据</li>
<li>不需要重新刷新当前页面</li>
<li>目前 JSON 数据格式以及占据市场</li>
</ul>
<h2 id="请求码-和-状态码"><a href="#请求码-和-状态码" class="headerlink" title="请求码 和 状态码"></a>请求码 和 状态码</h2><h3 id="readyState-请求码"><a href="#readyState-请求码" class="headerlink" title="readyState 请求码"></a>readyState 请求码</h3><ul>
<li>0 : 请求未初始化  ( 没有 XHR 对象 )</li>
<li>1 : 服务器连接已建立</li>
<li>2 : 请求已接受</li>
<li>3 : 请求处理中</li>
<li>4 : 请求已完成, 且相应已就绪</li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul>
<li>200 - 服务器成功返回网页</li>
<li>300 - 请求地址错误,重定向</li>
<li>400 - 请求错误<ul>
<li>404 - 请求的网页不存在</li>
</ul>
</li>
<li>500 - 服务端错误<ul>
<li>503 - 服务器暂时不可用    </li>
</ul>
</li>
</ul>
<h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建  XMLHttpRequest 对象"></a>创建  XMLHttpRequest 对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure>
<h2 id="open-请求部署阶段"><a href="#open-请求部署阶段" class="headerlink" title="open() 请求部署阶段"></a>open() 请求部署阶段</h2><ul>
<li>xhr.open( type 请求类型 , url/filename 路径或文件名 ,  async是否要使用异步)</li>
<li>GET 请求 参数写在 URL 中<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://jsonplaceholder.typicode.com/users'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="两种方式请求-onload-和-onreadystatechange"><a href="#两种方式请求-onload-和-onreadystatechange" class="headerlink" title="两种方式请求 onload 和 onreadystatechange"></a>两种方式请求 onload 和 onreadystatechange</h2><ul>
<li>请求成功后会返回服务器 返还的相应内容 <code>responseText</code></li>
</ul>
<h3 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h3><ul>
<li>只有请求码为 4 时才会进入 onload<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="onprogress-捕获-为3-的请求码"><a href="#onprogress-捕获-为3-的请求码" class="headerlink" title="onprogress 捕获 为3 的请求码"></a>onprogress 捕获 为3 的请求码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onprogress =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.readyState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><ul>
<li>需要判断返回的请求码 , 直接输出会返回两次数据 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><ul>
<li>返回请求码的位置与顺序<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readyState) <span class="comment">// 0</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://jsonplaceholder.typicode.com/users'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readyState)  <span class="comment">// 1</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'readyState:'</span>,xhr.readyState)  <span class="comment">// 2 , 3 , 4</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="status-状态码"><a href="#status-状态码" class="headerlink" title="status 状态码"></a>status 状态码</h4><ul>
<li>每次都和请求码一同被返回</li>
</ul>
<h4 id="根据-请求码-和-状态码-来操作数据"><a href="#根据-请求码-和-状态码-来操作数据" class="headerlink" title="根据 请求码 和 状态码 来操作数据"></a>根据 请求码 和 状态码 来操作数据</h4><h4 id="一个完整的-GET-请求"><a href="#一个完整的-GET-请求" class="headerlink" title="一个完整的 GET 请求"></a>一个完整的 GET 请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"> xhr.open(<span class="string">'GET'</span>, <span class="string">'http://jsonplaceholder.typicode.com/users'</span>, <span class="literal">true</span>)</span><br><span class="line"> xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> xhr.send()</span><br></pre></td></tr></table></figure>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><ul>
<li>GET 直接发送</li>
<li>POST 需要带上要发送的 请求体 数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【imooc】HTML5&CSS3</title>
    <url>/2019/04/10/%E3%80%90imooc%E3%80%91HTML5-CSS3/</url>
    <content><![CDATA[<h1 id="HTML5-CSS3"><a href="#HTML5-CSS3" class="headerlink" title="HTML5 + CSS3"></a>HTML5 + CSS3</h1><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nav</td>
<td style="text-align:center">导航</td>
</tr>
<tr>
<td style="text-align:center">header</td>
<td style="text-align:center">页眉</td>
</tr>
<tr>
<td style="text-align:center">footer</td>
<td style="text-align:center">文档或者页的页脚</td>
</tr>
<tr>
<td style="text-align:center">main</td>
<td style="text-align:center">主要内容</td>
</tr>
<tr>
<td style="text-align:center">article</td>
<td style="text-align:center">文章或热点区</td>
</tr>
<tr>
<td style="text-align:center">aside</td>
<td style="text-align:center">主题内容之外</td>
</tr>
</tbody>
</table>
<h2 id="语义化标签的兼容性"><a href="#语义化标签的兼容性" class="headerlink" title="语义化标签的兼容性"></a>语义化标签的兼容性</h2><ul>
<li>IE9: 行级元素在设置宽度的时候失效, 解决方法: display : block</li>
<li>IE8: 完全不支持语义标签( 不支持html5 )  ,解决方法: <code>document.createElement(&#39;header&#39;)</code> 或引入第三方插件 <code>html5shiv</code></li>
</ul>
<h2 id="form-新增的属性"><a href="#form-新增的属性" class="headerlink" title="form 新增的属性"></a>form 新增的属性</h2><ul>
<li>autofocus 浏览器打开自动获得焦点</li>
<li>autocomplete=”on”   表单内容自动完成,前提: 必须成功提交过  , 该标签必须有name 属性</li>
<li>required 必须输入</li>
<li>pattern=” “    正则表达式验证</li>
<li>multiple  对于file 标签使用,  同时选择多个文件, 对于email 标签使用, 可以同时输入多个邮箱</li>
<li>form=”表单form 的 id “  可以让在form 表单外部的 表单数据也参与提交</li>
<li>oninvalid 当验证不通过时触发的事件</li>
<li>this.setCustomValidity(“ 请输入合法的手机号 “)     这个js api 可以修改默认的h5表单 提示内容</li>
<li><code>dom.dataset[ &quot;myTest&quot; ]</code>  获取自定义的data-my-Test的值 ,获取时要变成驼峰命名</li>
</ul>
<h2 id="form-新增的元素"><a href="#form-新增的元素" class="headerlink" title="form 新增的元素"></a>form 新增的元素</h2><ul>
<li><p>datalist   可以输入的下拉列表 (   firfox 中不支持 )   需要通过  list=”datalist的id” 建立联系</p>
<ul>
<li>如果 input 的type 类型是url ,那么value值必须添加 http://  ,因为不加的话识别为不合法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 建立关联   list=&quot;datalist的id&quot; --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; list=&quot;dt&quot;&gt;</span><br><span class="line">&lt;datalist id=&quot;dt&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;哈哈&quot; label=&quot;10人&quot;&gt;哈哈哈&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;前端牛逼&quot; label=&quot;18人&quot;&gt;前端牛逼&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>keygen标签       h5 提供的加密  , 部分浏览器不支持 , 将表单信息进的是非对称加密,</p>
<ul>
<li>生成公钥和私钥,   提交数据的时候  信息+私钥 =&gt; 二次加密   然后发送给服务器,  服务器用接收到的 公钥进行解密数据</li>
</ul>
</li>
<li>output  显示输出信息, 只能显示不能修改<ul>
<li>语义性更强</li>
<li>值需要你去设置, 不能自动计算</li>
</ul>
</li>
</ul>
<h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ul>
<li><p>embed  直接插入视频文件， 它的本质是调用本机上已经安装的软件  有兼容性</p>
</li>
<li><p>flash插件   安装flash   1.学习flash,增加使用成本    2.苹果设备不支持flash</p>
</li>
<li><p>audio 音频 </p>
<ul>
<li>src : 播放音频文件的路径</li>
<li>controls: 音频播放器的控制面板</li>
<li>autoplay: 自动播放</li>
<li>loop: 循环</li>
</ul>
</li>
<li><p>video 视频 </p>
<ul>
<li><p>src : 播放音频文件的路径</p>
</li>
<li><p>controls: 音频播放器的控制面板</p>
</li>
<li><p>autoplay: 自动播放</p>
</li>
<li><p>loop: 循环</p>
</li>
<li><p>width:宽度 </p>
</li>
<li><p>height:高度</p>
</li>
<li><p>poster: 当视频还没完全下载，  或者用户还没点击播放前的默认显示的封面， 默认是显示当前视频文件的第一帧</p>
</li>
<li><p>设置宽高的时候，一般情况下只会设置宽度或者高度 让其自动等比缩放， 如果同时设置宽度和高度，那么视频不会真正的调整到设置的高度，除非设置刚好等比例</p>
</li>
<li><p>多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 </p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video  autoplay controls width=&quot;600px&quot;&gt;</span><br><span class="line">       &lt;!-- 多个source 让浏览器自动选择支持的视频格式 先看第一个支不支持再看第二个 --&gt;</span><br><span class="line">       &lt;source src=&quot;http://www.baidu.com&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">       &lt;source src=&quot;http://wxhboy.com/login/movies/w.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">           您的浏览器不支持当前的视频播放</span><br><span class="line">   &lt;/video&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="操作class的API"><a href="#操作class的API" class="headerlink" title="操作class的API"></a>操作class的API</h2><ul>
<li><code>dom.classList.add(&#39;bg&#39;)</code> 增加class</li>
<li><code>obj.classList.remove(&#39;bg&#39;)</code>  删除class</li>
<li><code>obj.classList.toggle(&#39;bg&#39;)</code> 切换class  如果存在就删除,如果不存在就增加该class</li>
<li><code>obj.classList.contains(&#39;bg&#39;)</code>  判断是否存在某个class  , 返回布尔型 </li>
</ul>
<h2 id="H5新增的接口-API"><a href="#H5新增的接口-API" class="headerlink" title="H5新增的接口 API"></a>H5新增的接口 API</h2><ul>
<li>ononline  网络连通时触发这个事件 ，只在window上 </li>
<li>onoffline  网络断开时触发事件</li>
<li><code>element.requestFullscreen</code> 开启全屏 ，需要加浏览器前缀<ul>
<li>需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o </li>
</ul>
</li>
<li><p><code>document.cancelFullScreen</code> 取消全屏，只能是document对象</p>
<ul>
<li>需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o </li>
</ul>
</li>
<li><p><code>document.fullscreenElement</code> 取消全屏，只能是document对象</p>
<ul>
<li>需要加兼容浏览器的前缀 chrome:webkit   firefox:moz  ie: ms  opera: o </li>
</ul>
</li>
<li><code>var reader = new FileReader()   reader.readAsDataURL(file[0])</code>读取文件斌转为base64<ul>
<li>没有返回值,但是它会将读取的结果存储在文件读取对象的result中 </li>
<li>FileReader 提供一个完整的事件模型, 用来捕获读取文件时的状态</li>
<li>onabort: 读取文件中断片时触发</li>
<li>onerror: 读取文件错误时触发</li>
<li>onload: 文件读取成功完成时触发<pre><code>  *  onloadend: 读取完成时触发,无论成功还是失败
* onloadstart: 开始读取文件时触发
* onprogress: 读取文件过程中持续触发
</code></pre></li>
</ul>
</li>
</ul>
<h1 id="CSS3-选择器"><a href="#CSS3-选择器" class="headerlink" title="CSS3 选择器"></a>CSS3 选择器</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><blockquote>
<p>属性时相对于标签而言的<br>就是根据指定名称的属性的值来查找元素</p>
</blockquote>
<ul>
<li><code>li[style]</code> 查找只要拥有 style 属性的标签</li>
<li><code>li[class = red ]</code>  严格匹配  拥有class 样式并且等于某值</li>
<li><code>li[class*= red ]</code>  查找class 中包含 red 的标签</li>
<li><code>li[class^= red ]</code>  查找class 中以red 开头的li标签</li>
<li><code>li[class$= red ]</code>  查找class 中以red 结尾的li标签</li>
</ul>
<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="兄弟伪类"><a href="#兄弟伪类" class="headerlink" title="兄弟伪类"></a>兄弟伪类</h3><ul>
<li><code>+</code> 获取当前元素相邻的满足条件的元素，必须是相邻的</li>
<li><code>~</code> 获取当前元素的满足条件的兄弟元素  可以不相邻 ，所有兄弟元素</li>
</ul>
<h3 id="相对于父级选择器"><a href="#相对于父级选择器" class="headerlink" title="相对于父级选择器"></a>相对于父级选择器</h3><ul>
<li><code>ul&gt; li:first-child</code> 查找ul下第一个元素，如果第一个不是li 那就不生效</li>
<li><code>ul&gt; li:last-child</code>  查找ul下最后一个元素</li>
<li><code>li:first-of-type</code>   查找的时候指挥查找满足类型条件的第一个元素，过滤掉其他类型的元素</li>
<li><code>li:last-of-type</code>   查找的时候指挥查找满足类型条件的最后一个元素</li>
<li><code>li:nth-child()</code> 指定索引位置 nth-child(从1开始的所以||关键字||表达式) /  该方法同样 &gt; 如果第一个不是li 那就不生效<ul>
<li>even 偶数</li>
<li>odd  奇数</li>
</ul>
</li>
<li><code>li:nth-of-type(even)</code>    指定类型的 所有偶数 li </li>
<li><code>li:nth-of-type(-n+5)</code>    只选择前5个li</li>
<li><code>li:nth-last-of-type(-n+5)</code>    只选择最后5个li</li>
<li><code>li:empty</code>     选择内容为空的li</li>
</ul>
<h2 id="伪类样式"><a href="#伪类样式" class="headerlink" title="伪类样式"></a>伪类样式</h2><ul>
<li><code>h2:target</code> 可以为锚点目标元素添加样式，当目标元素被触发为当前锚链接的目标时，调用此伪类样式</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><blockquote>
<p>是一个行内元素， 如果想设置宽高需要转换成block|| float || postition<br>必须添加 content, 哪怕不设置内容， 也要 content:””</p>
</blockquote>
<ul>
<li><code>e::before</code></li>
<li><code>e::after</code></li>
<li><code>e::first-letter</code>  文本的第一个字母或字(不是词组) <ul>
<li>依靠float 实现首字下沉</li>
</ul>
</li>
<li><code>e::first-line</code>   文本第一行  ，  如果第一个字设置了<code>::first-letter</code> 这些样式都对它无效</li>
<li><code>e::selection</code>  可改变选中文本的样式，只能设置显示的样式，而不能设置内容的大小</li>
</ul>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><blockquote>
<p> shape : 渐变的形状</p>
<p>ellipse 表示椭圆形（适配当前的形状），circle 表示正圆形 </p>
<p>如果宽 高不一样  默认效果切换到 ellipse</p>
</blockquote>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><blockquote>
<p>固定列数时可以使用<br>有点类似表格布局<br>比较适合文字</p>
</blockquote>
<ul>
<li>只需再父容器上 加上 <code>column-count: 3</code>  想要几列就写几</li>
<li><code>column-rule:dashed 3px red;</code> 设置边框样式，这是虚线边框</li>
<li><code>column-gap: 0px;</code>   设置列与列之间的间距 , 为0时是没有边框的</li>
<li><p><code>column-width: 500px;</code>  </p>
<ul>
<li><p>取大优先，看看是自动计算的宽度大还是你设置的大</p>
<ul>
<li>但是会填充整个屏幕 ，意味最终的宽度可能会大于设置的宽度–</li>
</ul>
<p>​        填充满整个屏幕</p>
<ul>
<li>如果人为设置宽度更小，使用自动计算的宽度</li>
</ul>
</li>
</ul>
</li>
<li><code>column-span: all;</code> 使某文字或某元素占满一整行</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML和CSS巩固</title>
    <url>/2019/04/10/%E3%80%90imooc%E3%80%91HTML%E5%92%8CCSS%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><blockquote>
<p>如何理解HTML<br>html “文档”<br>描述文档的”结构”<br>有区块和大纲</p>
<ul>
<li><code>&lt;base href=&quot;/&quot;&gt;</code> 指定基础路径 ,只有所有的链接都是以该路径为基准来进行计算</li>
<li><code>label</code> 中 <code>for</code> = 表单项的<code>id</code> 可以和表单项关联, 你点击这个<code>label</code>就好比点击这个表单项本身 </li>
<li><code>button tyle=&quot;reset&quot;&gt;</code>  初始化表单</li>
<li>jQurey 的  <code>$(&quot;form&quot;).serialize()</code>  的方法可以批量获得表单的属性</li>
<li>了解下html 5的 <code>内容模型</code> 分类规则 <code>https://www.w3.org/TR/html5/text-level-semantics.html#the-a-element</code></li>
<li>块级元素不一定能包含块级元素  如: p 中不能包含div  ,强行包裹渲染时浏览器会进行容错模式会以为你写错了, p的开始标签会被当成一个标签,div 还是div ,p 的结束标签又会被当成一个独立的标签</li>
<li>行内元素一般不能包含块级元素 ,  但也有例外, 比如:  a  但在html4中是不合法的,,h5中计算时会将其透明化,也就是说计算合法性时会不考虑 a , 但比如  a&gt;div 这样包裹,还是要取决于 它们外部时什么元素才能决定是否合法</li>
<li>a 中同样不能包含  a  强行包裹渲染时会被分离</li>
</ul>
</blockquote>
<h2 id="html-元素默认样式"><a href="#html-元素默认样式" class="headerlink" title="html 元素默认样式"></a>html 元素默认样式</h2><blockquote>
<p>默认样式的意义在于, 你可以直接书写代码就会在页面上出现效果,而不是每创建一个元素都要去临时给他 宽高颜色之类的 才会在页面上出现\<br>但也会带来一些问题, 有时会导致和我预期想要实现效果截然不同的情况<br>所以需要适当清除默认样式  叫做 <code>css Reset</code>  可以去百度下著名的写法,比如 : 雅虎 YUI  的 css reset 写法 或者是 <code>Normalize.css</code> 让默认样式有效化</p>
</blockquote>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>doctype的意义是什么<ul>
<li>让浏览器以标准模式渲染</li>
<li>让浏览器知道元素的合法性</li>
</ul>
</li>
<li>html、xhtml、html5之间的关系<ul>
<li>HTML属于SGML</li>
<li>XHTML 属于XML, 是XTML进行xml严格化的结果</li>
<li>HTML5不属于SGML或XML,比XHTML宽松</li>
</ul>
</li>
<li>HTML 5 有什么变化<ul>
<li>新的语义化元素</li>
<li>表单增强</li>
<li>新的API (离线、音视频、实时通信、本地存储、设备能力  )</li>
<li>分类和嵌套变更</li>
</ul>
</li>
<li>em 和 i 有什么区别<ul>
<li>em是语义化的标签, 表强调</li>
<li>i 是纯样式的标签, 表示斜体</li>
<li>HTML5中 i 不推荐使用, 一般用作图标</li>
</ul>
</li>
<li>语义化的意义是什么<ul>
<li>开发者容易理解</li>
<li>机器容易理解结构  (搜索、读屏软件)   ,比如 大纲算法</li>
<li>有助于 SEO </li>
<li>semantic microdata  增强语义化   , 详细的需要去百度</li>
</ul>
</li>
<li>哪些元素可以自闭和 ( 就是在该标签内部不能再带其他东西了 )<ul>
<li>表单元素 Input</li>
<li>图片 img</li>
<li>br hr</li>
<li>meta link</li>
</ul>
</li>
<li>HTML 和 DOM 的关系<ul>
<li>HTML是 “ 死 “ 的</li>
<li>DOM 由HTML解析而来, 是活的</li>
<li>js 可以维护DOM</li>
</ul>
</li>
<li>property 和 attribute 的区别<ul>
<li>attribute 是 “死” 的  , 是你写在HTML上的属性</li>
<li>property  是 “ 活 “ 的 , 是dom 解析后获得的</li>
</ul>
</li>
<li>form的作用有哪些<ul>
<li>直接提交表单</li>
<li>使用submit / reset 按钮</li>
<li>便于浏览器保存表单</li>
<li>第三库可以整体提取值 如: JQuery</li>
<li>第三方库可以进行表单验证, 比如 angular</li>
</ul>
</li>
</ul>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote>
<p>全称  Cascading Style Sheet 层叠样式表</p>
<ul>
<li>id选择器 样式的权重优先级最高 class选择器 其次</li>
<li>解析方式, <code>body div a { }</code> 这样的一个css 浏览器是先找到a标签,再找到它父级有没有 div ,再去找 body  ,总结就是: 从右往左解析,目的就是加快 浏览器对css 的解析速度,更快确定是哪些元素</li>
<li>伪类和伪元素的区别</li>
</ul>
</blockquote>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><ul>
<li>元素选择器 a{}</li>
<li>伪元素选择器 ::before{}</li>
<li>类选择器 .link{}</li>
<li>属性选择器 [type = radio] {}</li>
<li>伪类选择器 :hover{}</li>
<li>id选择器 #id{}</li>
<li>组合选择器 [type=checkbox] + label{}</li>
<li>否定选择器 :not(.link){}</li>
<li><p>通用选择器 * {}</p>
<h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3><blockquote>
<p>必须遵守的是  只要有id 选择器 永远比 class 选择器要大, 并不能通过选择器数量盖过 id 选择器的权重,  官大一级压死人  , class再多  权重 也无法 从 十位 进到 百位, 因为权重不进位</p>
</blockquote>
</li>
<li><p>ID 选择器 #id{}  +100</p>
</li>
<li>类  属性  伪类 选择器  +10</li>
<li>元素 伪元素   +1</li>
<li>其他选择器   +0</li>
<li>还有一些需要注意的<ul>
<li>!important 优先级最高 ( 不管你出现在哪,不管是谁写的 ,永远最高 )</li>
<li>元素属性 优先级高  ==&gt; 比ID 选择器还要高  ( 元素属性上写style 比外联和内嵌样式表优先级高 )</li>
<li>相同权重 后写的生效</li>
</ul>
</li>
</ul>
<h2 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h2><ul>
<li>line-hight 会撑起 block 元素, inline 则本身无变化,但实际占用高度会被影响</li>
<li>图片下方会出现空隙的原因 : 因为图片是 按inline 来排版, 参照的是基线 ( base-line ), 而基线和底线又有一定的距离,这个距离视字体大小而定 , 例如当12px时 ,这个距离大约是3px </li>
</ul>
<h2 id="css-Hack"><a href="#css-Hack" class="headerlink" title="css  Hack"></a>css  Hack</h2><blockquote>
<p>在一部分浏览器上生效的写法</p>
<ul>
<li>Hack 即不合法但生效的写法</li>
<li>主要用于区分不同浏览器</li>
<li>缺点: 难理解  难维护 易失效</li>
<li>替代方案: 特性检测</li>
<li>替代方案: 针对性加 class</li>
</ul>
</blockquote>
<h2 id="取色方式"><a href="#取色方式" class="headerlink" title="取色方式"></a>取色方式</h2><ul>
<li>RGB 方式 (方便,但是人眼对rgb不是很敏感)<ul>
<li>#fff</li>
<li>rgb</li>
<li>rgba</li>
</ul>
</li>
<li>hsl ( 色相, 饱和度,  亮度) <ul>
<li>hsl </li>
<li>hsla( 色相, 饱和度,  亮度, 透明度) <h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="载入自定义字体"><a href="#载入自定义字体" class="headerlink" title="载入自定义字体"></a>载入自定义字体</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"IF"</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"./IndieFlower.ttf"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: IF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>css 样式 ( 选择器 ) 的优先级<ul>
<li>计算权重确定</li>
<li>!important</li>
<li>内联样式</li>
<li>后写的优先级高</li>
</ul>
</li>
<li>雪碧图的作用<ul>
<li>减少http请求次数 提高加载性能</li>
<li>有些情况下可以减少图片大小</li>
</ul>
</li>
<li>自定义字体的使用场景<ul>
<li>1.宣传 / 品牌 / Banner等固定文案</li>
<li>2.字体图标</li>
</ul>
</li>
<li>base64 的使用<ul>
<li>减少http请求</li>
<li>适用于小图片</li>
<li>base64的体积约为原图 4 / 3</li>
</ul>
</li>
<li>伪类和伪元素的区别<ul>
<li>伪类表状态</li>
<li>伪元素是真的有元素</li>
<li>前者单冒号, 后者双冒号</li>
</ul>
</li>
<li>如何梅花checkbox<ul>
<li>label [ for ] 和 id</li>
<li>隐藏原生 Input</li>
<li>:checked + label</li>
</ul>
</li>
</ul>
<h1 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h1><blockquote>
<p>npm install  postcss  -g<br>文件输出命令<br>postcss  src/aa.css   -o  bb.css </p>
</blockquote>
<h2 id="autoprefixer-自动加前缀"><a href="#autoprefixer-自动加前缀" class="headerlink" title="autoprefixer 自动加前缀"></a>autoprefixer 自动加前缀</h2><blockquote>
<p>npm install  autoprefixer</p>
</blockquote>
<h2 id="psostcss-import-模块化css"><a href="#psostcss-import-模块化css" class="headerlink" title="psostcss-import 模块化css"></a>psostcss-import 模块化css</h2><blockquote>
<p>npm install  postcss-import</p>
</blockquote>
<h2 id="cssnano-压缩css代码"><a href="#cssnano-压缩css代码" class="headerlink" title="cssnano  压缩css代码"></a>cssnano  压缩css代码</h2><blockquote>
<p>npm install  cssnano</p>
</blockquote>
<h2 id="cssnext-使用浏览器未支持的css"><a href="#cssnext-使用浏览器未支持的css" class="headerlink" title="cssnext    使用浏览器未支持的css"></a>cssnext    使用浏览器未支持的css</h2><blockquote>
<p>npm install  postcss-cssnext</p>
</blockquote>
<h2 id="precss-用预处理的语法写css-循环-变量"><a href="#precss-用预处理的语法写css-循环-变量" class="headerlink" title="precss  用预处理的语法写css /循环/变量"></a>precss  用预处理的语法写css /循环/变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const autoprefixer = require(&apos;autoprefixer&apos;)</span><br><span class="line">const atImport = require(&apos;postcss-import&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        atImport,</span><br><span class="line">        autoprefixer(</span><br><span class="line">            &#123;</span><br><span class="line">            browsers:[&apos;&gt;0%&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="webpack-打包后js-与-css-分离"><a href="#webpack-打包后js-与-css-分离" class="headerlink" title="webpack 打包后js 与 css 分离"></a>webpack 打包后js 与 css 分离</h2><blockquote>
<p>npm install extract-text-webpack-plugin</p>
</blockquote>
<blockquote>
<p><img src="C:\Users\Lei\AppData\Local\Temp\1528628764809.png" alt="1528628764809"></p>
</blockquote>
<ul>
<li>loader 配置</li>
</ul>
<p><img src="C:\Users\Lei\AppData\Local\Temp\1528628596610.png" alt="1528628596610"></p>
<ul>
<li><p>文件输出</p>
<p><img src="C:\Users\Lei\AppData\Local\Temp\1528628686140.png" alt="1528628686140"></p>
</li>
</ul>
<h1 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h1><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>实现两栏 ( 三栏 ) 布局<ul>
<li>表格布局</li>
<li>float + margin 布局</li>
<li>inline-block布局</li>
<li>flexbox布局</li>
</ul>
</li>
<li>position:absolute / fixed 有什么区别<ul>
<li>前者相对最近的absolute / relative 进行定位</li>
<li>后者相对屏幕 或 移动端的 viewport 进行定位</li>
</ul>
</li>
<li>display:inline-block 的间隙<ul>
<li>原因: 字符间距</li>
<li>解决: 消灭字符或者消灭间距</li>
</ul>
</li>
<li>如何清楚浮动<ul>
<li>让盒子负责自己的布局</li>
<li>overflow:hidden( auto )</li>
<li>::after{ clear:both }</li>
</ul>
</li>
<li>如何适配移动端页面<ul>
<li>viewport</li>
<li>rem / viewport / media query</li>
<li>设计上: 隐藏  折行  自适应</li>
</ul>
</li>
</ul>
<h1 id="浏览器小技巧"><a href="#浏览器小技巧" class="headerlink" title="浏览器小技巧"></a>浏览器小技巧</h1><ul>
<li><code>$0</code> 获取当前选中的元素DOM</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>【Node】mongose基本使用</title>
    <url>/2019/04/10/%E3%80%90Node%E3%80%91mongose%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="NodeJS-与-MongooDB"><a href="#NodeJS-与-MongooDB" class="headerlink" title="NodeJS 与 MongooDB"></a>NodeJS 与 MongooDB</h1><blockquote>
<p>在NodeJs 中推荐使用 Mongoose来对mongoDB 进行操作<br>mongoose 官网  <a href="http://mongoosejs.com/" target="_blank" rel="noopener">http://mongoosejs.com/</a></p>
</blockquote>
<h2 id="mongoDB-的特点"><a href="#mongoDB-的特点" class="headerlink" title="mongoDB 的特点"></a>mongoDB 的特点</h2><ul>
<li>JSON 格式的数据存储</li>
<li>非关系型数据库</li>
<li>不需要和 MYSQL 之类的关系型数据库一样简表, 使用时若没有该集合会自动创建</li>
<li>集合 =&gt; 文档 =&gt; 记录/数据字段</li>
<li>缺点就是数据操作太灵活, 容易混入脏数据</li>
</ul>
<h2 id="如何安装-mongoose"><a href="#如何安装-mongoose" class="headerlink" title="如何安装 mongoose"></a>如何安装 mongoose</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
<h2 id="导入Mongooes"><a href="#导入Mongooes" class="headerlink" title="导入Mongooes"></a>导入Mongooes</h2><ul>
<li>在 Node 中 需要先使用 require 导入mongoose 模块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mongoose = require(&apos;mongoose&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h2><ul>
<li>这里拿连接本地的mongoDB 示范<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongoose.connect(&apos;mongod://localhost/test&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="引入数据库模型骨架-Schema"><a href="#引入数据库模型骨架-Schema" class="headerlink" title="引入数据库模型骨架 Schema"></a>引入数据库模型骨架 Schema</h2><ul>
<li>Schema 在导入的 mongoose 对象中, 建议先将其的引用存入一个变量</li>
<li>Schema  是一种以文件形式存储的数据库模型骨架,</li>
<li>它不具备对数据库的操作能力</li>
<li>它可以弥补 mongoDB 对数据格式控制的不足<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Schema = mongoose.Schema</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实例化-Schema"><a href="#实例化-Schema" class="headerlink" title="实例化 Schema"></a>实例化 Schema</h2><ul>
<li>既然是模型骨架,  那我们就需要 将它的骨架搭建起来</li>
<li>以下举例 一个用户注册使用的 骨架模型</li>
<li>type (数据类型)   如: String ,Number</li>
<li>required (  是否允许为空 )<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let userSchema = new Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type: String,</span><br><span class="line">        required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    email: &#123;</span><br><span class="line">        type: String</span><br><span class="line">    &#125;,</span><br><span class="line">    pwd:&#123;</span><br><span class="line">        type: String,</span><br><span class="line">        required: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="发布模型-Model"><a href="#发布模型-Model" class="headerlink" title="发布模型 Model"></a>发布模型 Model</h2><ul>
<li>由搭建好的模型骨架 Schema 发布生成的模型, 具有抽象属性和数据库操作的能力</li>
<li>Model 第一个参数 单数形式开头大写 , Mongoose 会自动将其转换为小写的负数形式作为文档名称</li>
<li>如: User =&gt; users</li>
<li>接下来你就可以对 User 为所欲为了, CURD<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const User = mongoose.model(&apos;Use&apos;,userSchema)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Sava-方法-保存数据"><a href="#Sava-方法-保存数据" class="headerlink" title="Sava 方法 保存数据"></a>Sava 方法 保存数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.save()</span><br><span class="line">	.then(() =&gt; console.log(&apos;保存成功&apos;));</span><br></pre></td></tr></table></figure>
<h2 id="Remove-删除数据"><a href="#Remove-删除数据" class="headerlink" title="Remove 删除数据"></a>Remove 删除数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.remove(&#123; 删除条件 &#125;)</span><br><span class="line">.then(res=&gt;&#123; &#125;)</span><br><span class="line">.catch(err=&gt;&#123; &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="FindOne-返回匹配到的第一条数据"><a href="#FindOne-返回匹配到的第一条数据" class="headerlink" title="FindOne 返回匹配到的第一条数据"></a>FindOne 返回匹配到的第一条数据</h2><ul>
<li>如果用 Find 查找是返回的数组, FindOne 返回的就是个单独的对象</li>
<li>注意返回的 的查询结果可以经过修改之后为所欲为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.findOne( &#123; 查询条件 &#125; )</span><br><span class="line">  .then(data=&gt;&#123;</span><br><span class="line">     //you can</span><br><span class="line">    // data.save()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Find-查找满足条件的所有"><a href="#Find-查找满足条件的所有" class="headerlink" title="Find 查找满足条件的所有"></a>Find 查找满足条件的所有</h2><ul>
<li>和 FinOne 不同的是 无论结果有多少条,它返回的始终是一个数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.find( &#123; 查询条件 &#125; )</span><br><span class="line">  .then(data=&gt;&#123;</span><br><span class="line">     //you can</span><br><span class="line">    // data.save()</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>【win10】解决经常性内存爆满100%</title>
    <url>/2019/04/10/%E3%80%90win10%E3%80%91%E8%A7%A3%E5%86%B3%E7%BB%8F%E5%B8%B8%E6%80%A7%E5%86%85%E5%AD%98%E7%88%86%E6%BB%A1100/</url>
    <content><![CDATA[<p>问题解决，killer网卡驱动与ndu网络驱动冲突，导致wfpn与ndnb标签池有内存泄漏。解决方法：管理员运行cmd，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc config Ndu start=disabled</span><br></pre></td></tr></table></figure>
<p>参考文献:</p>
<ul>
<li><a href="http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1737577&amp;highlight=" target="_blank" rel="noopener">http://bbs.pcbeta.com/forum.php?mod=viewthread&amp;tid=1737577&amp;highlight=</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【记录】记一次优化时间线卡顿处理思路</title>
    <url>/2019/04/10/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E5%8D%A1%E9%A1%BF%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>公司有这样的应用场景， 需要按时间段来分类图片， 然后各个分类之间还有联系， 因为有可能上一个分段的后面一部分图片和下一个分段的钱一部分图片在同一个分页。 </p>
<p><img src="http://img.nixiaolei.com/2019-09-10-20-36-59.png" alt="2019-09-10-20-36-59"></p>
<p>打开某一分类：<br><img src="http://img.nixiaolei.com/2019-09-10-20-52-42.png" alt="2019-09-10-20-52-42"></p>
<p>在这种场景下， 我们需要考虑:</p>
<ol>
<li>如何把归类的图片同时保持相应的顺序成一组</li>
<li>当我打开并不是连续的分段时， 中间的分段如何空出来， 以便于后续插入， 同时插入后还要保证 <code>1</code> </li>
<li>打开一个分类时会加载大量图片， 此时加载资源会阻塞网络， 图片归类计算会阻塞进程， 图片量大的时候性能会出问题</li>
<li>当用户滚动时， 需要加载分页</li>
<li>滚动时分页加载的数据， 不能和用户主动打开时的数据冲突重复</li>
</ol>
<hr>
<p>解决思路</p>
<ol>
<li>首先可以创建一个数组或是字典， 存储已加载的页码， 用来过滤重复加载的情况</li>
<li>以用户展开指定操作为优先， 滚动加载数据为次要，  当用户滚动时 ， 我们不要立即加载， 先存在一个队列里， 设置一个延迟时间， 在这段时间内， 用户有任何和加载相关的操作就将 分页的请求无限期延后， 直到在一段时间内都无任何操作后， 才开始从队列中取出需要加载的分页， 挨个加载（注意不要一起加载， 加载图片会阻塞网络）。</li>
<li>大图索引问题， 维护一个二为数组 和一个一维数组， 一维数组用来给大图使用，因为大图需要连续的滑动下一页操作， 二位数组用来渲染页面</li>
</ol>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】从高阶函数到理解高阶组件</title>
    <url>/2019/04/09/%E3%80%90React%E3%80%91%E4%BB%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%88%B0%E7%90%86%E8%A7%A3%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>高阶组件其实就是高阶函数</p>
<p>高阶函数的概念千万别和普通回调搞混， 高阶函数的必要条件：</p>
<ul>
<li>一定要返回一个新函数</li>
<li>非入侵</li>
</ul>
<h2 id="一句话理解高阶函数"><a href="#一句话理解高阶函数" class="headerlink" title="一句话理解高阶函数"></a>一句话理解高阶函数</h2><p>本来我没有的，我很垃圾，  通过把我交给别人， 在我身上装了额外的东西， 使我变的拥有了某种能力</p>
<p>举个例子:  人和坦克， 本来人是不能发射炮弹的， 但是人钻进了坦克， 就可以发射炮弹了， 人还是人（自身未变）， 只是在坦克里了</p>
<h2 id="一个例子理解高阶函数"><a href="#一个例子理解高阶函数" class="headerlink" title="一个例子理解高阶函数"></a>一个例子理解高阶函数</h2><p>一个简单的不能再简单的高阶函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    fn()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="一个例子理解高阶组件"><a href="#一个例子理解高阶组件" class="headerlink" title="一个例子理解高阶组件"></a>一个例子理解高阶组件</h2><p>在不修改原有组件的情况下， 为其添加一个生命周期</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收一个组件参数</span></span><br><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增的生命周期</span></span><br><span class="line">    componentwillmount() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'增加一个生命周期'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 传入的组件</span></span><br><span class="line">        &lt;WrappedComponent /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyContainer;</span><br></pre></td></tr></table></figure>
<h2 id="随处可见的高阶函数"><a href="#随处可见的高阶函数" class="headerlink" title="随处可见的高阶函数"></a>随处可见的高阶函数</h2><p>node的<code>express</code>框架中, 你的<code>app.use</code>就是典型的高阶组件</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s学习笔记</title>
    <url>/2019/04/09/k8s%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="什么是K8s"><a href="#什么是K8s" class="headerlink" title="什么是K8s"></a>什么是K8s</h2><ul>
<li>Kubernetes，因为首尾字母中间有8个字符，所以被简写成 K8s。</li>
<li>K8s 是底层资源与容器间的一个抽象层，如果和单机架构类比，可以算作是一个分布式时代的 Linux。</li>
<li>K8s 是 Google 开源的容器集群管理系统。在 Docker 技术的基础上，为容器化的应用提供<code>部署运行</code>、<code>资源调度</code>、<code>服务发现</code>和<code>动态伸缩</code>等一系列完整功能，提高了大规模容器集群管理的便捷性。</li>
</ul>
<h2 id="K8S的特点"><a href="#K8S的特点" class="headerlink" title="K8S的特点"></a>K8S的特点</h2><ul>
<li>k8s是一个管理容器的工具，也是管理应用整个生命周期的一个工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，而且可以做到<code>故障自愈</code>。</li>
<li>可移植：支持公有云，私有云，混合云；</li>
<li>可扩展：模块化，热插拨，可组合；</li>
<li>自愈：自动替换，自动重启，自动复制，自动扩展。</li>
</ul>
<blockquote>
<p>故障自愈场景比如机房工作人员误操作将某一排服务器断电了， k8s就会认为是故障， 自动扩充备用服务器</p>
</blockquote>
<h2 id="K8S的管理步骤"><a href="#K8S的管理步骤" class="headerlink" title="K8S的管理步骤"></a>K8S的管理步骤</h2><p>在k8s进行管理应用的时候，基本步骤是：</p>
<ul>
<li>创建集群</li>
<li>部署应用</li>
<li>发布应用</li>
<li>扩展应用</li>
<li>更新应用</li>
</ul>
<h2 id="K8S的架构结构"><a href="#K8S的架构结构" class="headerlink" title="K8S的架构结构"></a>K8S的架构结构</h2><ul>
<li>生态系统<ul>
<li>外部生态（k8s运行过程中产出的来判断，如：日志、监控、配置功能、自动化发布、工作流）</li>
<li>内部生态（系统本身所依赖的东西， 如：镜像管理、镜像仓库、集群配置管理）</li>
</ul>
</li>
<li>接口层<ul>
<li>用于开发和管理生态系统层</li>
</ul>
</li>
<li>管理层<ul>
<li>系统层面的调度，比如：自动扩展， 监视、资源状态</li>
</ul>
</li>
<li>应用层<ul>
<li>部署及路由<ul>
<li>处理有状态应用和无状态应用</li>
<li>路由根据内部的<code>dns</code>服务器</li>
</ul>
</li>
</ul>
</li>
<li>核心层<ul>
<li>k8s的核心功能， 提供程序内部接口</li>
</ul>
</li>
<li>核心模块及插件</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-13-13-48-43.png" alt="k8s架构结构"></p>
<p>k8s是和<code>TCP/IP</code>协议很像都是不允许跨层的， 当生态系统层的功能不够使用时， 你只能通过接口层来开发，不能使用更下层的东西了</p>
<h2 id="k8s相关概念"><a href="#k8s相关概念" class="headerlink" title="k8s相关概念"></a>k8s相关概念</h2><ul>
<li><strong>主机（Master）</strong>：用于控制 <code>Kubernetes</code> 节点的计算机。所有任务分配都来自于此。</li>
<li><strong>节点（Node）</strong>：执行请求和分配任务的计算机。由 <code>Kubernetes</code> 主机负责对节点进行控制。</li>
<li><strong>容器集（Pod）</strong>：部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将<code>网络</code>和<code>存储</code>从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。</li>
<li><strong>复制控制器（Replication controller）</strong>： 用于控制应在集群某处运行的完全相同的容器集副本数量。</li>
<li><strong>服务（Service）</strong>：服务可将工作定义与容器集分离。<code>Kubernetes</code> 服务代理会自动将服务请求分配到正确的容器集——无论这个容器集会移到集群中的哪个位置，即使它已被替换。</li>
<li><strong>Kubelet</strong>： 这是一个在节点上运行的服务，可读取容器清单，确保指定的容器启动并运行。</li>
<li><strong>kubectl</strong>： <code>Kubernetes</code> 的命令行配置工具</li>
</ul>
<blockquote>
<p>如果数据库安装于容器内部， 则在数据膨胀后，想要升级数据库就变得十分的困难， 容器集将他从容器中抽象出来便于移动管理容器</p>
</blockquote>
<h2 id="k8s整体流程"><a href="#k8s整体流程" class="headerlink" title="k8s整体流程"></a>k8s整体流程</h2><ul>
<li>容器间都由<code>Master</code>统一管理， 一个容器想知道另一个容器的服务， 就必须询问<code>master</code>, 由<code>master</code>引导调度 </li>
<li><code>Linux</code> 的<code>etc</code>相当于<code>window</code>的注册表, <code>Linux</code>中的配置文件和<code>window</code>不一样， <code>window</code>是集中管理 ，<code>Linux</code>是分散管理,  <code>etcd</code>就是为了解决多集群时配置文件难以维护的问题</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-13-14-57-25.png" alt="k8s架构结构"></p>
<h2 id="安装K8S"><a href="#安装K8S" class="headerlink" title="安装K8S"></a>安装K8S</h2><p>在<code>Linux</code>下安装单机版的集群环境<br>以root身份执行以下操作：</p>
<h3 id="1-关闭Linux防火墙"><a href="#1-关闭Linux防火墙" class="headerlink" title="1. 关闭Linux防火墙"></a>1. <strong>关闭<code>Linux</code>防火墙</strong></h3><blockquote>
<p>如果不关闭可能会在<code>SELinux</code> 安全模块上出问题</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<h3 id="2-安装Kubernetes和依赖组件etcd"><a href="#2-安装Kubernetes和依赖组件etcd" class="headerlink" title="2. 安装Kubernetes和依赖组件etcd"></a>2. <strong>安装<code>Kubernetes</code>和依赖组件<code>etcd</code></strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y etcd kubernetes</span><br></pre></td></tr></table></figure>
<h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. <strong>修改配置</strong></h3><blockquote>
<p>docker 中的 <code>SElinux</code>安全模块也要关闭</p>
</blockquote>
<ul>
<li>Docker配置文件/etc/sysconfig/docker, OPTIONS=’–selinux-enabled=false –insecure-registry gcr.io’</li>
<li>Kubernetes apiservce配置文件/etc/kubernetes/apiserver,把–admission-control参数中的ServiceAccount删除</li>
</ul>
<h3 id="4-按顺序启动所有的服务"><a href="#4-按顺序启动所有的服务" class="headerlink" title="4. 按顺序启动所有的服务"></a>4. <strong>按顺序启动所有的服务</strong></h3><ul>
<li>提供配置存储: <code>systemctl start etcd</code></li>
<li>k8s node的重要服务: <code>systemctl start docker</code></li>
<li>提供客户端接口: <code>systemctl start kube-apiserver</code></li>
<li>systemctl start kube-controller-manager</li>
<li>提供管理功能： <code>systemctl start kube-scheduler</code></li>
<li>提供pod功能: <code>systemctl start kubelet</code></li>
<li>提供路由请求: <code>systemctl start kube-proxy</code></li>
</ul>
<h2 id="K8S相关资源"><a href="#K8S相关资源" class="headerlink" title="K8S相关资源"></a>K8S相关资源</h2><p>1、官网</p>
<blockquote>
<p><a href="https://kubernetes.io" target="_blank" rel="noopener">https://kubernetes.io</a></p>
</blockquote>
<p>2、Chart 应用仓库</p>
<blockquote>
<p><a href="https://hub.kubeapps.com/" target="_blank" rel="noopener">https://hub.kubeapps.com/</a></p>
</blockquote>
<p>3、中文手册</p>
<blockquote>
<p><a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">https://www.kubernetes.org.cn/docs</a></p>
</blockquote>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>容器技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】为什么要使用immutableJs</title>
    <url>/2019/04/08/%E3%80%90React%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8immutableJs/</url>
    <content><![CDATA[<h2 id="React自身的一些Bug"><a href="#React自身的一些Bug" class="headerlink" title="React自身的一些Bug"></a>React自身的一些Bug</h2><p>在开发中对<code>React</code>应用做性能优化时， 我们通常会使用<code>shouldComponentUpdate</code> 这个生命周期钩子来决定该组件是否需要更新， 来过滤掉没有意义的更新修改。 </p>
<p>并且，官方也贴心的为我们提供了 <code>PureComponent</code> 用来省去我们繁琐的判断， 自动生成<code>shouldComponentUpdate</code></p>
<p>但现实往往不是那么的完美， <code>PureComponent</code> 也有解决不了问题的时候， </p>
<p>为了更好的理解， 我们先来显示的使用<code>shouldComponentUpdate</code>操作一遍</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; </span><br><span class="line">      todoList: [</span><br><span class="line">       <span class="string">'喝可乐'</span>, </span><br><span class="line">       <span class="string">'打游戏'</span></span><br><span class="line">      ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.state.todoList != nextState.todoList ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'两次不一致， 同意更新'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新前后todolist 一致， 所以不更新'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组concat操作， 会返回新数组</span></span><br><span class="line">  concatHandle() &#123;</span><br><span class="line">    <span class="keyword">let</span> todoList = <span class="keyword">this</span>.state.todoList</span><br><span class="line">    <span class="keyword">const</span> rd = <span class="built_in">Math</span>.random() * <span class="number">30</span></span><br><span class="line">    todoList = todoList.concat([ <span class="string">`搞事情:<span class="subst">$&#123;rd&#125;</span>`</span> ])</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">      todoList</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组Push操作， 未改变原数组</span></span><br><span class="line">  pushHandle() &#123;</span><br><span class="line">    <span class="keyword">let</span> todoList = <span class="keyword">this</span>.state.todoList</span><br><span class="line">    <span class="keyword">const</span> rd = <span class="built_in">Math</span>.random() * <span class="number">30</span></span><br><span class="line">    todoList.push( <span class="string">`搞事情:<span class="subst">$&#123;rd&#125;</span>`</span> )</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">      todoList</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"wrap"</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.pushHandle()&#125;&gt;Push操作&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.concatHandle()&#125;&gt;concat操作&lt;/</span>button&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          todoList.map( <span class="function">(<span class="params">item,index</span>) =&gt;</span> &lt;TodoItem key=&#123;index&#125;  thing=&#123;item&#125; /&gt; )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件</span></span><br><span class="line"><span class="regexp">class TodoItem extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123; this.props.thing &#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>shouldComponentUpdate</code> 进行了简单的判断， 但是可悲的是这只在对比普通类型时比较的奏效， 因为<code>JavaScript</code>中存在这引用类型的概念， 所以对于引用类型来说<code>==</code> 会变成判断该变量地址的操作</p>
<p>口说无凭，我们来看看实际的情况。 </p>
<p><img src="http://img.nixiaolei.com/pureCompoents.gif" alt="ReactBug"></p>
<p>我的天，这是怎么回事， 实际情况好像要更复杂一些！<br>点击了两次<code>Push</code>没有反应， 然而在点击<code>concat</code>的时候， 一瞬间多出了<code>3</code>条</p>
<h3 id="冷静分析"><a href="#冷静分析" class="headerlink" title="冷静分析"></a>冷静分析</h3><p>对于这种种非正常现象， 我们有必要保持清新的头脑去分析一下</p>
<p><img src="http://img.nixiaolei.com/2019-04-08-22-39-14.png" alt="别慌"></p>
<p>我们可以看到， 第一次点击<code>push</code>操作， 页面没有任何反应， 只是在控制台打印了<code>更新前后todolist 一致， 所以不更新</code>,</p>
<p>哦~， 看到这个我们知道了， 此次组件的更新被<code>shouldComponentUpdate</code>拦截了，  这怎么行呢， 我要更新的你给我拦截了， 我数组明明变化了啊， 我数组新增了内容， 你就该给我正常变化， 这不是坑人吗</p>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>看到这，你可能会说， 官方不是提供了<code>PureComponent</code>吗，  官方给的还能跟你一样这么龊？  该更新的不更新？</p>
<p>您还别不信， 它就这么龊， <code>PureComponent</code> 其实是很傻的， 他也只是单纯的帮我们做了上面我们那样的操作， 虽然这样针对基本类型来说已经非常够用了， 能够解决问题了， 但是一旦遇上了引用类型， 它可就歇菜了， 还会引起你页面的奇妙<code>Bug</code></p>
<p>不信咱们来测试下， 我们修改下父组件代码， 子组件保持一致:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换为 PureComponent</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; </span><br><span class="line">      todoList: [</span><br><span class="line">       <span class="string">'喝可乐'</span>, </span><br><span class="line">       <span class="string">'打游戏'</span></span><br><span class="line">      ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  ------------ 删除掉 shouldComponentUpdate ------------------------</span></span><br><span class="line">  <span class="comment">// shouldComponentUpdate(nextProps, nextState) &#123;</span></span><br><span class="line">  <span class="comment">//   if( this.state.todoList != nextState.todoList ) &#123;</span></span><br><span class="line">  <span class="comment">//     console.log('两次不一致， 同意更新')</span></span><br><span class="line">  <span class="comment">//     return true</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   console.log('更新前后todolist 一致， 所以不更新')</span></span><br><span class="line">  <span class="comment">//   return false</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  concatHandle() &#123;</span><br><span class="line">    <span class="keyword">let</span> todoList = <span class="keyword">this</span>.state.todoList</span><br><span class="line">    <span class="keyword">const</span> rd = <span class="built_in">Math</span>.random() * <span class="number">30</span></span><br><span class="line">    todoList = todoList.concat([ <span class="string">`concat操作: <span class="subst">$&#123;rd&#125;</span>`</span> ])</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">      todoList</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pushHandle() &#123;</span><br><span class="line">    <span class="keyword">let</span> todoList = <span class="keyword">this</span>.state.todoList</span><br><span class="line">    <span class="keyword">const</span> rd = <span class="built_in">Math</span>.random() * <span class="number">30</span></span><br><span class="line">    todoList.push( <span class="string">`push操作:<span class="subst">$&#123;rd&#125;</span>`</span> )</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">      todoList</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"wrap"</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.pushHandle()&#125;&gt;Push操作&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.concatHandle()&#125;&gt;concat操作&lt;/</span>button&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          todoList.map( <span class="function">(<span class="params">item,index</span>) =&gt;</span> &lt;TodoItem key=&#123;index&#125;  thing=&#123;item&#125; /&gt; )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>来看看结果</p>
<p><img src="http://img.nixiaolei.com/pureComponent02.gif" alt="测试结果"></p>
<p>哎， 还是一样的坑</p>
<p>那这个<code>Bug</code>怎么办， 这时候就请本文的主角<code>immutableJs</code>登场吧</p>
<h2 id="immutableJs"><a href="#immutableJs" class="headerlink" title="immutableJs"></a>immutableJs</h2><blockquote>
<p>Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce、find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。</p>
</blockquote>
<p>使用 <code>immutableJs</code> 避免这个副作用的一种实现是按值传递，也就是拷贝一份再传递过去，有深层结构就深拷贝。深拷贝在只做局部修改的时候做了很多无用功，于是<code>ImmutableJs</code>做了性能优化。</p>
<h3 id="使用它带来的好处"><a href="#使用它带来的好处" class="headerlink" title="使用它带来的好处"></a>使用它带来的好处</h3><p>网上找了个图，假如我们要修改左图中黄色节点的子节点4，那么Immutable.js只需要更新右图中的绿色节点，其余节点不需拷贝，继续复用。也就是说，Immutable.js会更新从根节点到所修改节点路径上的所有节点，由于修改了根节点，所以返回一个新对象，这也解释了为什么能控制副作用。</p>
<p><img src="http://img.nixiaolei.com/2019-04-09-21-43-20.png" alt="更新树"></p>
<ol>
<li>假如你在组件state中保存了一份有深层结构的引用类型的数据，如果没有Immutable.js，你需要深拷贝一份再做修改。而用Immutable.js将state中的数据包装一下，不需深拷贝就可以直接修改。</li>
<li>由于修改后返回的是新对象，React.js只需要在oldState.obj === newState.obj这一层就能判断出obj产生了变化，不需要深入obj的深层结构。</li>
<li>带来几种操作方便的数据结构和API</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js光源入门之聚光灯</title>
    <url>/2019/04/04/%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E8%81%9A%E5%85%89%E7%81%AF/</url>
    <content><![CDATA[<p>聚光灯是一特殊的光源， 聚光灯能朝一个方向投射出锥形的光线。</p>
<h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><ul>
<li>具有锥形效果的光源， 能够朝着一个方向投射光线</li>
<li>最常用到的光源， 它可以产生阴影</li>
<li>锥形效果， 类似电筒光照效果</li>
</ul>
<h3 id="光照效果样例"><a href="#光照效果样例" class="headerlink" title="光照效果样例"></a>光照效果样例</h3><p><img src="http://img.nixiaolei.com/three-SpotLight.png" alt="光照效果样例"></p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><blockquote>
<p>THREE.SpotLight(hex, intensity, distance, angle, exponent)</p>
</blockquote>
<p><code>castShadow</code> —- 如果设置为<code>true</code>, 这个光源就会产生阴影。<br>target —- 决定光照方向。<br>angle —- 光照的角度， 默认值是 <code>Math.PI / 3</code></p>
<h2 id="实践一下"><a href="#实践一下" class="headerlink" title="实践一下"></a>实践一下</h2><p>按照惯例， 我们测试灯光需要有几何物体才能体现出来， 因为聚光灯是中心最亮， 逐渐向外变暗， 所以我们创建几个立方体， 然后想办法摆动一下聚光灯的位置和角度看看具体效果</p>
<h3 id="第一步-创建立方体"><a href="#第一步-创建立方体" class="headerlink" title="第一步-创建立方体"></a>第一步-创建立方体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立方体</span></span><br><span class="line"><span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span><br><span class="line"><span class="comment">// 打开立方体的阴影</span></span><br><span class="line">cube.castShadow = <span class="literal">true</span></span><br><span class="line">cube.position.set(<span class="number">-4</span>, <span class="number">2.5</span>, <span class="number">0</span>)</span><br><span class="line">commonObj.scene.add(cube) <span class="comment">// 调整相机位置</span></span><br></pre></td></tr></table></figure>
<h3 id="第二步-创建球体"><a href="#第二步-创建球体" class="headerlink" title="第二步-创建球体"></a>第二步-创建球体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆球</span></span><br><span class="line"><span class="keyword">var</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> sphreMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGeometry, sphreMaterial)</span><br><span class="line">sphere.position.set(<span class="number">20</span>, <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">commonObj.scene.add(sphere)</span><br></pre></td></tr></table></figure>
<h3 id="第三步-创建聚光灯"><a href="#第三步-创建聚光灯" class="headerlink" title="第三步-创建聚光灯"></a>第三步-创建聚光灯</h3><p>创建聚光灯并将聚光灯的目标调整为刚才创建的 球体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 聚光灯光源</span></span><br><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="string">'#ffffff'</span>)</span><br><span class="line">spotLight.position.x = <span class="number">-40</span></span><br><span class="line">spotLight.position.y = <span class="number">60</span></span><br><span class="line">spotLight.position.z = <span class="number">-12</span></span><br><span class="line"><span class="comment">// 选择照射目标</span></span><br><span class="line">sphere.target = sphere</span><br><span class="line"><span class="comment">// 加入场景</span></span><br><span class="line">commonObj.scene.add(spotLight)</span><br></pre></td></tr></table></figure>
<h3 id="第四步-用键盘控制聚光灯的角度及位置"><a href="#第四步-用键盘控制聚光灯的角度及位置" class="headerlink" title="第四步-用键盘控制聚光灯的角度及位置"></a>第四步-用键盘控制聚光灯的角度及位置</h3><p>键盘方向的上下键控制聚光灯的角度，左右键控制聚光灯的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始角度</span></span><br><span class="line"><span class="keyword">var</span> angleNUM = <span class="number">3</span></span><br><span class="line"><span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 上键 控制聚光灯角度</span></span><br><span class="line">  <span class="keyword">switch</span>(e.keyCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">      angleNUM += <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 下键</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">40</span>: </span><br><span class="line">      angleNUM -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span>( angleNUM &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">        angleNUM = <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 左右键控制聚光灯位移</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">      spotLight.position.x += <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">      spotLight.position.x -= <span class="number">2</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第五步-实时渲染"><a href="#第五步-实时渲染" class="headerlink" title="第五步-实时渲染"></a>第五步-实时渲染</h3><p>在每一帧时根据当前的情况调整聚光灯的角度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(render)</span><br><span class="line">  commonObj.renderer.render(commonObj.scene, commonObj.camera)</span><br><span class="line">  spotLight.angle = <span class="built_in">Math</span>.PI / angleNUM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>该图中， 前半段我先按了上下键来调整聚光灯角度， 后半段我按了左右键来控制聚光灯位置</p>
<p><img src="http://img.nixiaolei.com/three-juguangdeng-keymove.gif" alt="聚光灯效果"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../common/common.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../SceneUtils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../common/common.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> commonObj = common()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 立方体</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 打开立方体的阴影</span></span></span><br><span class="line"><span class="javascript">  cube.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">  cube.position.set(-4, 2.5, 0)</span></span><br><span class="line"><span class="javascript">  commonObj.scene.add(cube) <span class="comment">// 调整相机位置</span></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 圆球</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphreMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGeometry, sphreMaterial)</span></span><br><span class="line"><span class="undefined">  sphere.position.set(20, 6, 0)</span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(sphere)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  commonObj.camera.position.set(<span class="number">-25</span>, <span class="number">20</span>, <span class="number">25</span>) <span class="comment">// 镜头朝向舞台中央</span></span></span><br><span class="line"><span class="undefined">  commonObj.camera.lookAt(commonObj.scene.position)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 聚光灯光源</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="string">'#ffffff'</span>)</span></span><br><span class="line"><span class="undefined">  spotLight.position.x = -40</span></span><br><span class="line"><span class="undefined">  spotLight.position.y = 60</span></span><br><span class="line"><span class="undefined">  spotLight.position.z = -12</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 选择照射目标</span></span></span><br><span class="line"><span class="undefined">  sphere.target = sphere</span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(spotLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.requestAnimationFrame(render)</span></span><br><span class="line"><span class="undefined">    commonObj.renderer.render(commonObj.scene, commonObj.camera)</span></span><br><span class="line"><span class="javascript">    spotLight.angle = <span class="built_in">Math</span>.PI / angleNUM</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置初始角度</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> angleNUM = <span class="number">3</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 上键 控制聚光灯角度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">switch</span>(e.keyCode) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">case</span> <span class="number">38</span>:</span></span><br><span class="line"><span class="undefined">        angleNUM += 1</span></span><br><span class="line"><span class="javascript">        <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 下键</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">case</span> <span class="number">40</span>: </span></span><br><span class="line"><span class="undefined">        angleNUM -= 1</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>( angleNUM &lt; <span class="number">1</span> ) &#123;</span></span><br><span class="line"><span class="undefined">          angleNUM = 1</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 聚光灯位移</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">case</span> <span class="number">37</span>:</span></span><br><span class="line"><span class="undefined">        spotLight.position.x += 2</span></span><br><span class="line"><span class="javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">case</span> <span class="number">39</span>:</span></span><br><span class="line"><span class="undefined">        spotLight.position.x -= 2</span></span><br><span class="line"><span class="javascript">        <span class="keyword">break</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  render()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(commonObj.renderer.domElement)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js光源入门之环境光</title>
    <url>/2019/04/04/%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E5%85%89/</url>
    <content><![CDATA[<p>环境光是环境整体的光照效果， 是场景内若干光源的多次反射形成的一种亮度一致的效果</p>
<h2 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h2><blockquote>
<p>AmbientLight </p>
</blockquote>
<p>它是一种基础光源， 影响整个场景的光源</p>
<p>环境光没有明确的光源位置， 在各处形成的亮度也是一致的。</p>
<p>它不会影响阴影的产生。</p>
<p>不能将环境光作为场景中唯一的光源。</p>
<h3 id="在Three中使用"><a href="#在Three中使用" class="headerlink" title="在Three中使用"></a>在Three中使用</h3><blockquote>
<p>THREE.AmbientLight(hex)</p>
</blockquote>
<blockquote>
<p>add(color) 添加到当前颜色上</p>
</blockquote>
<blockquote>
<p>clone 复制当前颜色</p>
</blockquote>
<p>如果只有环境光没有物同样是看不见东西的， 所以想测试环境光， 得先创建物体， </p>
<p>看一下下面两幅图:</p>
<p>这是正常环境光情况下的物体<br><img src="http://img.nixiaolei.com/three-ambientLight.png" alt="正常环境光"></p>
<p>然后我们把环境光调暗一点:</p>
<p><img src="http://img.nixiaolei.com/three-ambientLight-darker.png" alt="调暗环境光"></p>
<p>可以看到， 两张图中鲜艳的绿色明显的暗淡了</p>
<h3 id="环境光换色"><a href="#环境光换色" class="headerlink" title="环境光换色"></a>环境光换色</h3><p>刚刚我们只是调整了亮度明暗， 现在我们试试给环境光换个颜色， 就换个红色吧， 红色的灯感觉蛮吓人的</p>
<p><img src="http://img.nixiaolei.com/three-ambientLight-red02.png" alt="红色环境光"></p>
<p>我们发现， 立方体好像少了一个， 这是因为一个不透明的物体 ， 我们所看到的颜色其实是他反射出来的颜色， 而绿色立方体无法反射红色通道的颜色， 所以， 绿色立方体在我们看上去就像是隐藏了一样， 实际上是黑了， 而我们的白色， 他能反射所有颜色， 所以是他就变红了</p>
<h2 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a>如何添加</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scene.add(<span class="keyword">new</span> THREE.AmbientLight(<span class="number">0xff0000</span>))</span><br></pre></td></tr></table></figure>
<h2 id="实际操作一下"><a href="#实际操作一下" class="headerlink" title="实际操作一下"></a>实际操作一下</h2><p>大体思路， 我们创建一个面，和一个立方体， 先不投射任何的光，看看是什么效果， 然后我们最后放上环境光，看一下效果</p>
<h3 id="第一步-创建好立方体和面"><a href="#第一步-创建好立方体和面" class="headerlink" title="第一步-创建好立方体和面"></a>第一步-创建好立方体和面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> commonObj = common()</span><br><span class="line"> <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"> <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span><br><span class="line"> <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打开立方体的阴影</span></span><br><span class="line"> cube.castShadow = <span class="literal">true</span></span><br><span class="line"> cube.position.set(<span class="number">-4</span>, <span class="number">2.5</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> commonObj.scene.add(cube)</span><br><span class="line"> <span class="comment">// 调整相机位置</span></span><br><span class="line"> commonObj.camera.position.set(<span class="number">-25</span>, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line"> <span class="comment">// 镜头朝向舞台中央</span></span><br><span class="line"> commonObj.camera.lookAt(commonObj.scene.position)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(commonObj.renderer.domElement)</span><br><span class="line"> commonObj.renderer.render(commonObj.scene, commonObj.camera)</span><br></pre></td></tr></table></figure>
<p>此时浏览器中的效果<br><img src="http://img.nixiaolei.com/three-ambientLight-nolight.png" alt="无光环境"></p>
<p>可以看到， 此时尽管我们给物体设定了他的颜色， 但我们看到的不管是面还是立方体都依旧是黑色。</p>
<h3 id="第二步-添加光源"><a href="#第二步-添加光源" class="headerlink" title="第二步-添加光源"></a>第二步-添加光源</h3><p>上帝说要有光， 我们给添加一个环境光试试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line">commonObj.scene.add(<span class="keyword">new</span> THREE.AmbientLight()) <span class="comment">// 默认白光</span></span><br></pre></td></tr></table></figure>
<p>好， 就这行代码，就算是加上了</p>
<p><img src="http://img.nixiaolei.com/three-ambientLight-haslight.png" alt="有光环境"></p>
<h3 id="第三步-改变环境光颜色"><a href="#第三步-改变环境光颜色" class="headerlink" title="第三步-改变环境光颜色"></a>第三步-改变环境光颜色</h3><p>环境光默认是白色， 那我们可不可以试着改变一下， 把环境光改为红色？ 是不是会很吓人</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line">commonObj.scene.add(<span class="keyword">new</span> THREE.AmbientLight(<span class="number">0xff0000</span>)) <span class="comment">// 设置红色</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.nixiaolei.com/three-ambientLight-redlight.png" alt="红色环境光"></p>
<p>此时原本白色的面，也变为了红色， 感觉好刺眼， 吓得我赶紧关了</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../SceneUtils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../common/common.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 公共的方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">common</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene()</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xEEEEEE</span>, <span class="number">1.0</span>))</span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="javascript">    renderer.shadowMapEnabled = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">60</span>, <span class="number">30</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 材质</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xffffff</span>&#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI</span></span><br><span class="line"><span class="undefined">    plane.position.set(15, 0, 10)</span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">60</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">      scene,</span></span><br><span class="line"><span class="undefined">      renderer,</span></span><br><span class="line"><span class="undefined">      plane,</span></span><br><span class="line"><span class="undefined">      camera</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 开始创建</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> commonObj = common()</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 打开立方体的阴影</span></span></span><br><span class="line"><span class="javascript">  cube.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">  cube.position.set(-4, 2.5, 0)</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(cube)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 调整相机位置</span></span></span><br><span class="line"><span class="undefined">  commonObj.camera.position.set(-25, 20, 25)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 镜头朝向舞台中央</span></span></span><br><span class="line"><span class="undefined">  commonObj.camera.lookAt(commonObj.scene.position)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 环境光</span></span></span><br><span class="line"><span class="javascript">  commonObj.scene.add(<span class="keyword">new</span> THREE.AmbientLight())</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(commonObj.renderer.domElement)</span></span><br><span class="line"><span class="undefined">  commonObj.renderer.render(commonObj.scene, commonObj.camera)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js光源入门之点光源</title>
    <url>/2019/04/04/%E3%80%90Three%E3%80%91Three-js%E5%85%89%E6%BA%90%E5%85%A5%E9%97%A8%E4%B9%8B%E7%82%B9%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>点光源是一种单点发光照亮物体的光源</p>
<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><ul>
<li>照射所有方向的光源，例如照明弹</li>
<li>点光源是单点发光方式</li>
<li>点光源不会产生阴影， 减少GPU 的负担</li>
</ul>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">THREE.PointLight(hex, intensity, distance)</span><br></pre></td></tr></table></figure>
<ul>
<li>clone() —- 复制当前颜色。 color 光源颜色</li>
<li>intensity —- 光照强度</li>
<li>distance —- 光源照射的距离</li>
<li>position —- 光源所在位置</li>
</ul>
<h2 id="测试点光源"><a href="#测试点光源" class="headerlink" title="测试点光源"></a>测试点光源</h2><p>测试方法和大体上和环境光是一样的， 但是点光源和环境光不同的是， 他有个特点， 它能产生阴影</p>
<p>那我们就创建一个点光源和几个几何物体， 顺便移动一下点光源， 看看阴影是如何变化的</p>
<h3 id="创建立方体"><a href="#创建立方体" class="headerlink" title="创建立方体"></a>创建立方体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 立方体</span></span><br><span class="line"><span class="keyword">var</span> cubeGeomtry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeomtry, cubeMaterial)</span><br><span class="line">cube.position.set(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">commonObj.scene.add(cube)</span><br></pre></td></tr></table></figure>
<h3 id="创建球体"><a href="#创建球体" class="headerlink" title="创建球体"></a>创建球体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 球体</span></span><br><span class="line"><span class="keyword">var</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> sphreMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGeometry, sphreMaterial)</span><br><span class="line">sphere.position.set(<span class="number">20</span>, <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">commonObj.scene.add(sphere)</span><br></pre></td></tr></table></figure>
<h3 id="创建点光源"><a href="#创建点光源" class="headerlink" title="创建点光源"></a>创建点光源</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加点光源</span></span><br><span class="line"><span class="keyword">var</span> pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>)</span><br><span class="line">pointLight.position.set(<span class="number">-40</span>, <span class="number">60</span>, <span class="number">-10</span>)</span><br><span class="line">commonObj.scene.add(pointLight)</span><br></pre></td></tr></table></figure>
<h3 id="让点光源动起来"><a href="#让点光源动起来" class="headerlink" title="让点光源动起来"></a>让点光源动起来</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(render)</span><br><span class="line">  pointLight.position.z += <span class="number">0.2</span></span><br><span class="line">  commonObj.renderer.render(commonObj.scene, commonObj.camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br></pre></td></tr></table></figure>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>我们可以看到， 随着点光源的不断发生位置变动， 我们可以看到阴影发生逐渐的发生变化</p>
<p><img src="http://img.nixiaolei.com/yA1pla0mDn.gif" alt></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../common/common.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../SceneUtils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../common/common.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> commonObj = common()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 立方体</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeGeomtry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span> &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeomtry, cubeMaterial)</span></span><br><span class="line"><span class="undefined">  cube.position.set(0, 6, 0)</span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(cube)</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  <span class="comment">// 球体</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphereGeometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphreMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGeometry, sphreMaterial)</span></span><br><span class="line"><span class="undefined">  sphere.position.set(20, 6, 0)</span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(sphere)</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  commonObj.camera.position.set(-25, 30, 25)</span></span><br><span class="line"><span class="undefined">  commonObj.camera.lookAt(commonObj.scene.position)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 添加点光源</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> pointLight = <span class="keyword">new</span> THREE.PointLight(<span class="number">0xffffff</span>)</span></span><br><span class="line"><span class="undefined">  pointLight.position.set(-40, 60, -10)</span></span><br><span class="line"><span class="undefined">  commonObj.scene.add(pointLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    requestAnimationFrame(render)</span></span><br><span class="line"><span class="undefined">    pointLight.position.z += 0.2</span></span><br><span class="line"><span class="undefined">    commonObj.renderer.render(commonObj.scene, commonObj.camera)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  render()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(commonObj.renderer.domElement)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之光源</title>
    <url>/2019/04/04/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>光源也分为很多种</p>
<ul>
<li>AmbientLight —- 环境光</li>
<li>PonitLight —- 点光源</li>
<li>SpotLight —- 聚光灯</li>
<li>DirectionalLight —- 平行光</li>
</ul>
<p>然后还有各种高级的光照效果</p>
<h2 id="光源种类描述"><a href="#光源种类描述" class="headerlink" title="光源种类描述"></a>光源种类描述</h2><blockquote>
<p>具体内容在站内搜索光源的关键字， 如：环境光，  篇幅太长不在此处描述</p>
</blockquote>
<h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><blockquote>
<p>AmbientLight</p>
</blockquote>
<p>基础光源， 影响整个场景的光源</p>
<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><blockquote>
<p>PonitLight</p>
</blockquote>
<p>空间中的一个点， 朝所有方向发射光源</p>
<h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><blockquote>
<p>SpotLight</p>
</blockquote>
<p>具有锥形效果的聚光灯光源</p>
<h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>无限光， 模拟远处太阳的光辉</p>
<h3 id="高级光照效果"><a href="#高级光照效果" class="headerlink" title="高级光照效果"></a>高级光照效果</h3><ul>
<li>半球光</li>
<li>平面光</li>
<li>镜头眩光</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】PureComponent解决了什么问题</title>
    <url>/2019/04/04/%E3%80%90React%E3%80%91PureComponent%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><code>PureComponent</code> 是和 <code>shouldComponentUpdate</code>这个生命周期息息相关的</p>
<h2 id="React-重新渲染问题"><a href="#React-重新渲染问题" class="headerlink" title="React 重新渲染问题"></a>React 重新渲染问题</h2><p><code>React</code>中，当父组件中触发<code>setState</code>， 尽管未修改任何 <code>state</code> 中的值也会引起所有子组件的重新渲染， 更何况是修改了某个<code>state</code></p>
<p>还有， 当父组件传给子组件的<code>props</code> 发生改变， 不管该<code>props</code>是否被子组件用到， 都会去重新渲染子组件。</p>
<blockquote>
<p>其实我们也可以想得到， setState 会去触发 render， 所以父组件<code>render</code>函数中的子组件都会被重新渲染， 因此也就无关 <code>state</code> 与 <code>props</code>了</p>
</blockquote>
<p>针对这个问题我实现了个例子， 来看一下下面这个例子</p>
<h3 id="实现下问题"><a href="#实现下问题" class="headerlink" title="实现下问题"></a>实现下问题</h3><blockquote>
<p>setState但未修改任何state</p>
</blockquote>
<p>父组件触发 <code>setState</code> 方法, 但未更新任何<code>state</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">'./components/todoItem/todoItem'</span></span><br><span class="line"><span class="comment">// 父组件代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  noChange() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'触发setState'</span>)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"wrap"</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.noChange()&#125;&gt;没有变化的setState&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;</span></span><br><span class="line"><span class="regexp">          todoList.map( (item,index) =&gt; &lt;TodoItem key=&#123;index&#125;  data=&#123;item&#125; /</span>&gt; )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件代码</span></span><br><span class="line"><span class="regexp">class TodoItem extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentWillUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('我被更新了')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123; this.props.data.thing &#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在子组件中预留了<code>componentWillUpdate</code> 方法， 用来监测子组件是否被跟新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">componentWillUpdate() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我被更新了'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果: </p>
<p><img src="http://img.nixiaolei.com/noChangeState.gif" alt="noChangeState"></p>
<p>我们可以看到, 每一次的点击都引起了子组件的<code>update</code></p>
<h3 id="冷静分析问题"><a href="#冷静分析问题" class="headerlink" title="冷静分析问题"></a>冷静分析问题</h3><p>无故的重复<code>update</code>, 这会导致业务规模扩大后十分的影响性能.</p>
<p>为此我监测了一下页面的重绘事件:</p>
<blockquote>
<p>绿色区域是浏览器发成重绘的地方</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/noRePaint.gif" alt="noRePaint"></p>
<p>可以看到<code>todoList</code>其实并没有引起浏览器的<code>repaint</code> , 因此可以推测, 实际<code>dom</code>并没有更新这在渲染页面前被<code>dom diff</code>给排除掉了, 因此性能损耗在了转换成<code>Virtual DOM</code>的过程中 </p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><blockquote>
<p>shouldComponentUpdate(nextProps, nextState)， 默认返回true</p>
</blockquote>
<p><code>shouldComponentUpdate</code> 是 <code>React</code> 中做性能优化的重要手段， 看这个英文翻译我们大概也能猜出个一二来 — ‘组件是否跟新？’</p>
<p><code>React</code> 会根据 <code>shouldComponentUpdate</code> 的返回结果来决定该组件是否重新渲染， 如果返回<code>True</code>就渲染，  如果返回<code>False</code>就重新渲染</p>
<p>基于这个特性, 我们来修改一下上面问题中的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件无变化, 因此省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略其他原有的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// --------- 新增代码 -------------</span></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// 判断下 当前 props传入的data.thing  是否和新传入的  data.thing 相同</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">this</span>.props.data.thing !== nextProps.data.thing</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// --------- 新增代码 -------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果:<br><img src="http://img.nixiaolei.com/addShouUpdate.gif" alt="addShouUpdate"></p>
<p>我们可以看到<code>update</code>事件确实消失了</p>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>看了<code>shouldComponentUpdate</code>函数的作用, 就能够理解<code>PureComponent</code>了?  它其实就是在帮我们做这样一件事:</p>
<p><strong>自动的帮我们编写 <code>shouldComponentUpdate</code> 方法, 避免我们为每个组件都编写一次的麻烦</strong></p>
<p>我们只需要这样, 就可以一步到位<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>是不是感觉<code>PureComponent</code>很强大, 但<code>PureComponent</code>并不完美, </p>
<p>其实它还有一些潜藏的问题, 如果您想要继续了解, 请在站内搜索 <code>immutable</code></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之相机</title>
    <url>/2019/04/03/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>有两种相机</p>
<ul>
<li>近交投影</li>
<li>正交投影</li>
</ul>
<h2 id="近交投影"><a href="#近交投影" class="headerlink" title="近交投影"></a>近交投影</h2><p>和真实世界中我们所看到的物体一样， 近大远小<br><img src="http://img.nixiaolei.com/three-camera-a.png" alt="近交投影"></p>
<h3 id="透视投影照相机"><a href="#透视投影照相机" class="headerlink" title="透视投影照相机"></a>透视投影照相机</h3><blockquote>
<p>THREE.PerspectiveCamera(fov, aspect, near, far)</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/perspectiveCamera.png" alt="透视投影照相机"></p>
<ul>
<li>fov —- 视野宽度</li>
<li>aspect —- 长宽比， 推荐使用 window.innerWidth / window.innerHeight</li>
<li>near —- 近裁面， 推荐值 0.1</li>
<li>far —- 远裁面， 推荐值 1000，  值太大影响性能， 值太小场景显示不全</li>
</ul>
<h2 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h2><blockquote>
<p>建模类软件使用的比较多</p>
</blockquote>
<p>正交投影就像老师在黑板上画的立方体，保证三维世界平行的线到了二维世界也是平行的， 不存在近大远小的概念，</p>
<h3 id="正交投影相机"><a href="#正交投影相机" class="headerlink" title="正交投影相机"></a>正交投影相机</h3><blockquote>
<p>THREE.OrthographicCamera(left, right, top, bottom, near, far)  // near far决定远近范围</p>
</blockquote>
<ul>
<li>left —- 左边界</li>
<li>right —- 右边界</li>
<li>top —- 上边界</li>
<li>bottom —- 下边界</li>
<li>near —- 近裁面</li>
<li>far —- 远裁面</li>
<li>camera.lookAt —- 设置目标点</li>
</ul>
<p>在Three中， 创建正交投影相机的参数决定了所看到的<code>视景体</code>, <code>视景体</code>内部的物体才能显示在屏幕上，视景体外部的就会被裁剪掉</p>
<p>图中灰色区域就是<code>视景体</code><br><img src="http://img.nixiaolei.com/OrthographicCamera.png" alt="正交投影相机"></p>
<h2 id="摄影机效果比对"><a href="#摄影机效果比对" class="headerlink" title="摄影机效果比对"></a>摄影机效果比对</h2><p>说概念总是比较抽象， 我们来实际操作一下，</p>
<p>大概思路就是， 首先将立方体铺满平面， 然后我们使用定时器来切换相机类型 ， 以此来区别出两种相机的效果</p>
<h3 id="第一步—-将立方体铺满平面"><a href="#第一步—-将立方体铺满平面" class="headerlink" title="第一步—-将立方体铺满平面"></a>第一步—-将立方体铺满平面</h3><p>利用我们之前设定的面的宽高， 计算出一列应该有多少立方体， 一行应该有多少立方体， 然后将其排列好， 添加入场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将立方体铺满屏幕</span></span><br><span class="line"><span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> j=<span class="number">0</span>; j &lt; planeGeometry.parameters.height / <span class="number">5</span> ;j++) &#123;  <span class="comment">// 面高 50</span></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; planeGeometry.parameters.width / <span class="number">5</span> ; i++) &#123; <span class="comment">// 面宽 70</span></span><br><span class="line">    <span class="comment">// 随机生成</span></span><br><span class="line">    <span class="keyword">var</span> rnd = <span class="built_in">Math</span>.random() * <span class="number">0.75</span> + <span class="number">0.25</span></span><br><span class="line">    <span class="comment">// 添加材质</span></span><br><span class="line">    <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial()</span><br><span class="line">    <span class="comment">// 添加颜色</span></span><br><span class="line">    cubeMaterial.color = <span class="keyword">new</span> THREE.Color(rnd, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 创建立方体</span></span><br><span class="line">    <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span><br><span class="line">    <span class="comment">// 设置立方体的位置</span></span><br><span class="line">    cube.position.x = -(planeGeometry.parameters.width / <span class="number">2</span>) + <span class="number">2</span> +(i * <span class="number">5</span>)</span><br><span class="line">    cube.position.y = <span class="number">2</span></span><br><span class="line">    cube.position.z = -(planeGeometry.parameters.height / <span class="number">2</span>) + <span class="number">2</span> +(j * <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 立方体加入场景</span></span><br><span class="line">    scene.add(cube)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二步—-用键盘控制相机角度"><a href="#第二步—-用键盘控制相机角度" class="headerlink" title="第二步—-用键盘控制相机角度"></a>第二步—-用键盘控制相机角度</h3><p>每当按下左右键时， 就调整相机的y 轴方向的旋转角度， 然后重新绘制场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定键盘事件</span></span><br><span class="line"><span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(e.keyCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">      camera.rotation.y += <span class="number">0.02</span></span><br><span class="line">      render()</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">      camera.rotation.y -= <span class="number">0.02</span></span><br><span class="line">      render()</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>
<h3 id="第三步—-利用定时器切换摄像机的模式"><a href="#第三步—-利用定时器切换摄像机的模式" class="headerlink" title="第三步—-利用定时器切换摄像机的模式"></a>第三步—-利用定时器切换摄像机的模式</h3><p>利用定时器切换 相机的模式，然后就会在下次一用户按下键盘时被渲染出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于切换相机模式</span></span><br><span class="line"><span class="keyword">var</span> controls = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.perspective = <span class="string">"Perspective"</span></span><br><span class="line">  <span class="keyword">this</span>.switchCamera = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( camera <span class="keyword">instanceof</span> THREE.PerspectiveCamera ) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Orthographic'</span>)</span><br><span class="line">      <span class="keyword">this</span>.perspective = <span class="string">'Orthographic'</span> </span><br><span class="line">      camera = <span class="keyword">new</span> THREE.OrthographicCamera (</span><br><span class="line">        <span class="built_in">window</span>.innerWidth / <span class="number">-16</span>,</span><br><span class="line">        <span class="built_in">window</span>.innerWidth / <span class="number">16</span>,</span><br><span class="line">        <span class="built_in">window</span>.innerHeight / <span class="number">-16</span>,</span><br><span class="line">        <span class="built_in">window</span>.innerHeight / <span class="number">16</span>,</span><br><span class="line">        <span class="number">-200</span>, </span><br><span class="line">        <span class="number">500</span></span><br><span class="line">      )</span><br><span class="line">      camera.position.x = <span class="number">-20</span></span><br><span class="line">      camera.position.y = <span class="number">60</span></span><br><span class="line">      camera.position.z = <span class="number">50</span></span><br><span class="line">      camera.lookAt(scene.position)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Perspective'</span>)</span><br><span class="line">      <span class="keyword">this</span>.perspective = <span class="string">"Perspective"</span></span><br><span class="line">      camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">75</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span><br><span class="line">      camera.position.x = <span class="number">-20</span></span><br><span class="line">      camera.position.y = <span class="number">60</span></span><br><span class="line">      camera.position.z = <span class="number">50</span></span><br><span class="line">      camera.lookAt(scene.position)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换相机模式</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  controls.switchCamera()</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p>随着我不断地按下键盘的方向键， 画布被重新渲染， 我们可以看到两种相机的不同效果在来回切换</p>
<p><img src="http://img.nixiaolei.com/camera-doubule-mode.gif" alt="两种摄影机模式"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../SceneUtils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置场景,</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置相机                      视角,  宽度/高度,   近距离点,  远距点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    camera.position.x = -30</span></span><br><span class="line"><span class="undefined">    camera.position.y = 40</span></span><br><span class="line"><span class="undefined">    camera.position.z = 10</span></span><br><span class="line"><span class="javascript">    camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置绘制对象---基于Webgl的渲染器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 控制渲染尺寸</span></span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打开阴影</span></span></span><br><span class="line"><span class="javascript">    renderer.shadowMapEnabled = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置辅助测试工具</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span></span><br><span class="line"><span class="undefined">    scene.add(axes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置平面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置旋转角度</span></span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    plane.position.x = 15</span></span><br><span class="line"><span class="undefined">    plane.position.y = 0</span></span><br><span class="line"><span class="undefined">    plane.position.z = 0</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    plane.receiveShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    *  添加材质和灯光</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置点光源</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置位置</span></span></span><br><span class="line"><span class="undefined">    spotLight.position.set(-40, 60, -10)</span></span><br><span class="line"><span class="javascript">    spotLight.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加进点光源</span></span></span><br><span class="line"><span class="undefined">    scene.add(spotLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// --------------------------关键区域-----------------------------------------</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将立方体铺满屏幕</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.BoxGeometry(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> ( <span class="keyword">var</span> j=<span class="number">0</span>; j &lt; planeGeometry.parameters.height / <span class="number">5</span> ;j++) &#123;  <span class="comment">// 面高 50</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; planeGeometry.parameters.width / <span class="number">5</span> ; i++) &#123; <span class="comment">// 面宽 70</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 随机生成</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> rnd = <span class="built_in">Math</span>.random() * <span class="number">0.75</span> + <span class="number">0.25</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 添加材质</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial()</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 添加颜色</span></span></span><br><span class="line"><span class="javascript">        cubeMaterial.color = <span class="keyword">new</span> THREE.Color(rnd, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建立方体</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置立方体的位置</span></span></span><br><span class="line"><span class="undefined">        cube.position.x = -(planeGeometry.parameters.width / 2) + 2 +(i * 5)</span></span><br><span class="line"><span class="undefined">        cube.position.y = 2</span></span><br><span class="line"><span class="undefined">        cube.position.z = -(planeGeometry.parameters.height / 2) + 2 +(j * 5)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 立方体加入场景</span></span></span><br><span class="line"><span class="undefined">        scene.add(cube)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 用于切换相机模式</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> controls = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.perspective = <span class="string">"Perspective"</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.switchCamera = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>( camera <span class="keyword">instanceof</span> THREE.PerspectiveCamera ) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'Orthographic'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.perspective = <span class="string">'Orthographic'</span> </span></span><br><span class="line"><span class="javascript">          camera = <span class="keyword">new</span> THREE.OrthographicCamera (</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.innerWidth / <span class="number">-16</span>,</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.innerWidth / <span class="number">16</span>,</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.innerHeight / <span class="number">-16</span>,</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.innerHeight / <span class="number">16</span>,</span></span><br><span class="line"><span class="undefined">            -200, </span></span><br><span class="line"><span class="undefined">            500</span></span><br><span class="line"><span class="undefined">          )</span></span><br><span class="line"><span class="undefined">          camera.position.x = -20</span></span><br><span class="line"><span class="undefined">          camera.position.y = 60</span></span><br><span class="line"><span class="undefined">          camera.position.z = 50</span></span><br><span class="line"><span class="undefined">          camera.lookAt(scene.position)</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'Perspective'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.perspective = <span class="string">"Perspective"</span></span></span><br><span class="line"><span class="javascript">          camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">75</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">          camera.position.x = -20</span></span><br><span class="line"><span class="undefined">          camera.position.y = 60</span></span><br><span class="line"><span class="undefined">          camera.position.z = 50</span></span><br><span class="line"><span class="undefined">          camera.lookAt(scene.position)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 切换相机模式</span></span></span><br><span class="line"><span class="javascript">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="undefined">      controls.switchCamera()</span></span><br><span class="line"><span class="undefined">    &#125;, 2000)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定键盘事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">switch</span>(e.keyCode) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="number">37</span>:</span></span><br><span class="line"><span class="undefined">          camera.rotation.y += 0.02</span></span><br><span class="line"><span class="undefined">          render()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="number">39</span>:</span></span><br><span class="line"><span class="undefined">          camera.rotation.y -= 0.02</span></span><br><span class="line"><span class="undefined">          render()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    render()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// --------------------------关键区域-----------------------------------------</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将renderer的输出挂到 body</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之几何和网格对象</title>
    <url>/2019/04/03/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E5%87%A0%E4%BD%95%E5%92%8C%E7%BD%91%E6%A0%BC%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><p>Three.js 中自带了很多的几何体， 我们可以直接使用他们的方法就可以轻松的创造出一个几何体，</p>
<p>比如:</p>
<p>创建一个面<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.PlaneGeometry()</span><br></pre></td></tr></table></figure></p>
<p>创建一个立方体<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> THREE.CubeGeometry()</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到都带有<code>Geometry</code> 这个单词， 翻译过来也是“几何体”的意思<br>其实这个<code>THREE.Geometry</code>是所有几何对象的基类( 简称 geom )</p>
<h3 id="vertices顶点数组"><a href="#vertices顶点数组" class="headerlink" title="vertices顶点数组"></a>vertices顶点数组</h3><blockquote>
<p>翻译： 顶点</p>
</blockquote>
<p>一个集合体我们可以看成是由几个顶点构成的， 比如一个立方体， 他就是由8个在空间中的顶点构成的。 </p>
<p>在Three中， <code>geom.vertices</code>表示几何体的顶点， 它是一个数组</p>
<p>所以我们不但可以利用<code>Three</code>已有的几何体， 还可以自己提供顶点， 自己来创建一个集合体</p>
<h3 id="faces-侧面"><a href="#faces-侧面" class="headerlink" title="faces 侧面"></a>faces 侧面</h3><blockquote>
<p>翻译: 面</p>
</blockquote>
<p><code>geom.faces</code> 表示几何体的侧面</p>
<h3 id="动手创建一个立方体"><a href="#动手创建一个立方体" class="headerlink" title="动手创建一个立方体"></a>动手创建一个立方体</h3><p>上面我们说了， 一个立方体， 由8个顶点 和 6个面构成， 如果让我们自己来实现， 我们就需要手动来创建下</p>
<h4 id="定义8个顶点"><a href="#定义8个顶点" class="headerlink" title="定义8个顶点"></a>定义8个顶点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vertices = [</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">3</span>, <span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="定义6个面"><a href="#定义6个面" class="headerlink" title="定义6个面"></a>定义6个面</h4><p>因为在Three 中，可以理解为万物都由 三角形构成， 所以要想有正方形， 需要通过三角形创建( 以前支持直接创建正方形， 后来被删除 )</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加 6个面</span></span><br><span class="line"><span class="keyword">var</span> faces = [</span><br><span class="line">  <span class="comment">// 一个正方形由两个三角形构成</span></span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> THREE.Face3(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="生成几何物体"><a href="#生成几何物体" class="headerlink" title="生成几何物体"></a>生成几何物体</h4><p>刚刚我们配置的只是所需的数据， 现在我们要做的是将他合并成一个完整的几何体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建几何体</span></span><br><span class="line"><span class="keyword">var</span> geom = <span class="keyword">new</span> THREE.Geometry()</span><br><span class="line">geom.vertices = vertices</span><br><span class="line">geom.faces = faces</span><br><span class="line">geom.computeFaceNormals()</span><br></pre></td></tr></table></figure>
<h4 id="添加材质"><a href="#添加材质" class="headerlink" title="添加材质"></a>添加材质</h4><p><img src="http://img.nixiaolei.com/sceneUtils-error.png" alt="控制台报错"><br>如果控制带出现这个错误， 说明<code>SceneUtils</code> 已经被Three 独立拆除去了， 所以要想使用需要单独引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 增加材质</span></span><br><span class="line"><span class="keyword">var</span> materials = [</span><br><span class="line">  <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">    opacity: <span class="number">0.5</span>, </span><br><span class="line">    color: <span class="number">0x44ff44</span>, </span><br><span class="line">    transparent: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">    color: <span class="number">0x000000</span>, </span><br><span class="line">    wireframe: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构成物体</span></span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.SceneUtils.createMultiMaterialObject(geom, materials)</span><br><span class="line">mesh.children.forEach(</span><br><span class="line">  (e) =&gt; &#123;</span><br><span class="line">    e.castShadow = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="渲染场景"><a href="#渲染场景" class="headerlink" title="渲染场景"></a>渲染场景</h4><p>加入到场景渲染一下我们刚刚创建的立方体<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scene.add(mesh)</span><br><span class="line">renderer.render(scene, camera)</span><br></pre></td></tr></table></figure></p>
<p>此时，我们可以看到画布上真的出现了一个立方体<br><img src="http://img.nixiaolei.com/three-gemo-mesh.png" alt="渲染场景结果"></p>
<h2 id="网格对象的属性和函数"><a href="#网格对象的属性和函数" class="headerlink" title="网格对象的属性和函数"></a>网格对象的属性和函数</h2><ul>
<li>position 决定该对象相对于父对象的位置。</li>
<li>rotation 设置对象绕任何一个轴的旋转弧度</li>
<li>scale沿 x, y 和 z轴缩放对象</li>
<li>translateX x轴平移</li>
<li>translateY y轴平移</li>
<li>translateZ z轴平移</li>
</ul>
<p>使用这些api移动一下我们刚刚创建的立方体吧</p>
<h3 id="移动一下立方体"><a href="#移动一下立方体" class="headerlink" title="移动一下立方体"></a>移动一下立方体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平移</span></span><br><span class="line">mesh.position.x = <span class="number">10</span></span><br><span class="line">mesh.position.y = <span class="number">10</span></span><br><span class="line">mesh.position.z = <span class="number">1</span></span><br><span class="line"><span class="comment">// // 等同于</span></span><br><span class="line"><span class="comment">// mesh.position.set(10, 10, 1)</span></span><br></pre></td></tr></table></figure>
<p>此时效果<br><img src="http://img.nixiaolei.com/2019-05-03-23-41-13.png" alt="移动立方体"></p>
<h3 id="再旋转一下立方体"><a href="#再旋转一下立方体" class="headerlink" title="再旋转一下立方体"></a>再旋转一下立方体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // 旋转</span></span><br><span class="line">mesh.rotation.x = <span class="number">2</span></span><br><span class="line">mesh.rotation.y = <span class="number">2</span></span><br><span class="line">mesh.rotation.z = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>此时效果<br><img src="http://img.nixiaolei.com/three-mesh-rotation.png" alt="旋转立方体"></p>
<h3 id="缩放一下立方体"><a href="#缩放一下立方体" class="headerlink" title="缩放一下立方体"></a>缩放一下立方体</h3><p>我们可以针对某一个轴进行缩放， 这里我们缩放x轴， 其他轴同理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 轴方向放大4倍</span></span><br><span class="line">mesh.scale.x = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>此时效果</p>
<p><img src="http://img.nixiaolei.com/three-mesh-scale.png" alt="立方体缩放效果"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    margin: 0;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../SceneUtils.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置场景,</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置相机                      视角,  宽度/高度,   近距离点,  远距点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    camera.position.x = -30</span></span><br><span class="line"><span class="undefined">    camera.position.y = 40</span></span><br><span class="line"><span class="undefined">    camera.position.z = 10</span></span><br><span class="line"><span class="javascript">    camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置绘制对象---基于Webgl的渲染器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 控制渲染尺寸</span></span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打开阴影</span></span></span><br><span class="line"><span class="javascript">    renderer.shadowMapEnabled = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置辅助测试工具</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span></span><br><span class="line"><span class="undefined">    scene.add(axes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置平面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置旋转角度</span></span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    plane.position.x = 15</span></span><br><span class="line"><span class="undefined">    plane.position.y = 0</span></span><br><span class="line"><span class="undefined">    plane.position.z = 0</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    plane.receiveShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    *  添加材质和灯光</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置点光源</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置位置</span></span></span><br><span class="line"><span class="undefined">    spotLight.position.set(-40, 60, -10)</span></span><br><span class="line"><span class="javascript">    spotLight.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加进点光源</span></span></span><br><span class="line"><span class="undefined">    scene.add(spotLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将renderer的输出挂到 body</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class="line"><span class="undefined">    renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义一个方块</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1.定义8个顶点</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2. 6个面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vertices = [</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">3</span>, <span class="number">-1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">3</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Vector3(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">    ]</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加 6个面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> faces = [</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 一个正方形由两个三角形构成</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>),</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>),</span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>),</span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>),</span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.Face3(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>),</span></span><br><span class="line"><span class="undefined">    ]</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建几何体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> geom = <span class="keyword">new</span> THREE.Geometry()</span></span><br><span class="line"><span class="undefined">    geom.vertices = vertices</span></span><br><span class="line"><span class="undefined">    geom.faces = faces</span></span><br><span class="line"><span class="undefined">    geom.computeFaceNormals()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加材质</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> materials = [</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="undefined">        opacity: 0.5, </span></span><br><span class="line"><span class="undefined">        color: 0x44ff44, </span></span><br><span class="line"><span class="javascript">        transparent: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">      &#125;),</span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span></span><br><span class="line"><span class="undefined">        color: 0x000000, </span></span><br><span class="line"><span class="javascript">        wireframe: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    ]</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 构成物体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> mesh = <span class="keyword">new</span> THREE.SceneUtils.createMultiMaterialObject(geom, materials)</span></span><br><span class="line"><span class="undefined">    mesh.children.forEach(</span></span><br><span class="line"><span class="undefined">      (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        e.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    )</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 平移</span></span></span><br><span class="line"><span class="undefined">    mesh.position.x = 10</span></span><br><span class="line"><span class="undefined">    mesh.position.y = 10</span></span><br><span class="line"><span class="undefined">    mesh.position.z = 1</span></span><br><span class="line"><span class="javascript">    <span class="comment">// // 等同于</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// mesh.position.set(10, 10, 1)</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// // 旋转</span></span></span><br><span class="line"><span class="undefined">    mesh.rotation.x = 2</span></span><br><span class="line"><span class="undefined">    mesh.rotation.y = 2</span></span><br><span class="line"><span class="undefined">    mesh.rotation.z = 2</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// // x 轴方向放大4倍</span></span></span><br><span class="line"><span class="undefined">    mesh.scale.x = 4</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    scene.add(mesh)</span></span><br><span class="line"><span class="undefined">    renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之添加动画</title>
    <url>/2019/04/03/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B7%BB%E5%8A%A0%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>本文基于”Three.js入门之添加材质和灯光” 文章之后</p>
<h2 id="帧率辅助库"><a href="#帧率辅助库" class="headerlink" title="帧率辅助库"></a>帧率辅助库</h2><blockquote>
<p>在官网下载到的three文件中的 <code>/examples/js/libs/stats.min.js</code> 可以找到</p>
</blockquote>
<p>这个是一个three 开发者之一写的库， 可以给我提供检测动画流畅度的数据， 引入方式和<code>three</code>一样</p>
<p>如何使用呢， </p>
<h3 id="创建一个dom"><a href="#创建一个dom" class="headerlink" title="创建一个dom"></a>创建一个dom</h3><p>我们给他预留一个<code>dom</code><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"stats-output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="初始化统计对象"><a href="#初始化统计对象" class="headerlink" title="初始化统计对象"></a>初始化统计对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化统计对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initStats</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">var</span> stats = <span class="keyword">new</span> Stats()</span><br><span class="line">  <span class="comment">// 设置模式， 0 显示 fps, 1 检测渲染时间</span></span><br><span class="line">  stats.setMode(<span class="number">0</span>) </span><br><span class="line">  <span class="comment">// 样式设置</span></span><br><span class="line">  stats.domElement.style.position = <span class="string">'absolute'</span></span><br><span class="line">  stats.domElement.style.left = <span class="string">"0px"</span></span><br><span class="line">  stats.domElement.style.top = <span class="string">"0px"</span></span><br><span class="line">  <span class="comment">// 加入刚才的dom</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'stats-output'</span>).appendChild(stats.domElement)</span><br><span class="line">  <span class="keyword">return</span> stats</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在每一帧动画期间更新"><a href="#在每一帧动画期间更新" class="headerlink" title="在每一帧动画期间更新"></a>在每一帧动画期间更新</h3><p>因为这里我们的动画使用的是<code>requestAnimationFrame</code>, 所以我们在每次调用该方法时， 去更新一下统计对象即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 更新统计对象</span></span><br><span class="line">  stats.update()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主循环</span></span><br><span class="line">  requestAnimationFrame(render)</span><br><span class="line">  <span class="comment">// 渲染当前的场景</span></span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看一下结果"><a href="#查看一下结果" class="headerlink" title="查看一下结果"></a>查看一下结果</h3><p>这些都做好以后，打开浏览器， 左上角就可以看到我们刚刚创建的统计对象了</p>
<p><img src="http://img.nixiaolei.com/2019-05-03-20-55-25.png" alt="统计对象"></p>
<h2 id="创建动画"><a href="#创建动画" class="headerlink" title="创建动画"></a>创建动画</h2><p>因为js定时器的种种问题， 计时不准确，  无法预估浏览器算力等等问题， 所以<code>requestAnimationFrame</code><br>是我们做动画时的首选， 它可以根据浏览器的具体繁忙情况自动控制帧率</p>
<h3 id="创建主循环"><a href="#创建主循环" class="headerlink" title="创建主循环"></a>创建主循环</h3><p>先把之前的最后一步的渲染操作放入<code>requestAnimationFrame</code> 这个主循环， </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  stats.update() <span class="comment">// 上面👆使用的帧率统计</span></span><br><span class="line">  <span class="comment">// 回调传入自身</span></span><br><span class="line">  requestAnimationFrame(render)</span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将renderer的输出挂到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement)</span><br><span class="line">render()</span><br></pre></td></tr></table></figure>
<p>这样，我们的主循环就创建好了， 但是还不够， 如果你刷新浏览器， 你看到的依旧是静止的， 因为你的代码没有任何变化， 所以， 我们就尝试着让他发生一些变化</p>
<h3 id="让正方体动起来"><a href="#让正方体动起来" class="headerlink" title="让正方体动起来"></a>让正方体动起来</h3><p>我们让正方体旋转起来， 我们在每一帧都修改一下这个正方体的 <code>x,y,z</code> 坐标位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  stats.update() <span class="comment">// 上面👆使用的帧率统计</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// -------转动方块--------</span></span><br><span class="line">  cube.rotation.x += <span class="number">0.02</span></span><br><span class="line">  cube.rotation.y += <span class="number">0.02</span></span><br><span class="line">  cube.rotation.z += <span class="number">0.02</span></span><br><span class="line">  <span class="comment">// ----------------------</span></span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(render)</span><br><span class="line">  renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这三行代码就可以了， 让我们看看现在的效果</p>
<p><img src="http://img.nixiaolei.com/J2oeAVFEnQ.gif" alt="旋转立方体"></p>
<p>我们可以看到， 立方体运动行径诡异啊， 但是很cool</p>
<h3 id="让球动起来"><a href="#让球动起来" class="headerlink" title="让球动起来"></a>让球动起来</h3><p>让球动起来也很简单， 但是我们想让他动的稍微炫酷一点， 让他跳来跳去， 这就需要用到一点数学知识了， 利用三角函数我们实现一下球的弹跳</p>
<p>我们在函数外记录了一个 <code>Step</code> 用来每次增长， 然后球的<code>x, y</code> 就会每次都根据三角函数的曲线规律来造成一高一低的效果， 而且是抛物线</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stats.update()</span><br><span class="line">    <span class="comment">// 转动方块</span></span><br><span class="line">    cube.rotation.x += <span class="number">0.02</span></span><br><span class="line">    cube.rotation.y += <span class="number">0.02</span></span><br><span class="line">    cube.rotation.z += <span class="number">0.02</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --------球体跳跃------------</span></span><br><span class="line">    step += <span class="number">0.04</span>;</span><br><span class="line">    sphere.position.x = <span class="number">20</span> + ( <span class="number">10</span> * <span class="built_in">Math</span>.cos( step ))</span><br><span class="line">    sphere.position.y = <span class="number">2</span> + ( <span class="number">10</span> * <span class="built_in">Math</span>.abs( <span class="built_in">Math</span>.sin(step) ))</span><br><span class="line">    <span class="comment">// ---------------------------</span></span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(render)</span><br><span class="line">    renderer.render(scene, camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下现在的效果图<br><img src="http://img.nixiaolei.com/three-ball-action.gif" alt="球体运动"></p>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><blockquote>
<p>git地址: <a href="https://0x9.me/ohetH" target="_blank" rel="noopener">https://0x9.me/ohetH</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"stats-output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 游戏帧率辅助库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../stats.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 增加统计功能</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> stats = initStats()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置场景,</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置相机                      视角,  宽度/高度,   近距离点,  远距点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    camera.position.x = -30</span></span><br><span class="line"><span class="undefined">    camera.position.y = 40</span></span><br><span class="line"><span class="undefined">    camera.position.z = 30</span></span><br><span class="line"><span class="javascript">    camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置绘制对象---基于Webgl的渲染器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 控制渲染尺寸</span></span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打开阴影</span></span></span><br><span class="line"><span class="javascript">    renderer.shadowMapEnabled = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置辅助测试工具</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span></span><br><span class="line"><span class="undefined">    scene.add(axes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置平面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置旋转角度</span></span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    plane.position.x = 15</span></span><br><span class="line"><span class="undefined">    plane.position.y = 0</span></span><br><span class="line"><span class="undefined">    plane.position.z = 0</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    plane.receiveShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置立方体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>)  <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置基础材质</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xff0000</span>&#125;) <span class="comment">// 设置颜色和打开线框</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    cube.position.x = 4</span></span><br><span class="line"><span class="undefined">    cube.position.y = 3</span></span><br><span class="line"><span class="undefined">    cube.position.z = 0</span></span><br><span class="line"><span class="javascript">    cube.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(cube)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置球面体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereGemometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGemometry, sphereMaterial)</span></span><br><span class="line"><span class="undefined">    sphere.position.x = 20</span></span><br><span class="line"><span class="undefined">    sphere.position.y = 4</span></span><br><span class="line"><span class="undefined">    sphere.position.z = -2</span></span><br><span class="line"><span class="javascript">    sphere.castShadow = <span class="literal">true</span> </span></span><br><span class="line"><span class="undefined">    scene.add(sphere)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    *  添加材质和灯光</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置点光源</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置位置</span></span></span><br><span class="line"><span class="undefined">    spotLight.position.set(-40, 60, -10)</span></span><br><span class="line"><span class="javascript">    spotLight.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加进点光源</span></span></span><br><span class="line"><span class="undefined">    scene.add(spotLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * 引入动画</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> step = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        stats.update()</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 转动方块</span></span></span><br><span class="line"><span class="undefined">        cube.rotation.x += 0.02</span></span><br><span class="line"><span class="undefined">        cube.rotation.y += 0.02</span></span><br><span class="line"><span class="undefined">        cube.rotation.z += 0.02</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="comment">// 球体跳跃</span></span></span><br><span class="line"><span class="undefined">        step += 0.04;</span></span><br><span class="line"><span class="javascript">        sphere.position.x = <span class="number">20</span> + ( <span class="number">10</span> * <span class="built_in">Math</span>.cos( step ))</span></span><br><span class="line"><span class="javascript">        sphere.position.y = <span class="number">2</span> + ( <span class="number">10</span> * <span class="built_in">Math</span>.abs( <span class="built_in">Math</span>.sin(step) ))</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        requestAnimationFrame(render)</span></span><br><span class="line"><span class="undefined">        renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * 输出</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 初始化统计对象</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">initStats</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> stats = <span class="keyword">new</span> Stats()</span></span><br><span class="line"><span class="javascript">        stats.setMode(<span class="number">0</span>) <span class="comment">// 0 显示fps, 1 检测渲染时间</span></span></span><br><span class="line"><span class="javascript">        stats.domElement.style.position = <span class="string">'absolute'</span></span></span><br><span class="line"><span class="javascript">        stats.domElement.style.left = <span class="string">"0px"</span></span></span><br><span class="line"><span class="javascript">        stats.domElement.style.top = <span class="string">"0px"</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'stats-output'</span>).appendChild(stats.domElement)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> stats</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将renderer的输出挂到body</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class="line"><span class="undefined">    render()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之添加材质和灯光</title>
    <url>/2019/04/03/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B7%BB%E5%8A%A0%E6%9D%90%E8%B4%A8%E5%92%8C%E7%81%AF%E5%85%89/</url>
    <content><![CDATA[<p>本文基于”Three.js入门之绘制三维对象” 文章之后</p>
<h2 id="材质与光源"><a href="#材质与光源" class="headerlink" title="材质与光源"></a>材质与光源</h2><p>可以对光产生反应的材质</p>
<ul>
<li>MeshLamberMaterial 材质</li>
<li>MeshPhongMaterial 材质</li>
<li>加入阴影效果</li>
</ul>
<h2 id="添加灯光"><a href="#添加灯光" class="headerlink" title="添加灯光"></a>添加灯光</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpootLight(<span class="number">0xffffff</span>);</span><br><span class="line"><span class="comment">// 设置位置</span></span><br><span class="line">spotLight.position.set(<span class="number">-40</span>, <span class="number">60</span>, <span class="number">-10</span>)</span><br><span class="line"><span class="comment">// 将光源添加进场景</span></span><br><span class="line">scene.add(spotLight)</span><br></pre></td></tr></table></figure>
<p>当我们将三维物体的所有材质都替换为<code>MeshLamberMaterial</code> 时, 效果如下</p>
<p><img src="http://img.nixiaolei.com/2019-05-03-17-30-33.png" alt="替换材质后效果"></p>
<p>我们看到这些三维物体上确实都有了些反光的效果</p>
<p>但是， 有反光还不够， 既然有光那肯定要有阴影， 但是绘制阴影是比较耗费性能的，所以<code>Three.js</code> 默认不会打开， 但是我们想绘制也是比较容易的</p>
<h2 id="给各个物体打开阴影"><a href="#给各个物体打开阴影" class="headerlink" title="给各个物体打开阴影"></a>给各个物体打开阴影</h2><p>首先给绘制对象打开阴影设置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renderer.shadowMapEnabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>然后将几个三维对象分别打开<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开面的阴影</span></span><br><span class="line">plane.receiveShadow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开立方体的阴影</span></span><br><span class="line">cube.castShadow = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开球面体的阴影</span></span><br><span class="line">sphere.castShadow = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>最后还需要给光源定义一下阴影， 让他可以生成阴影</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">spotLight.castShadow = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>添加完阴影后，我们刷新一下浏览器， 阴影出来了， 只是有些粗糙</p>
<p><img src="http://img.nixiaolei.com/2019-05-03-17-44-10.png" alt="阴影"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><blockquote>
<p>git地址: <a href="https://0x9.me/ohetH" target="_blank" rel="noopener">https://0x9.me/ohetH</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置场景,</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置相机                      视角,  宽度/高度,   近距离点,  远距点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    camera.position.x = -30</span></span><br><span class="line"><span class="undefined">    camera.position.y = 40</span></span><br><span class="line"><span class="undefined">    camera.position.z = 30</span></span><br><span class="line"><span class="javascript">    camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置绘制对象---基于Webgl的渲染器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 控制渲染尺寸</span></span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 打开阴影</span></span></span><br><span class="line"><span class="javascript">    renderer.shadowMapEnabled = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置辅助测试工具</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span></span><br><span class="line"><span class="undefined">    scene.add(axes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置平面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置旋转角度</span></span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    plane.position.x = 15</span></span><br><span class="line"><span class="undefined">    plane.position.y = 0</span></span><br><span class="line"><span class="undefined">    plane.position.z = 0</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    plane.receiveShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置立方体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>)  <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置基础材质</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xff0000</span>&#125;) <span class="comment">// 设置颜色和打开线框</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    cube.position.x = 4</span></span><br><span class="line"><span class="undefined">    cube.position.y = 3</span></span><br><span class="line"><span class="undefined">    cube.position.z = 0</span></span><br><span class="line"><span class="javascript">    cube.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(cube)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置球面体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereGemometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span> &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGemometry, sphereMaterial)</span></span><br><span class="line"><span class="undefined">    sphere.position.x = 20</span></span><br><span class="line"><span class="undefined">    sphere.position.y = 4</span></span><br><span class="line"><span class="undefined">    sphere.position.z = -2</span></span><br><span class="line"><span class="javascript">    sphere.castShadow = <span class="literal">true</span> </span></span><br><span class="line"><span class="undefined">    scene.add(sphere)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    *  添加材质和灯光</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置点光源</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> spotLight = <span class="keyword">new</span> THREE.SpotLight(<span class="number">0xffffff</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置位置</span></span></span><br><span class="line"><span class="undefined">    spotLight.position.set(-40, 60, -10)</span></span><br><span class="line"><span class="javascript">    spotLight.castShadow = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加进点光源</span></span></span><br><span class="line"><span class="undefined">    scene.add(spotLight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * 输出</span></span><br><span class="line"><span class="undefined">    *</span></span><br><span class="line"><span class="undefined">    * */</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将renderer的输出挂到body</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class="line"><span class="undefined">    renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】命令手册</title>
    <url>/2019/04/02/%E3%80%90Linux%E3%80%91%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>linux 只有区的概念</p>
<h2 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl + c</td>
<td>结束正在运行的程序 【 ping 、 teInet等】</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>结束输入或退出shell</td>
</tr>
<tr>
<td>ctrl + s</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>ctrl + q</td>
<td>恢复屏幕输出</td>
</tr>
<tr>
<td>ctrl + l</td>
<td>清屏， 等同于Clear</td>
</tr>
<tr>
<td>ctrl + a / ctrl + e</td>
<td>快速移动光标到行首 / 行尾</td>
</tr>
</tbody>
</table>
<h2 id="身份命令"><a href="#身份命令" class="headerlink" title="身份命令"></a>身份命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>sudo</td>
<td>暂时以root 用户身份运行命令</td>
</tr>
<tr>
<td>su</td>
<td>切换用户身份, root身份切换不需要密码</td>
</tr>
<tr>
<td>exit</td>
<td>退出当前身份或退出连接</td>
</tr>
<tr>
<td>w</td>
<td>查看正在登录用户</td>
</tr>
</tbody>
</table>
<h3 id="路径知识"><a href="#路径知识" class="headerlink" title="路径知识"></a>路径知识</h3><ul>
<li>Linux下文件前带<code>.</code>表示隐藏文件</li>
<li>一个<code>.</code>代表当前目录, 两个<code>..</code>代表上级目录</li>
</ul>
<h2 id="资源目录相关命令"><a href="#资源目录相关命令" class="headerlink" title="资源目录相关命令"></a>资源目录相关命令</h2><blockquote>
<p>a是显示隐藏文件, l是显示长列表格</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls 或 dir</td>
<td>查看当前目录内容</td>
</tr>
<tr>
<td>ls -l</td>
<td>显示长格式目录, 有创建时间,修改信息, 文件大小</td>
</tr>
<tr>
<td>ls -a</td>
<td>显示隐藏文件</td>
</tr>
<tr>
<td>ls -al</td>
<td>查看目录所有对应的权限( )</td>
</tr>
<tr>
<td>pwd</td>
<td>宣誓当前目录的全部路径</td>
</tr>
<tr>
<td>cd ~</td>
<td>进入到当前分配<code>home</code>目录下的用户区域, 比如<code>/home/nxl</code></td>
</tr>
<tr>
<td>cd /</td>
<td>进入系统的根目录</td>
</tr>
</tbody>
</table>
<h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><ul>
<li>[old] 表示旧文件       </li>
<li>[new] 表示操作后的文件     </li>
<li>[target] 目标文件        </li>
<li>[targetDir] 目标目录</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir</td>
<td>创建文件夹</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除文件</td>
</tr>
<tr>
<td>touch [new]</td>
<td>创建文件</td>
</tr>
<tr>
<td>rm [target]</td>
<td>删除文件</td>
</tr>
<tr>
<td>rm -r [targetDir]</td>
<td>删除文件夹</td>
</tr>
<tr>
<td>rm -rf *</td>
<td>删除所有内容(r递归, f强制)</td>
</tr>
<tr>
<td>cp [old] [test/new]</td>
<td>复制文件</td>
</tr>
<tr>
<td>cp [old] -R [test/new]</td>
<td>复制目录 </td>
</tr>
<tr>
<td>ln -s old new</td>
<td>建立软链</td>
</tr>
</tbody>
</table>
<h2 id="界面切换命令-init-number"><a href="#界面切换命令-init-number" class="headerlink" title="界面切换命令 init [number]"></a>界面切换命令 init [number]</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户</td>
</tr>
<tr>
<td>2</td>
<td>多用户状态没有网络服务</td>
</tr>
<tr>
<td>3</td>
<td>多用户状态有网络服务(就是平时的小黑窗)</td>
</tr>
<tr>
<td>4</td>
<td>系统未使用保留给用户</td>
</tr>
<tr>
<td>5</td>
<td>图形界面</td>
</tr>
<tr>
<td>6</td>
<td>系统重启</td>
</tr>
</tbody>
</table>
<h2 id="服务-进程管理命令"><a href="#服务-进程管理命令" class="headerlink" title="服务 / 进程管理命令"></a>服务 / 进程管理命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>systemctl</td>
<td>查看进程</td>
</tr>
<tr>
<td>ststemctl [ status , start , stop , restart ] nginx</td>
<td>如对 nginx 执行相关命令 </td>
</tr>
<tr>
<td>top</td>
<td>进程资源实时状态</td>
</tr>
<tr>
<td>ps  [aux]</td>
<td>进程快照</td>
</tr>
<tr>
<td>kill [-9] pid</td>
<td>杀死进程</td>
</tr>
<tr>
<td>pkill [name]</td>
<td>根据进程名杀死进程</td>
</tr>
</tbody>
</table>
<h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ifconfig</td>
<td>查看网络接口（ interface）</td>
</tr>
<tr>
<td>ip</td>
<td>网络配置工具箱</td>
</tr>
<tr>
<td>route</td>
<td>诊断网络</td>
</tr>
<tr>
<td> ipdown eth0</td>
<td>关闭<code>eth0</code>网卡</td>
</tr>
<tr>
<td>ipup eth0</td>
<td>开启<code>eth0</code>网卡</td>
</tr>
<tr>
<td>ss -anp , grep :22</td>
<td>查找占用端口情况</td>
</tr>
<tr>
<td>netstat -anp , grep :22</td>
<td>查找占用端口情况</td>
</tr>
</tbody>
</table>
<h2 id="命令行下载命令"><a href="#命令行下载命令" class="headerlink" title="命令行下载命令"></a>命令行下载命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>curl</td>
<td>查看网络接口（ interface）</td>
</tr>
<tr>
<td>wget</td>
<td>网络配置工具箱</td>
</tr>
<tr>
<td>wget -c</td>
<td>断点续传</td>
</tr>
</tbody>
</table>
<h2 id="vi-vim-行编辑器"><a href="#vi-vim-行编辑器" class="headerlink" title="vi / vim 行编辑器"></a>vi / vim 行编辑器</h2><blockquote>
<p>vim是vi的增强版</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vi [target]</td>
<td>编辑目标文件</td>
</tr>
<tr>
<td>cat [target]</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>i (insert)</td>
<td>在当前光标所在字符的前面，转为编辑模式；</td>
</tr>
<tr>
<td>a (append)</td>
<td>在当前光标所在字符的后面，转为编辑模式；</td>
</tr>
<tr>
<td>o</td>
<td>在当前光标所在行的下方，新建一行，并转为输入模式；</td>
</tr>
<tr>
<td>I</td>
<td>在当前光标所在行的行首，转换为输入模式</td>
</tr>
<tr>
<td>A</td>
<td>在当前光标所在行的行尾，转换为输入模式</td>
</tr>
<tr>
<td>O</td>
<td>在当前光标所在行的上方，新建一行，并转为输入模式；</td>
</tr>
<tr>
<td>esc</td>
<td>退出编辑, ubuntu 需要 <code>esc + :</code></td>
</tr>
<tr>
<td>:q</td>
<td>退出编辑</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>:wq</td>
<td>退出并保存</td>
</tr>
</tbody>
</table>
<h2 id="系统操作命令"><a href="#系统操作命令" class="headerlink" title="系统操作命令"></a>系统操作命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>！</td>
<td>强制执行命令</td>
</tr>
<tr>
<td>shutdown -h now</td>
<td>立刻关机</td>
</tr>
<tr>
<td>shutdown -r now /reboot</td>
<td>立刻重启计算机</td>
</tr>
<tr>
<td>su - root</td>
<td>先用普通账户登录再切换 sudo临时已管理员操作</td>
</tr>
<tr>
<td>logout</td>
<td>用户注销</td>
</tr>
</tbody>
</table>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–help</td>
<td>查看命令帮助</td>
</tr>
<tr>
<td>man xxx</td>
<td>查看详细手册</td>
</tr>
</tbody>
</table>
<h2 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>关机</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【SSR】nuxt.js服务端渲染体验笔记</title>
    <url>/2019/04/02/%E3%80%90SSR%E3%80%91nuxt-js%E4%BD%93%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>官网: <a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">https://zh.nuxtjs.org/</a></p>
</blockquote>
<p>这段时间公司招了个专门搞seo优化的,  经过他的建议我们需要整改一系列之前没有注意的细节来提升SEO的优化</p>
<p>给我们提出了大致以下的建议</p>
<ol>
<li>对非必要跟踪的页面的<code>a</code>标签添加 <code>noffollow</code>属性</li>
<li>需要对首页的<code>meta</code>的<code>title</code>,<code>keyword</code>, <code>description</code>进行设置, 而且要避免大写</li>
<li>网页静态化, 使用 <code>/</code>路由参数, 而不是<code>query</code>形式的参数(<code>?</code>)</li>
<li>去掉无关页面的<code>keyword</code>和 <code>description</code>标签</li>
<li>必须要有404页面</li>
<li>提供一个专门给爬虫爬取的<code>新闻栏目</code>, 并且入口对用户不可见</li>
<li>生成<code>sitemap.html</code>和<code>sitemap.xml</code>文件,  并在网站底部”链接”的地方以”网站地图”和”XML”添加</li>
<li>配置<code>robots.txt</code>文件</li>
<li>需要SSR</li>
</ol>
<p>最后一点也就是工程量最大的一点–SSR, 就是使用<code>Nuxt.js</code>的目的</p>
<p>怎么起步就不说了, 官网写的很好, 这里就记录一下本次尝试中花了比较多的时间去理解的地方, 以及坑</p>
<h2 id="compoents-和-pages目录"><a href="#compoents-和-pages目录" class="headerlink" title="compoents 和 pages目录"></a>compoents 和 pages目录</h2><p>顾名思义, Pages 文件夹应该存放的是页面, components应该是组件,  这其实在最开始是比较容易混淆的,  在我们平时习惯性的使用vue的时候, 一个vue文件既可以作为组件也可以作为页面,  但在 <code>Nuxt</code> 中是类似但不完全相同,  </p>
<p>pages 中的页面组件具有被强化的几个方法<br><img src="http://img.nixiaolei.com/2019-05-02-19-08-21.png" alt="页面组件"></p>
<p>而components 则确实是组件的定义,  它就是最普通的<code>vue</code>组件</p>
<h2 id="可选与必选动态路由"><a href="#可选与必选动态路由" class="headerlink" title="可选与必选动态路由"></a>可选与必选动态路由</h2><p>Nuxt.js 的路由按照pages 文件夹的具体目录结构自动划分,  动态路由也是如此, 但动态路由可被分为可选和必选,  </p>
<p>可选路由, 访问路径demo: <code>people/123</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages/</span><br><span class="line">--| people/</span><br><span class="line">-----| _id.vue</span><br><span class="line">--| _.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure></p>
<p>这样的结构是 必选路由,  访问路径demo: <code>people/123/456</code></p>
<blockquote>
<p>同时可接收 123 和 456 两个参数, 并且 123 参数必须有<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages/</span><br><span class="line">--| people/</span><br><span class="line">-----| _id/</span><br><span class="line">---------| _id.vue</span><br><span class="line">---------| index.vue</span><br><span class="line">--| _.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h2><p><code>_.vue</code> 可以用来充当路由未被匹配上的情况, 所以我们需要的404页面就可以使用<code>_.vue</code>来编写, 放在pages目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pages/</span><br><span class="line">--| _.vue</span><br><span class="line">--| index.vue</span><br></pre></td></tr></table></figure>
<h2 id="使用axios"><a href="#使用axios" class="headerlink" title="使用axios"></a>使用axios</h2><p>必须要在<code>nuxt.config.js</code>中添加关于<code>axios</code>的配置, 才能使用<code>this.$axios</code>访问到<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios: &#123;</span><br><span class="line">  proxy: <span class="literal">true</span>,</span><br><span class="line">  prefix: <span class="string">'http://jsonplaceholder.typicode.com'</span>, <span class="comment">// baseURL</span></span><br><span class="line">  credentials: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/api/'</span>: &#123;</span><br><span class="line">    target: <span class="string">'http://127.0.0.1:2001'</span>, <span class="comment">// 代理地址</span></span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="使用axios-1"><a href="#使用axios-1" class="headerlink" title="使用axios"></a>使用axios</h2><p>不需要创建 <code>vuex</code>实例<br>只需要把你的 <code>state</code>,<code>getters</code>等等导出即可,  命名空间的方式也是如此,只需要多建一个文件即可</p>
<p>如下:<br><code>store/index.js</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  userInfo: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getters = &#123;</span><br><span class="line">  getUserInfo (state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.userInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  setUserInfo (state, data) &#123;</span><br><span class="line">    state.userInfo = data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fetch.js</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  posts: <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getters = &#123;</span><br><span class="line">  getPosts (state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.posts</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  setPosts (state, data) &#123;</span><br><span class="line">    state.posts = data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>fetch</code>中的state时:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写数据</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'fetch/setPosts'</span>, res.data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="keyword">this</span>.posts = <span class="keyword">this</span>.$store.getters[<span class="string">'fetch/getPosts'</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="服务端与客户端数据传递"><a href="#服务端与客户端数据传递" class="headerlink" title="服务端与客户端数据传递"></a>服务端与客户端数据传递</h2><p>利用vuex里提供的<code>nuxtServerInit</code>,  Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟）</p>
<p>举个例子，假设我们服务端的会话状态树里可以通过 req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  nuxtServerInit (&#123; commit &#125;, &#123; req &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">      commit(<span class="string">'user'</span>, req.session.user)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果你使用<em>状态树模块化</em>的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。</p>
</blockquote>
<h2 id="生命周期的调用环境"><a href="#生命周期的调用环境" class="headerlink" title="生命周期的调用环境"></a>生命周期的调用环境</h2><p>在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个方法会在 客户端和服务端被调用。其他生命周期函数仅在客户端被调用。</p>
]]></content>
      <categories>
        <category>SEO</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>SSR</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】高阶用法</title>
    <url>/2019/04/02/%E3%80%90React%E3%80%91%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><blockquote>
<p>当未传入props时使用预设的默认值</p>
</blockquote>
<p>使用静态属性<code>defaultProps</code>来定义<code>props</code>的默认值, 避免未传<code>props</code>报错的情况<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  thing: <span class="string">"这是默认的props参数"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// todoList.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; </span><br><span class="line">      todoList: [</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'喝可乐'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'打游戏'</span> &#125;,</span><br><span class="line">        <span class="comment">// 故意留空一个</span></span><br><span class="line">        &#123;  &#125;,</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'看电影'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'看剧'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'刷抖音'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">thing</span>: <span class="string">'吃饭'</span> &#125;</span><br><span class="line">      ] </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; todoList &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"wrap"</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          todoList.map( <span class="function"><span class="params">item</span> =&gt;</span> &lt;TodoItem  thing=&#123;item.thing&#125; /&gt;)</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ todoItem.jsx</span></span><br><span class="line"><span class="regexp">class TodoItem extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  static defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    thing: "这是默认的props参数"</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123; this.props.thing &#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际显示:<br><img src="http://img.nixiaolei.com/2019-04-07-11-28-59.png" alt="props默认值"></p>
<h2 id="自由的render返回值类型"><a href="#自由的render返回值类型" class="headerlink" title="自由的render返回值类型"></a>自由的render返回值类型</h2><blockquote>
<p><code>render</code>函数的要求没有以前严格了， 不用固定返回<code>dom</code> 以及 免除必须使用<code>()</code>包裹</p>
</blockquote>
<h3 id="返回dom"><a href="#返回dom" class="headerlink" title="返回dom"></a>返回dom</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello React'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回数组"><a href="#返回数组" class="headerlink" title="返回数组"></a>返回数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;li&gt;<span class="number">1111</span>&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;2222&lt;/</span>li&gt;,</span><br><span class="line">      &lt;li&gt;<span class="number">3333</span>&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="空的根节点"><a href="#空的根节点" class="headerlink" title="空的根节点"></a>空的根节点</h2><blockquote>
<p>避免了无故地嵌套</p>
</blockquote>
<p>写法一：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>写法二 ：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用文档片段</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>hello world3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种写法的效果是一样的：<br><img src="http://img.nixiaolei.com/2019-04-07-12-57-12.png" alt="空地根节点"></p>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><blockquote>
<p>自动为状态组件添加<code>shouldComponentUpdate</code>函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更安全的数据类型"><a href="#更安全的数据类型" class="headerlink" title="更安全的数据类型"></a>更安全的数据类型</h2><p>使用<code>immutableJs</code></p>
<h2 id="处理异步任务及组件"><a href="#处理异步任务及组件" class="headerlink" title="处理异步任务及组件"></a>处理异步任务及组件</h2><p>站内搜索 <code>react16.6中如何处理异步</code></p>
<h2 id="为函数组件做性能优化"><a href="#为函数组件做性能优化" class="headerlink" title="为函数组件做性能优化"></a>为函数组件做性能优化</h2><p>站内搜索 <code>memo</code></p>
<h2 id="新版ref用法"><a href="#新版ref用法" class="headerlink" title="新版ref用法"></a>新版ref用法</h2><p>站内搜索 <code>react16中如何使用ref</code></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门之绘制三维对象</title>
    <url>/2019/04/02/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BB%98%E5%88%B6%E4%B8%89%E7%BB%B4%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<ul>
<li>Plane ( 平面 ) 二维矩形，渲染结果是在屏幕中央有个灰色矩形</li>
<li>Cube (方块) 三维立方体。</li>
<li>Sphere ( 球体 ) 三维球体。</li>
<li>Camera ( 相机 ) 决定视点的位置， 和最终观察结果</li>
<li>Axes ( 轴 ) 辅助测试工具</li>
</ul>
<h2 id="第一步-设置场景"><a href="#第一步-设置场景" class="headerlink" title="第一步-设置场景"></a>第一步-设置场景</h2><p>变量<code>Scene</code>是一个容器， 它用来保存并且跟踪我们想渲染的物体<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span><br></pre></td></tr></table></figure></p>
<p>具体内容我们后续会添加到 <code>scene</code>中</p>
<h2 id="第二步-设置相机"><a href="#第二步-设置相机" class="headerlink" title="第二步-设置相机"></a>第二步-设置相机</h2><p><code>camera</code>用来控制我们所看到的方向角度<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置相机                    视角,  宽度/高度,   近距离点,  远距点</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth/<span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 设置坐标</span></span><br><span class="line">camera.position.x = <span class="number">-30</span></span><br><span class="line">camera.position.y = <span class="number">40</span></span><br><span class="line">camera.position.z = <span class="number">30</span></span><br><span class="line"><span class="comment">// 设置朝向</span></span><br><span class="line">camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第三步-设置绘制对象"><a href="#第三步-设置绘制对象" class="headerlink" title="第三步-设置绘制对象"></a>第三步-设置绘制对象</h2><p>我们创建一个基于<code>webgl</code>的渲染器, 当然还有其他的渲染器( canvas ,svg渲染器等)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span><br><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span><br><span class="line"><span class="comment">// 控制渲染尺寸</span></span><br><span class="line">renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span><br></pre></td></tr></table></figure></p>
<h2 id="第四步-设置辅助测试工具"><a href="#第四步-设置辅助测试工具" class="headerlink" title="第四步-设置辅助测试工具"></a>第四步-设置辅助测试工具</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置辅助测试工具</span></span><br><span class="line"><span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span><br><span class="line">scene.add(axes)</span><br></pre></td></tr></table></figure>
<h2 id="第五步-创建集合体"><a href="#第五步-创建集合体" class="headerlink" title="第五步-创建集合体"></a>第五步-创建集合体</h2><h3 id="创建一个平面"><a href="#创建一个平面" class="headerlink" title="创建一个平面"></a>创建一个平面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置平面</span></span><br><span class="line"><span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span><br><span class="line"><span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span><br><span class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span><br><span class="line"><span class="comment">// 设置旋转角度</span></span><br><span class="line">plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="comment">// 设置坐标</span></span><br><span class="line">plane.position.x = <span class="number">15</span></span><br><span class="line">plane.position.y = <span class="number">0</span></span><br><span class="line">plane.position.z = <span class="number">0</span></span><br><span class="line"><span class="comment">// 加入场景</span></span><br><span class="line">scene.add(plane)</span><br></pre></td></tr></table></figure>
<h3 id="创建一个立方体"><a href="#创建一个立方体" class="headerlink" title="创建一个立方体"></a>创建一个立方体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置立方体</span></span><br><span class="line"><span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>)  <span class="comment">//设置宽高和段度</span></span><br><span class="line"><span class="comment">// 设置基础材质</span></span><br><span class="line"><span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>: <span class="number">0xff0000</span>, <span class="attr">wireframe</span>: <span class="literal">true</span>&#125;) <span class="comment">// 设置颜色和打开线框</span></span><br><span class="line"><span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span><br><span class="line"><span class="comment">// 设置坐标</span></span><br><span class="line">cube.position.x = <span class="number">4</span></span><br><span class="line">cube.position.y = <span class="number">3</span></span><br><span class="line">cube.position.z = <span class="number">0</span></span><br><span class="line"><span class="comment">// 加入场景</span></span><br><span class="line">scene.add(cube)</span><br></pre></td></tr></table></figure>
<h3 id="创建一个球体"><a href="#创建一个球体" class="headerlink" title="创建一个球体"></a>创建一个球体</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置球面体</span></span><br><span class="line"><span class="keyword">var</span> sphereGemometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span>, <span class="attr">wireframe</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGemometry, sphereMaterial)</span><br><span class="line">sphere.position.x = <span class="number">20</span></span><br><span class="line">sphere.position.y = <span class="number">4</span></span><br><span class="line">sphere.position.z = <span class="number">-2</span></span><br><span class="line">scene.add(sphere)</span><br></pre></td></tr></table></figure>
<h2 id="最后一步-输出到body"><a href="#最后一步-输出到body" class="headerlink" title="最后一步-输出到body"></a>最后一步-输出到body</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将renderer的输出挂到body</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement)</span><br><span class="line">renderer.render(scene, camera)</span><br></pre></td></tr></table></figure>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="http://img.nixiaolei.com/2019-05-02-12-02-43.png" alt="最终效果"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><blockquote>
<p>git地址: <a href="https://0x9.me/ohetH" target="_blank" rel="noopener">https://0x9.me/ohetH</a></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个ThreeJs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../three.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置场景,</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置相机                      视角,  宽度/高度,   近距离点,  远距点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(<span class="number">50</span>, <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight, <span class="number">0.1</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    camera.position.x = -30</span></span><br><span class="line"><span class="undefined">    camera.position.y = 40</span></span><br><span class="line"><span class="undefined">    camera.position.z = 30</span></span><br><span class="line"><span class="javascript">    camera.lookAt(scene.position) <span class="comment">// 看向场景的中央</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置绘制对象---基于Webgl的渲染器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer()</span></span><br><span class="line"><span class="javascript">    renderer.setClearColor(<span class="keyword">new</span> THREE.Color(<span class="number">0xeeeeee</span>));</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 控制渲染尺寸</span></span></span><br><span class="line"><span class="javascript">    renderer.setSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置辅助测试工具</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> axes = <span class="keyword">new</span> THREE.AxisHelper(<span class="number">20</span>)</span></span><br><span class="line"><span class="undefined">    scene.add(axes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置平面</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> THREE.PlaneGeometry(<span class="number">70</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;<span class="attr">color</span>: <span class="number">0xcccccc</span>&#125;) <span class="comment">// 设置颜色</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> plane = <span class="keyword">new</span> THREE.Mesh(planeGeometry, planeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置旋转角度</span></span></span><br><span class="line"><span class="javascript">    plane.rotation.x = <span class="number">-0.5</span> * <span class="built_in">Math</span>.PI;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    plane.position.x = 15</span></span><br><span class="line"><span class="undefined">    plane.position.y = 0</span></span><br><span class="line"><span class="undefined">    plane.position.z = 0</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(plane)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置立方体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeGeometry = <span class="keyword">new</span> THREE.CubeGeometry(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>)  <span class="comment">//设置宽高和段度</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置基础材质</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cubeMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="attr">color</span>: <span class="number">0xff0000</span>, <span class="attr">wireframe</span>: <span class="literal">true</span>&#125;) <span class="comment">// 设置颜色和打开线框</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cube = <span class="keyword">new</span> THREE.Mesh(cubeGeometry, cubeMaterial)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置坐标</span></span></span><br><span class="line"><span class="undefined">    cube.position.x = 4</span></span><br><span class="line"><span class="undefined">    cube.position.y = 3</span></span><br><span class="line"><span class="undefined">    cube.position.z = 0</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 加入场景</span></span></span><br><span class="line"><span class="undefined">    scene.add(cube)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置球面体</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereGemometry = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4</span>, <span class="number">20</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphereMaterial = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x7777ff</span>, <span class="attr">wireframe</span>: <span class="literal">true</span> &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.Mesh(sphereGemometry, sphereMaterial)</span></span><br><span class="line"><span class="undefined">    sphere.position.x = 20</span></span><br><span class="line"><span class="undefined">    sphere.position.y = 4</span></span><br><span class="line"><span class="undefined">    sphere.position.z = -2</span></span><br><span class="line"><span class="undefined">    scene.add(sphere)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将renderer的输出挂到body</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class="line"><span class="undefined">    renderer.render(scene, camera)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【Three】Three.js入门学习笔记</title>
    <url>/2019/04/02/%E3%80%90Three%E3%80%91Three-js%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebGL是基于OpenGl ES 2.0的Web标准， 可以通过HTML5 Canvas 元素作为Dom接口访问。</p>
<p>WebGl 灵活且复杂。</p>
<p><strong>Three.js 是一个3D JavaScript 库， Three.js 库可简化 WebGL 开发。</strong></p>
<p><strong>Three.js 封装了底层的图形接口， 能够在无需掌握繁冗的图形学知识的情况下， 也能用简单的代码实现三位场景的渲染</strong></p>
<h2 id="Three-js用途"><a href="#Three-js用途" class="headerlink" title="Three.js用途"></a>Three.js用途</h2><ul>
<li>创建三维图形</li>
<li>在三维场景中生成动画</li>
<li>在物体上应用纹理和材质。</li>
<li>从三维建模软件中加载图形</li>
<li>创建基于样条曲线的二维图形</li>
</ul>
<h2 id="其他web3D引擎"><a href="#其他web3D引擎" class="headerlink" title="其他web3D引擎"></a>其他web3D引擎</h2><p>插件式:</p>
<ul>
<li>Flash</li>
<li>O3D</li>
<li>Unity3d</li>
</ul>
<p>原生:</p>
<ul>
<li>GLGE</li>
<li>X3DOM</li>
<li>PhiloGL</li>
<li>CopperLicht</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>浏览器原生支持， 不需要安装插件</li>
<li>对操作系统、 浏览器兼容性高， 支持移动平台</li>
<li>基于HTML5/WebGL, 是 Web开发的主流； 开发维护非常活跃</li>
<li>组件及案例丰富， 易于学习掌握； 设计优雅、 灵活， 方便以及增加新的特性</li>
</ul>
<hr>
<ul>
<li>基于 WebGL/OpenGL ES 2.0</li>
<li>使用熟悉的HTML/JavaScript</li>
<li>对底层的WebGl的高级封装</li>
<li>保留底层开发的特性</li>
<li>结构严谨灵活、 易于扩展</li>
</ul>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>ThreeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>了解CPU工作原理</title>
    <url>/2019/04/01/%E4%BA%86%E8%A7%A3CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>计算机在被发明出来之后， 结构基本上没有怎么改变， 目前使用最广泛的结构是“冯诺依曼结构”</p>
<h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">维基百科传送门</a></p>
</blockquote>
<p>简单而言的冯诺依曼结构处理器具有以下几个特点:</p>
<ol>
<li>必须有一个存储器；</li>
<li>必须有一个控制器；</li>
<li>必须有一个运算器，用于完成算术运算和逻辑运算；</li>
<li>必须有输入和输出设备，用于进行人机通信。</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-04-04-22-51-57.png" alt="冯诺依曼结构处理器"></p>
<p>并且还有和冯诺依曼不一样的另一种结构: <a href="https://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">哈佛结构</a></p>
<h2 id="CPU的指令集"><a href="#CPU的指令集" class="headerlink" title="CPU的指令集"></a>CPU的指令集</h2><p>指令集是存储在CPU内部，对CPU运算进行指导和优化的硬程序</p>
<p>说人话:<br>指令集就是你驱动<code>CPU</code>运算发送的指令</p>
<h3 id="x86-x64指令集"><a href="#x86-x64指令集" class="headerlink" title="x86/x64指令集"></a>x86/x64指令集</h3><p>这两种是我们目前最普遍的台式机和笔记本的<code>CPU</code>种类，</p>
<h3 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h3><p>在我们的移动设备上、 智能手表上、只能音响上</p>
<h3 id="MIPS指令集"><a href="#MIPS指令集" class="headerlink" title="MIPS指令集"></a>MIPS指令集</h3><p>一般用在服务器上， 并且是大型的服务器</p>
<h3 id="RISC指令集"><a href="#RISC指令集" class="headerlink" title="RISC指令集"></a>RISC指令集</h3><p>这属于一种精简指令， 也可以认为是一种开源的指令集</p>
<p>中国曾经自己研发的芯片 <code>龙芯</code>， 还有中国的超级计算机也是使用的这个指令集</p>
<h4 id="🌗如何兼容各指令集"><a href="#🌗如何兼容各指令集" class="headerlink" title="🌗如何兼容各指令集"></a>🌗如何兼容各指令集</h4><p>指令集是CPU原生支持的语言，不同的指令集之间是不能互换的，</p>
<p>所以C语言在编译的时候有一种方式叫<code>交叉编译</code>：</p>
<p>你在<code>X64</code>系列的CPU上去给<code>ARM</code>的CPU去编译程序，这就是交叉编译。</p>
<p>这也是做嵌入式的就比较常用这些东西。</p>
<h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul>
<li>控制器</li>
<li>运算器</li>
<li>存储器</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-04-23-02-40.png" alt="CPU结构"></p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>存储器的主要功能是存储程序和各种数据，并能在计算机运行过程中高速、自动地完成程序或数据的存取。</p>
<p>他是CPU上的缓存， 它相当于是我们考试时的<code>草稿纸</code>, 在上面写的只是运算过程， 而最终答案是写到答题纸上的(内存)</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制单元又分为： 指令计数器、 指令寄存器</p>
<p>控制负责协调运算器和存储器之间的工作</p>
<hr>
<p>总之，控制器相当于指挥官, 运算单元相当于士兵， 存储器相当于仓库， </p>
<p>指挥官指挥士兵在存库中搬弹药，做工作</p>
<h2 id="CPU如何与内存沟通"><a href="#CPU如何与内存沟通" class="headerlink" title="CPU如何与内存沟通"></a>CPU如何与内存沟通</h2><p>计算机中的数据分为两种</p>
<ol>
<li>代码段 —- 指令数据（我们写的代码）</li>
<li>数据段 —- 纯粹的数据（比如电影文件）</li>
</ol>
<p>代码段和数据段一般是分开存放的， 一定要放一起也不是不可以， 但是很有可能回引起很严重的安全问题– 缓冲区溢出，看下面的安全问题区域 👇</p>
<hr>
<p>指令计数器从代码段中找出一段指令， 放到指令寄存器中(指令寄存器可以理解为CPU中一块特殊的内存, 但是它只能放指令， 如果存数据就会宕机)， 放到指令寄存器中后， 控制器就开始根据这个指令具体的内容，把数据送入运算器， 数据从哪里来， 控制器通过数据总线从内存中拿到数据然后送入存储单元，供运算器使用</p>
<h3 id="🔥安全问题"><a href="#🔥安全问题" class="headerlink" title="🔥安全问题"></a>🔥安全问题</h3><h4 id="🌊-缓冲区溢出"><a href="#🌊-缓冲区溢出" class="headerlink" title="🌊 缓冲区溢出"></a>🌊 缓冲区溢出</h4><p>在代码段插入一些数据， 或是插入一些异常的跳转指令， 本来程序中的跳转是体现在<code>if`</code>else<code>或者是</code>for<code>循环， 这些跳转语句在计算机底层会被转换成</code>jmp`指令，从这个地方跳转到另一个地方去执行， 当你跳到另一段代码那， 这段代码就开始执行了，  也就是如果代码是经过精心设计的， 跳转到的目标代码段不是你原本想要的代码段， 而目标代码段要做危险操作， 那就危险大了， 这就是缓冲区溢出。</p>
<p>比如前两年的漏洞： 心脏滴血</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-11-53-40.png" alt="如何与内存沟通"></p>
<h2 id="经典的8086CPU结构体系"><a href="#经典的8086CPU结构体系" class="headerlink" title="经典的8086CPU结构体系"></a>经典的8086CPU结构体系</h2><p>8086是一种比较早的商业化处理器芯片<br><img src="http://img.nixiaolei.com/2019-04-06-12-32-53.png" alt="8086CPU结构"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>待学书籍</title>
    <url>/2019/04/01/%E5%BE%85%E5%AD%A6%E4%B9%A6%E7%B1%8D/</url>
    <content><![CDATA[<h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><ul>
<li>《高中数学必修123》</li>
<li>线性代数</li>
<li>离散数学</li>
</ul>
]]></content>
      <categories>
        <category>目录</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现一个bind</title>
    <url>/2019/03/31/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind/</url>
    <content><![CDATA[<p><code>bind</code>方法用来保留<code>JavaScript</code>的<code>this</code>指向， 和<code>apply</code>、<code>call</code>这两个方法不同的是，<code>bind</code>不会立即执行</p>
<p>如何模拟实现一个<code>bind</code>方法</p>
<p>初始函数，我们将对整个函数修改<code>this</code>指向<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"> name </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最普通的实现"><a href="#最普通的实现" class="headerlink" title="最普通的实现"></a>最普通的实现</h2><p>创建一个函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mybind</span>(<span class="params">func ,context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(context, args  )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFn = mybind(fn, obj, <span class="string">'小明'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="原型实现"><a href="#原型实现" class="headerlink" title="原型实现"></a>原型实现</h2><p>创建一个函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _this.apply( context, [ ...args, ...args2] )</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFn = fn.mybind(obj, <span class="string">'小明'</span> )</span><br></pre></td></tr></table></figure></p>
<p>实现很简单， 但是还差一步，就是<code>bind</code>后的函数， 拿来作为构造函数<code>new</code>时， <code>this</code>指向会出问题</p>
<h2 id="处理new-的指向"><a href="#处理new-的指向" class="headerlink" title="处理new 的指向"></a>处理new 的指向</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mybind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cbFn</span> (<span class="params">...tempArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> cbFn ? _this.apply(<span class="keyword">this</span>, [ ...args, ...tempArgs]) : _this.apply( context, [ ...args, ...tempArgs] )</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> cbFn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> BindFn = fn.mybind(obj, <span class="string">'小明'</span> )</span><br><span class="line"><span class="keyword">var</span> bfn = <span class="keyword">new</span> BindFn()</span><br></pre></td></tr></table></figure>
<p>参考文献</p>
<ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/13</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>this的软绑定和硬绑定</title>
    <url>/2019/03/30/this%E7%9A%84%E8%BD%AF%E7%BB%91%E5%AE%9A%E5%92%8C%E7%A1%AC%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>被调用的函数示例<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果严格模式， "use strict"加在此处</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>“use strict” 严格模式的软绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn()  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.apply(&#123;&#125;,[<span class="string">'a'</span>])  <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>忽略硬绑定， 使用软绑定<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.apply(<span class="literal">null</span>,[<span class="string">'a'</span>])  <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p>
<p>“use strict” 严格模式<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.apply(&#123;&#125;,[<span class="string">'a'</span>])  <span class="comment">// &#123;&#125;</span></span><br><span class="line">fn.apply(<span class="literal">null</span>,[<span class="string">'a'</span>])  <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Iaas、PaaS、SaaS的区别</title>
    <url>/2019/03/29/%E7%90%86%E8%A7%A3Iaas%E3%80%81PaaS%E3%80%81SaaS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：<br>买服务器，安装服务器软件，编写网站程序。</p>
<h2 id="😦Iaas"><a href="#😦Iaas" class="headerlink" title="😦Iaas"></a>😦Iaas</h2><blockquote>
<p>比如: 普通的云服务器</p>
</blockquote>
<p>现在你追随潮流，采用流行的云计算，如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件。</p>
<h2 id="😧PaaS"><a href="#😧PaaS" class="headerlink" title="😧PaaS"></a>😧PaaS</h2><blockquote>
<p>比如: 阿里云的虚拟机</p>
</blockquote>
<p>而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序</p>
<h2 id="😨SaaS"><a href="#😨SaaS" class="headerlink" title="😨SaaS"></a>😨SaaS</h2><blockquote>
<p>如淘宝对于商家</p>
</blockquote>
<p>如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。</p>
<p>参考文献</p>
<ul>
<li><a href="https://www.zhihu.com/question/20387284" target="_blank" rel="noopener">https://www.zhihu.com/question/20387284</a></li>
</ul>
]]></content>
      <categories>
        <category>专业术语</category>
      </categories>
      <tags>
        <tag>专业术语</tag>
      </tags>
  </entry>
  <entry>
    <title>【容器】搭建第一个docker环境</title>
    <url>/2019/03/28/%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="初始化一个NodeJs程序"><a href="#初始化一个NodeJs程序" class="headerlink" title="初始化一个NodeJs程序"></a>初始化一个NodeJs程序</h2><p>以下操作必须已经安装了了NodeJS。<br>首先创建一个空文件夹。并创建以下⽂文件：</p>
<ul>
<li>server.js</li>
<li>package.json</li>
<li>Dockerfile</li>
<li>.dockerignore</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir docker_demo</span><br><span class="line">cd docker_demo</span><br><span class="line">touch server.js</span><br><span class="line">touch package.json</span><br><span class="line">touch Dockerfile</span><br><span class="line">touch .dockerignore</span><br></pre></td></tr></table></figure>
<p>然后在server.js写⼊入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello docker'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>在package.json中写入</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"koa"</span>: <span class="string">"^2.5.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序。控制台输⼊<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p>
<p>浏览器打开本地测试,如果如图所示。表示demo创建成功。请继续往下。</p>
<p><img src="http://img.nixiaolei.com/2019-04-08-21-05-28.png" alt="本地测试"></p>
<h2 id="创建dockerfile文件"><a href="#创建dockerfile文件" class="headerlink" title="创建dockerfile文件"></a>创建dockerfile文件</h2><p>Dockerfile是由一系列命令和参数构成的脚本，一个Dockerfile⾥里里⾯面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列列命令自动构建image. 在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Logs</span></span><br><span class="line">logs</span><br><span class="line">*.log</span><br><span class="line">npm-debug.log*</span><br><span class="line"><span class="comment"># Runtime data</span></span><br><span class="line">pids</span><br><span class="line">*.pid</span><br><span class="line">*.seed</span><br><span class="line"><span class="comment"># Directory for instrumented libs generated by jscoverage/JSCover</span></span><br><span class="line">lib-cov</span><br><span class="line"><span class="comment"># Coverage directory used by tools like istanbul</span></span><br><span class="line"></span><br><span class="line">coverage</span><br><span class="line"><span class="comment"># nyc test coverage</span></span><br><span class="line">.nyc_output</span><br><span class="line"><span class="comment"># Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)</span></span><br><span class="line">.grunt</span><br><span class="line"><span class="comment"># node-waf configuration</span></span><br><span class="line">.lock-wscript</span><br><span class="line"><span class="comment"># Compiled binary addons (http://nodejs.org/api/addons.html)</span></span><br><span class="line">build/Release</span><br><span class="line"><span class="comment"># Dependency directories</span></span><br><span class="line">node_modules</span><br><span class="line">jspm_packages</span><br><span class="line"><span class="comment"># Optional npm cache directory</span></span><br><span class="line">.npm</span><br><span class="line"><span class="comment"># Optional REPL history</span></span><br><span class="line">.node_repl_history</span><br><span class="line">.idea</span><br><span class="line">.node_modules</span><br><span class="line">node_modules</span><br><span class="line">.vscode</span><br></pre></td></tr></table></figure>
<p>在Dockerfile文件中写入以下代码：<br><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment">#制定node镜像的版本</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.9</span>-alpine</span><br><span class="line"><span class="comment">#声明作者</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> evilboy</span><br><span class="line"><span class="comment">#移动当前⽬目录下⾯面的⽂文件到app⽬目录下</span></span><br><span class="line"><span class="keyword">ADD</span> . /app/</span><br><span class="line"><span class="comment">#进⼊入到app⽬目录下⾯面，类似cd</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span> npm install</span><br><span class="line"><span class="comment">#对外暴暴露露的端⼝口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment">#程序启动脚本</span></span><br><span class="line"><span class="keyword">CMD</span> ["npm", "start"]</span><br></pre></td></tr></table></figure></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><blockquote>
<p>使用build命令构造镜像,注意后⾯面那个“.”不不能少。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Sandbox-N ~]# docker build -t docker_demo .</span><br><span class="line">Sending build context to Docker daemon 39.94kB</span><br><span class="line">Step 1/7 : FROM node:8.9-alpine</span><br><span class="line"><span class="meta">---&gt;</span> 406f227b21f5</span><br><span class="line">Step 2/7 : MAINTAINER robin</span><br><span class="line"><span class="meta">---&gt;</span> Using cache</span><br><span class="line"><span class="meta">---&gt;</span> 78d6cdbcfee2</span><br><span class="line">Step 3/7 : ADD . /app/</span><br><span class="line"><span class="meta">---&gt;</span> 2cb30678612d</span><br><span class="line">Step 4/7 : WORKDIR /app</span><br><span class="line">Removing intermediate container e51377081039</span><br><span class="line"><span class="meta">---&gt;</span> c2b7d0f37d2d</span><br><span class="line">Step 5/7 : RUN npm install</span><br><span class="line"><span class="meta">---&gt;</span> Running in da0c3946ca8d</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit</span><br><span class="line">this file.</span><br><span class="line">added 38 packages in 3.323s</span><br><span class="line">Removing intermediate container da0c3946ca8d</span><br><span class="line"><span class="meta">---&gt;</span> eecee87f10e2</span><br><span class="line">Step 6/7 : EXPOSE 3000</span><br><span class="line"><span class="meta">---&gt;</span> Running in f3973cc168a4</span><br><span class="line">Removing intermediate container f3973cc168a4</span><br><span class="line"><span class="meta">---&gt;</span> 2671a4c6deb4</span><br><span class="line">Step 7/7 : CMD ["npm", "start"]</span><br><span class="line"><span class="meta">---&gt;</span> Running in dec529f754aa</span><br><span class="line">Removing intermediate container dec529f754aa</span><br><span class="line"><span class="meta">---&gt;</span> 6ec73793d353</span><br><span class="line">Successfully built 6ec73793d353</span><br><span class="line">Successfully tagged docker_demo:latest</span><br></pre></td></tr></table></figure>
<p>等待镜像构造完成。然后使用 images命令查看镜像。</p>
<p><img src="http://img.nixiaolei.com/2019-04-08-21-08-27.png" alt="查看镜像"></p>
<p>此时可以看到images已经构造完成。现在开始启动images，并测试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>启动镜像 -d表示后台执⾏行行，-p 9000:3000表示指定本地的9000端⼝口隐射到容器器内的3000端⼝口，</span><br><span class="line">docker_demo为镜像名称</span><br><span class="line">docker run -d -p 9000:3000 docker_demo</span><br><span class="line"><span class="meta">#</span>查看容器器</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><img src="http://img.nixiaolei.com/2019-04-08-21-09-13.png" alt="查看容器"></p>
<p>此时浏览器打开<a href="http://localhost:9000/,如果如图所示。表示容器运行正常。" target="_blank" rel="noopener">http://localhost:9000/,如果如图所示。表示容器运行正常。</a></p>
<p><img src="http://img.nixiaolei.com/2019-04-08-21-10-04.png" alt="正常情况"></p>
<p>如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。</p>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>简单理解破解与脱壳</title>
    <url>/2019/03/28/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E7%A0%B4%E8%A7%A3%E4%B8%8E%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<h2 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h2><p>想要破解别人的程序， 必然要对别人代码进行分析， 分析手段无非两种:</p>
<ol>
<li>静态分析</li>
<li>动态分析</li>
</ol>
<p>利用动态分析就可以绕过类似注册码的步骤</p>
<p>如何避免别人通过分析绕过注册码等步骤呢， 就需要对程序加一层壳， </p>
<p>当你程序在载入到内存的时候， 要先去检查一下环境，看看自身是否跑在调试器的环境里， 如果在调试器的环境，就要把调试器的环境破坏掉，不让你进行动态分析，</p>
<p>这就是加壳的一种手段</p>
<p>或者还有其他的手段， 例如，把真正的程序压缩到其他地方， 当启动<code>exe</code>程序时再将真正的程序解压缩， 用来防止动态分析</p>
<blockquote>
<p>脱壳就是扒掉这层防护</p>
</blockquote>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>静态分析就是直接去看别人的源代码， 当然别人写的C的源代码你是看不到的， 必须进行反编译， 但是反编译也不是那么的完美， 无法恢复回原来的样子， 会非常难以理解。</p>
<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>类似于<code>debugger</code>, 借助调试器，  可以看到代码的当前执行状况， 跳转地址、内存当中的状态</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript事件机制</title>
    <url>/2019/03/26/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>首先我们都知道JavaScript是单线程的， 当然现在浏览器中 HTML5 为我们提供了<code>Web-Worker</code>, 但JavaScript本质上还是一门单线程的语言，</p>
<p>这也是为了保持JavaScript 的简单易学，并且这也和DOM有关，因为如果 JavaScript 是多线程的， 一个县城增加了 DOM，一个删除了DOM， 那该听哪个线程的</p>
<p>所以JavaScript 放弃了多线程</p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>单线程当遇到比较费事的操作带来的后果就是浏览器卡死， 那怎么办？<br>为了应对这些问题， JavaScript将事件分为了</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>所有的事件任务都被加入到栈内,  栈的特点是先入后出， 如下图</p>
<p><img src="http://img.nixiaolei.com/js-stack.gif" alt="js事件执行栈"></p>
<p>看图中， 最开始调用的函数被压在了最下面， 直到最后才出栈</p>
<p>当我们递归书写不规范时， 就会撑爆函数的执行栈， 也就是<code>爆栈</code></p>
<h2 id="微任务与宏任务的区别"><a href="#微任务与宏任务的区别" class="headerlink" title="微任务与宏任务的区别"></a>微任务与宏任务的区别</h2><p>我们可以把事件处理机制想象成银行柜台的柜员， 柜员每次只能处理接待一个客户， 就和JS一样是单线程的， 每一次的事件循环就是一个来办理业务的客户， 这个客户就是宏任务， </p>
<p>当前的客户结束之后， 柜员叫号，继续接待下一个客户， 也就是开始下一个宏任务</p>
<p>能进入任务队列的都是已完成的异步操作， 当你注册了异步事件，但还未完成， 就好比你取了排队的票子， 但是人离开了，有可能先去吃饭，有可能先去逛街， 于是当轮到你的号码时， 银行柜员会先跳过你， 当你回来时， 你依旧需要重新排队</p>
<p>在宏任务期间， 可以追加微任务的， 或者说微任务是可以插队的，  就像在柜台办理业务中， 一位大爷在办完自己的本来的业务后，  柜员通常都会问还有什么需要办理的业务， 这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 </p>
<p>所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。<br>也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？<br>无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。</p>
<p>所以<br><strong>在当前的微任务没有执行完成时，是不会执行下一个宏任务的</strong></p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>不管是微任务还是宏任务， 都是异步任务， 当他们的事件处理完成后， 最终都是要归回到同步事件队列处理的， 也就是主进程， </p>
<p>既然是主进程，主进程又要负责浏览器的渲染， 那这三者之间的优先级是什么呢</p>
<p>因为微任务实际上是宏任务的其中一个步骤， 也就是下一次的宏任务到来之前必然得先执行完当前的宏任务的微任务, 所以可以这么看:</p>
<blockquote>
<p>浏览器渲染 &gt; 微任务 &gt; 宏任务</p>
</blockquote>
<p>微任务会插队， 插入每一次的执行栈末尾， 宏任务比较可怜， 只要存在微任务，就会被插队，顺序就会往后</p>
<hr>
<p>看下图， 我们可以理解微任务和微任务分别维护着一个队列， 微任务的箭头指向靠前， 表示微任务会优先于宏任务加入事件队列，  宏任务会延迟加入</p>
<p>理论上UI渲染的优先级是比较高的， 但实际上如果你的微任务或宏任务之内， 出现了死循环或大量计算的情况， UI渲染就会被阻塞住， 无法进行，也就是页面卡死状态， 毕竟js单线程</p>
<p><img src="http://img.nixiaolei.com/2019-03-29-22-31-43.png" alt="事件关系"></p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。<em>（检查还有没有微任务需要处理）</em><br>而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。<em>（结束本次宏任务、检查还有没有宏任务需要处理）</em><br>这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。<em>(这是个非常简易的描述了，实际上会复杂很多)</em></p>
<p>而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：</p>
<h3 id="宏任务例子"><a href="#宏任务例子" class="headerlink" title="宏任务例子"></a>宏任务例子</h3><table>
<thead>
<tr>
<th>API</th>
<th style="text-align:center">浏览器</th>
<th style="text-align:center">Node</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>setTimeout</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>setInterval</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>setImmediate</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>requestAnimationFrame</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">❌</td>
</tr>
</tbody>
</table>
<p>I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。</p>
<p>有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML规范文档</a>以后，发现这很显然是和微任务平行的一个操作步骤 </p>
<p>requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN</a>的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行</p>
<h3 id="微任务例子"><a href="#微任务例子" class="headerlink" title="微任务例子"></a>微任务例子</h3><table>
<thead>
<tr>
<th>API</th>
<th style="text-align:center">浏览器</th>
<th style="text-align:center">Node</th>
</tr>
</thead>
<tbody>
<tr>
<td>process.nextTick</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>MutationObserver</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td>Promise.then catch finally</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td>MessageChannel 消息队列</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="浏览器中的情况"><a href="#浏览器中的情况" class="headerlink" title="浏览器中的情况"></a>浏览器中的情况</h2><p>在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？<br>首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）</p>
<p>I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。</p>
<p>假设有这样的一些DOM结构：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#outer</span> &#123;</span></span><br><span class="line"><span class="undefined">    padding: 20px;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#616161</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#inner</span> &#123;</span></span><br><span class="line"><span class="undefined">    width: 100px;</span></span><br><span class="line"><span class="undefined">    height: 100px;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#757575</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $inner = <span class="built_in">document</span>.querySelector(<span class="string">'#inner'</span>)</span><br><span class="line"><span class="keyword">const</span> $outer = <span class="built_in">document</span>.querySelector(<span class="string">'#outer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>) <span class="comment">// 直接输出</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'promise'</span>)) <span class="comment">// 注册微任务</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)) <span class="comment">// 注册宏任务</span></span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'animationFrame'</span>)) <span class="comment">// 注册宏任务</span></span><br><span class="line"></span><br><span class="line">  $outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random()) <span class="comment">// DOM属性修改，触发微任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observer'</span>)</span><br><span class="line">&#125;).observe($outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$inner.addEventListener(<span class="string">'click'</span>, handler)</span><br><span class="line">$outer.addEventListener(<span class="string">'click'</span>, handler)</span><br></pre></td></tr></table></figure>
<p>如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。</p>
<p>因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。<br>按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。<br>因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(<em>一次在inner、一次在outer</em>)，所以会优先执行冒泡的事件(<em>早于其他的宏任务</em>)，也就是说会重复上述的逻辑。<br>在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。<br>需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。</p>
<h2 id="Node-Js中的情况"><a href="#Node-Js中的情况" class="headerlink" title="Node Js中的情况"></a>Node Js中的情况</h2><p>Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">Node官方文档</a>的地址。</p>
<p>就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。</p>
<h3 id="几个特殊的API"><a href="#几个特殊的API" class="headerlink" title="几个特殊的API"></a>几个特殊的API</h3><ol>
<li>SetTimeout和SetInterval 线程池不参与</li>
<li>process.nextTick() 实现类似SetTimeout(function(){},0);每次调用放入队列中，在下一轮循环中取出。</li>
<li>setImmediate();比process.nextTick()优先级低</li>
</ol>
<p>来看看这段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这道题目的答案是 463512</p>
<p>这里有几个注意点， 第一就是 nextTick ，它的优先级比 promise.then 要高， 如下图， 它加入队列的方式属于插队行为, 它直接加入到了当前执行栈（同步队列）与 下一次的等待执行栈之间</p>
<p><img src="http://img.nixiaolei.com/2019-03-29-22-45-02.png" alt="nextTick"></p>
<p>我们都知道 then 比 setTimeout 优先级高</p>
<p>然后就是 setTimeout 和 setImmediate 的问题了，</p>
<p>setImmediate与setTimeout的区别，在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。</p>
<p>但是在实际使用中， 当setTimeout 设置为0时， 他们都是放在队列最后,  所以执行顺序就是谁先写就先执行谁了， 但当setTimeout 设置的时间大于0 时（最低延迟会被忽略）， 情况就不一样了， setTmmediate 会先被执行</p>
<p><img src="http://img.nixiaolei.com/2019-03-29-22-45-25.png" alt="setImmediate"></p>
<p>参考文献(原文写的不错， 所以我大部分是复制，方便之后自己回顾理解)</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000016022069" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016022069</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【NodeJs】异步IO与EventLoop</title>
    <url>/2019/03/26/%E3%80%90NodeJs%E3%80%91%E5%BC%82%E6%AD%A5IO%E4%B8%8EEventLoop/</url>
    <content><![CDATA[<p>IO密集型就是需要频繁请求的程序，高访问量，  CPU密集型就是需要进行大量计算的 </p>
<h2 id="异步IO的好处"><a href="#异步IO的好处" class="headerlink" title="异步IO的好处"></a>异步IO的好处</h2><ul>
<li>前端通过异步IO可以消除UI堵塞。</li>
<li>假设请求资源A的时间为M,请求资源B的时间为N.那么同步的请求耗时为M+N.如果采用异步方式占用时间为Max(M,N)。</li>
<li>随着业务的复杂，会引入分布式系统，时间会线性的增加，M+N+…和Max(M,N…)，这会放大同步和异步之间的差异。</li>
<li>I/O是昂贵的，分布式I/O是更昂贵的。<ul>
<li>分布式因为你读取到了这个值， 但并没有在你这台机器上， 远程的机器想要读取到那就必须要走网络， 这个过程就变长了</li>
</ul>
</li>
<li>NodeJS 适用于IO密集型不适用CPU密集型</li>
</ul>
<h2 id="Node对异步IO的实现"><a href="#Node对异步IO的实现" class="headerlink" title="Node对异步IO的实现"></a>Node对异步IO的实现</h2><blockquote>
<p>完美的异步IO应该是应该是应用程序发起非阻塞调用，无需通过遍历或者事件幻想等方式轮询。</p>
</blockquote>
<p>Node.js 的事件循环和在浏览器中的实现不太一样， 在Node.js 中事件循环交给了Libuv托管，  Libuv 和 v8 是分别独立的线程， 辅助Node.js 进行事件轮询</p>
<p>Node.js 依靠v8运行javascript, 并且绑定了底层的操作系统</p>
<p>当V8接收到用户的请求进入， 通过绑定系统接口，将事件交给Libuv处理， Libuv 将事件加入事件队列( event queue)， EventLoop 不行的旋转并执行同步事件，当遇到异步事件时，将其交给 worker Threads 线程， 比如操作文件就是交给工作线程去同步完成， 当文件操作完毕后， 根据文件描述符去获取数据， 然后将结果作为参数返回给事件队列中等候的回调函数</p>
<p><img src="http://img.nixiaolei.com/2019-03-29-22-50-40.png" alt="EventLoop"></p>
<h2 id="常用的Node控制异步技术手段"><a href="#常用的Node控制异步技术手段" class="headerlink" title="常用的Node控制异步技术手段"></a>常用的Node控制异步技术手段</h2><blockquote>
<p>Promise 是一个语法， 规范， js只是实现了这个规范，  Promise 是一个高级接口， 创建一次，不容易修改， then就是 低级接口， 可以一直then ,处理逻辑</p>
</blockquote>
<ol>
<li>Step、wind（提供等待的异步库）、Bigpipe、Q.js</li>
<li>Async、Await</li>
<li>Promise/Defferred 是一种先执行异步调用，延迟传递的处理方式。Promise是高级接口，事件是低级接口。低级接口可以构建更多复杂的场景，高级接口一旦定义，不太容易变化，不再有低级接口的灵活性，但对于解决问题非常有效</li>
<li>由于Node基于V8的原因，目前还不支持协程。协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</li>
</ol>
<h2 id="底层的知识"><a href="#底层的知识" class="headerlink" title="底层的知识"></a>底层的知识</h2><ol>
<li>CPU时钟周期：1/cpu主频 -&gt; 1s/3.1 GHz<br><img src="http://img.nixiaolei.com/2019-03-29-22-54-03.png" alt="底层知识"></li>
</ol>
<ol start="3">
<li>操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理。应用程序如果需要进行IO需要打开文件描述符，在进行文件和数据的读写。异步IO不带数据直接返回，要获取数据还需要通过文件描述符再次读取。</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-03-29-22-54-36.png" alt="文件操作"></p>
]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>【架构】简单理解微服务架构</title>
    <url>/2019/03/26/%E3%80%90%E6%9E%B6%E6%9E%84%E3%80%91%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><img src="http://img.nixiaolei.com/2019-04-06-16-21-09.png" alt="微服务"></p>
<h2 id="1-1-单体应用与微服务"><a href="#1-1-单体应用与微服务" class="headerlink" title="1.1 单体应用与微服务"></a>1.1 单体应用与微服务</h2><blockquote>
<p>微服务对应的是传统架构， 传统的软件架构是把所有都打在一个包里面， 也就是单体应用。</p>
</blockquote>
<p>单体应用在部署上和后期管理维护上会愈来愈越庞大和难以管理， 而且约束开发成员使用的技术栈， <code>JAVA</code>的程序必须使用<code>JAVA</code>, 但是可能团队里有的擅长<code>PHP</code>，有的擅长<code>Go</code>。 针对这些问题就有人提出了微服务的概念， 可以让适合的语言干适合的事情。</p>
<p>单体应用想要增加服务器只能把整个项目都丢到一台新的服务器上，但每个模块对并发的要求不一样， 比如产品服务模块是需求较多的，压力比较大， 但是订单模块需求就比较少，你也无法拆开，   而微服务不一样， 可以单独对<code>产品服务</code> 这个需求比较大的微服务进行增加服务器， 并且在功能升级时可以实现部分升级， 让用户感觉不到什么异样。</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-17-25-10.png" alt="单体应用与微服务"></p>
<h2 id="2-1-微服务到底是什么"><a href="#2-1-微服务到底是什么" class="headerlink" title="2.1 微服务到底是什么"></a>2.1 微服务到底是什么</h2><blockquote>
<p>微服务只是业务层面上的架构， 技术层面的架构属于你选用某框架</p>
</blockquote>
<ul>
<li>✅微服务属于架构层面的设计模式【结构层面的设计模式】</li>
<li>✅微服务的设计概念以<strong>业务功能为主</strong></li>
<li>✅微服务独立提供对应的业务功能</li>
<li>✅微服务不拘泥于具体的实现语言</li>
<li>✅微服务架构 ≈ 模块化开发 + 分布式计算</li>
</ul>
<h3 id="2-1-易于扩展的分布式"><a href="#2-1-易于扩展的分布式" class="headerlink" title="2.1 易于扩展的分布式"></a>2.1 易于扩展的分布式</h3><p>微服务的架构不管是横向扩展还是纵向扩展都比较的友好</p>
<h4 id="2-1-1-横向扩展"><a href="#2-1-1-横向扩展" class="headerlink" title="2.1.1 横向扩展"></a>2.1.1 横向扩展</h4><p>针对业务进行扩展， 当需要新增业务时只需要增加一个微服务即可</p>
<h4 id="2-1-2-纵向扩展"><a href="#2-1-2-纵向扩展" class="headerlink" title="2.1.2 纵向扩展"></a>2.1.2 纵向扩展</h4><p>纵向扩展是对计算压力上的扩展， 针对某一块增加服务器，增强其计算能力， 然后使用<code>Nginx</code>进行反向代理</p>
<h2 id="3-1-微服务的特点"><a href="#3-1-微服务的特点" class="headerlink" title="3.1 微服务的特点"></a>3.1 微服务的特点</h2><ul>
<li>小, 且专注于做⼀件事情</li>
<li>处于独立的进程中</li>
<li>轻量级的通信机制</li>
<li>松耦合、独立部署</li>
</ul>
<h2 id="4-1-合理使用微服务"><a href="#4-1-合理使用微服务" class="headerlink" title="4.1 合理使用微服务"></a>4.1 合理使用微服务</h2><p>微服务不是灵丹妙药，并不能适应所有的情况。 微服务需要在范围内被合理的使用。</p>
<ul>
<li>业务复杂度高</li>
<li>团队规模大</li>
<li>业务需要长期演进</li>
<li>最后——没有银弹【人月神话】</li>
</ul>
<h2 id="5-1-微服务——集成与部署"><a href="#5-1-微服务——集成与部署" class="headerlink" title="5.1 微服务——集成与部署"></a>5.1 微服务——集成与部署</h2><ul>
<li>持续集成——jekins</li>
<li>虚拟化——虚拟机</li>
<li>容器——Docker</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript语法</title>
    <url>/2019/03/24/TypeScript%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h2><blockquote>
<p>tsc –init<br>修改<code>outDir</code></p>
</blockquote>
<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><blockquote>
<p>1</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'5515'</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure>
<h2 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h2><blockquote>
<p>元组表示一个已知元素数量和类型的数组，各元素的类型不必相同。<br>1</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:[<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">123</span>, <span class="string">'this is ts'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><blockquote>
<p>用于处理非数值的数据</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Flag &#123; success=<span class="number">1</span>, error=<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> s:Flag=Flag.success</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型:"></a>never 类型:</h2><blockquote>
<p>never类型表示的是那些永不存在的值的类型, 如null, undefind, error</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="literal">undefined</span></span><br><span class="line">a = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="定义-symbol类型"><a href="#定义-symbol类型" class="headerlink" title="定义 symbol类型"></a>定义 symbol类型</h2><blockquote>
<p>symbol类型的值是通过Symbol构造函数创建的。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = Symbol();</span><br></pre></td></tr></table></figure>
<h2 id="容许多个类型"><a href="#容许多个类型" class="headerlink" title="容许多个类型"></a>容许多个类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure>
<h2 id="有返回值类型"><a href="#有返回值类型" class="headerlink" title="有返回值类型"></a>有返回值类型</h2><blockquote>
<p>函数声明</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'32132132'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数表达式</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">132</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无返回值类型"><a href="#无返回值类型" class="headerlink" title="无返回值类型"></a>无返回值类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选参数、-默认参数-、剩余参数"><a href="#可选参数、-默认参数-、剩余参数" class="headerlink" title="可选参数、 默认参数 、剩余参数"></a>可选参数、 默认参数 、剩余参数</h2><blockquote>
<p>默认必传, 带‘?’可传可不传， 必须配置到参数的最后面</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age?:<span class="built_in">number</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> ---- <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认参数<br>写了默认参数就不再需要 ‘?’ 标记</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span>=250</span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> ---- <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>剩余参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="json-属性约束"><a href="#json-属性约束" class="headerlink" title="json 属性约束"></a>json 属性约束</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// json属性约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonCon</span>(<span class="params">label</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(label.labelJson);</span><br><span class="line">&#125;</span><br><span class="line">jsonCon(&#123; labelJson: <span class="string">'你好评'</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote>
<p>因为需要遵循js ， 所以无法像java一样实现重载， 实现的只能是变体， 自己判断typeof</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age?:<span class="built_in">any</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断类型用 typeof</span></span><br><span class="line">  <span class="keyword">if</span>(age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名:<span class="subst">$&#123;name&#125;</span>, 年龄<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`姓名:<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">'吴大龙'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;  <span class="comment">// 属性 ,前面省略了Public 关键词</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;    <span class="comment">// 构造函数  实例化类的时候 触发的方法</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName():<span class="built_in">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name:<span class="built_in">string</span>):<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">new</span> Person(<span class="string">'栗色'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aa.getName())</span><br><span class="line">aa.setName(<span class="string">'吴大龙'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(aa.getName())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用类的 get 和 set</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  <span class="keyword">private</span> _name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name():<span class="built_in">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name:<span class="built_in">string</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'吴大龙'</span>, <span class="number">112</span>)</span><br><span class="line">p.name = <span class="string">'吴强'</span> <span class="comment">// 赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name)  <span class="comment">// 取值</span></span><br></pre></td></tr></table></figure>
<h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><blockquote>
<p>继承自上方类</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Web <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w=<span class="keyword">new</span> Web(<span class="string">'往'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(w.run())</span><br></pre></td></tr></table></figure>
<h2 id="类修饰符"><a href="#类修饰符" class="headerlink" title="类修饰符"></a>类修饰符</h2><blockquote>
<p>不加修饰符默认就是 Public  ,  ==外部的意思就是指不被内部函数里被调用, 而是被外部人为调用==<br>public:  共有,  在类的里面, 子类, 类外部都可以访问</p>
</blockquote>
<blockquote>
<p>protected:  保护类型, 在类里面, 子类里面可以访问, 类外部无法访问</p>
</blockquote>
<blockquote>
<p>private:   私有, 在类里可以访问, 子类, 类外部都没法访问</p>
</blockquote>
<h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><blockquote>
<p>static  静态方法, 在没有 new 出实例前都可以调用<br>==但是没法直接调用类里面的属性==</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> nickname:<span class="built_in">string</span>= <span class="string">'吴大龙'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> speak():<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`用户姓名:<span class="subst">$&#123;this.nickname&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.speak()  <span class="comment">// 用户姓名:undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<p>父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现<br>也是继承的一种表现, 子类实现或重写父类中的已有的方法， 这叫多态</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多态</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  eat():<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span>， 在吃屎`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类重新定义 eat方法</span></span><br><span class="line">  eat():<span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">'吃肉'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wuxiaohong = <span class="keyword">new</span> Dog(<span class="string">'吴晓红'</span>)</span><br><span class="line">wuxiaohong.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类重新定义 eat方法</span></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  eat():<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+ <span class="string">'吃粮食'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cc = <span class="keyword">new</span> Cat(<span class="string">'吴强'</span>)</span><br><span class="line">cc.eat()</span><br></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>用abstract关键字定义抽象类和抽象方法， 是提供其他类继承的基类<br>==抽象方法只能放在抽象类里==<br>从抽象类继承的方法必须被子类重写, 重新实现</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal&#123;</span><br><span class="line">  <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">any</span></span>)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'吃粮食'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'小狗'</span>)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>也是一种定义标准. 类似抽象类, 抽象类只能规定方法， 接口可以规定属性， 函数， 索引和类</li>
</ul>
<blockquote>
<p>批量属性接口， 可定义可选参数</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性接口</span></span><br><span class="line"><span class="keyword">interface</span> FullName&#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;   <span class="comment">//封号结束</span></span><br><span class="line">  secondName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span> (<span class="params">name: FullName</span>) : <span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name.firstName +<span class="string">'====&gt;'</span> + name.secondName);</span><br><span class="line">&#125;</span><br><span class="line">printName(&#123;firstName: <span class="string">'吴'</span>, secondName: <span class="string">'大龙'</span>&#125;)  <span class="comment">// 吴====&gt;大龙</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组类型接口<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArray:StringArray;</span><br><span class="line">myArray = [<span class="string">"iwen"</span>, <span class="string">"ime"</span>]</span><br><span class="line">alert(myArray[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>函数类型接口,  对方法传入的参数， 以及返回值进行约束</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如建一个md5加密的接口 的接口</span></span><br><span class="line"><span class="keyword">interface</span> encrypt&#123;</span><br><span class="line">  (key:<span class="built_in">string</span>, value:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5:encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">key:<span class="built_in">string</span>, value:<span class="built_in">string</span></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key + value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(md5(<span class="string">'name'</span>, <span class="string">'吴大龙'</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口扩展， 接口可以继承接口</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">  eat():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承上方接口</span></span><br><span class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  work():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有个类 实现 这个接口</span></span><br><span class="line"><span class="keyword">class</span> Web <span class="keyword">implements</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">  &#125;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'喜欢吃馒头'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  work()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'写代码'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">'小林'</span>)</span><br><span class="line">w.work()  <span class="comment">// 小林写代码</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口多继承  &amp;&amp;  ==创建一个接口对象==<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  多继承 并 创建一个接口对象</span></span><br><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建接口对象不需要 new  而是这样的语法</span></span><br><span class="line"><span class="keyword">var</span> s = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">s.color = <span class="string">"blue"</span></span><br><span class="line">s.penWidth = <span class="number">10</span></span><br><span class="line">s.sideLength = <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>用于创建可重用的组件， 让一个组件支持多种数据类型</li>
<li>==泛型就是解决类 接口 方法的复用性、 以及对不特定数据类型的支持==</li>
</ul>
<blockquote>
<p>基本使用 </p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型 : 可以支持不特定的数据类型   要求： 传入的参数和返回的参数一致</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;    <span class="comment">// T表示泛型</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getData&lt;<span class="built_in">string</span>&gt;(<span class="string">'我是泛型'</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个泛型参数</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> HelloNumber&lt;T, S&gt;&#123;</span><br><span class="line">  Ten:T;</span><br><span class="line">  add:<span class="function">(<span class="params">x:T, y:T</span>) =&gt;</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myHelloNumber = <span class="keyword">new</span> HelloNumber&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">myHelloNumber.Ten = <span class="number">10</span>;</span><br><span class="line">myHelloNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y+<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myHelloNumber.add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lamb 表达式</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lamb 表达式只是表达具体 参数和返回类型, 需要重新赋值上真函数</span></span><br><span class="line"><span class="keyword">var</span> myHello:&lt;K&gt;<span class="function">(<span class="params">arg:K</span>)=&gt;</span> K = &lt;K&gt;(arg:K):<span class="function"><span class="params">K</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line">alert(myHello(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种写法， 对象形式</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myHello:&#123;&lt;T&gt;(arg:T):T&#125; = Hello;</span><br><span class="line">alert(myHello(<span class="string">" Hello"</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型接口</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn&#123;</span><br><span class="line">  &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getData:ConfigFn = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( getData&lt;<span class="built_in">string</span>&gt;(<span class="string">'你好'</span>) )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型小实战 ==需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现==</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型类: 比如有个最小堆算法， 需要同时支持返回数字和字符串两种类型， 通过类的泛型来实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MinClass&lt;T&gt;&#123;</span><br><span class="line">  list:T[]=[]</span><br><span class="line">  add(value:T):<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(value)</span><br><span class="line">  &#125;</span><br><span class="line">  min():T&#123;</span><br><span class="line">    <span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.list.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(minNum &gt; <span class="keyword">this</span>.list[i])&#123;</span><br><span class="line">        minNum=<span class="keyword">this</span>.list[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m1 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">m1.add(<span class="string">'1'</span>)</span><br><span class="line">m1.add(<span class="string">'you'</span>)</span><br><span class="line">m1.add(<span class="string">'love'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m1.min())</span><br></pre></td></tr></table></figure>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在伪元素中使用Iconfont</title>
    <url>/2019/03/24/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E4%BD%BF%E7%94%A8Iconfont/</url>
    <content><![CDATA[<h2 id="把iconfont-中的样式拷到-伪元素上"><a href="#把iconfont-中的样式拷到-伪元素上" class="headerlink" title="把iconfont 中的样式拷到 伪元素上"></a>把iconfont 中的样式拷到 伪元素上</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.iconfont</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">16px</span>;<span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-webkit-text-stroke-width</span>: <span class="number">0.2px</span>;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="砍掉unicode-前面的字符"><a href="#砍掉unicode-前面的字符" class="headerlink" title="砍掉unicode 前面的字符"></a>砍掉unicode 前面的字符</h2><h2 id="如下-即可"><a href="#如下-即可" class="headerlink" title="如下 即可"></a>如下 即可</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'\e60e'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">16px</span>;<span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-webkit-text-stroke-width</span>: <span class="number">0.2px</span>;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>【AOP】面向切面编程</title>
    <url>/2019/03/24/%E3%80%90AOP%E3%80%91%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>Aspect Oriented Programming</p>
</blockquote>
<p>面向切面编程（aop）是对面向对象编程（oop）的补充</p>
<h2 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h2><p>在软件业， AOP为 <code>Aspect Oriented Programming</code> 的缩写， 意为: 面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP的延续， 是软件开发中的一个热点， 也是Spring 框架中的一个重要内容， 是函数式编程的一种衍生范式。 利用AOP可以对业务逻辑的各个部分进行隔离， 从而使得业务逻辑各部分之间的耦合度降低， 提高程序的可重用性， 同时提高了开发效率。</p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>AOP 完善Spring 的依赖注入(DI) 面向对象编程将程序分解成各个层次的对象， 面向切面编程将程序运行过程分解成各个切面。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter(过滤器) 也是一种AOPA， 他利用一种称为“横切”的技术， 刨解开封装的对象内部， 并将那些影响了多个类的公共行为封装到一个可重用的模块， 并将其命名为”Aspect”， 即切面。 所谓“切面”。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>AOP的好处就是你只需要干你的正事， 其他事情别人帮你干。 在你访问数据库之前， 自动帮你开启事务， 当你访问数据库结束之后， 自动帮你提交/回滚事务！</p>
<p>就像函数的<code>before</code>和 <code>after</code></p>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计原则之IOC控制反转</title>
    <url>/2019/03/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BIOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="IOC-（控制反转）"><a href="#IOC-（控制反转）" class="headerlink" title="IOC （控制反转）"></a>IOC （控制反转）</h1><blockquote>
<p>Inversion of Control</p>
</blockquote>
<p>IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚。</p>
<h2 id="什么是控制反转"><a href="#什么是控制反转" class="headerlink" title="什么是控制反转"></a>什么是控制反转</h2><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注⼊到对象中。</p>
<blockquote>
<p>DI是IOC的一种表现形式</p>
</blockquote>
<h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><h3 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h3><p>容器提供回调接口和上下文条件给组件。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>组件不做定位查询， 需提供普通的方法让容器去决定依赖关系。</p>
<h2 id="IOC概念图"><a href="#IOC概念图" class="headerlink" title="IOC概念图"></a>IOC概念图</h2><p>在未使用IOC的时候 各个 <code>Object</code> 之间的耦合度很高， 谁也离不开谁</p>
<p>在使用 IOC 后， 各个 <code>Object</code> 之间通过 <code>IOC容器</code> 整个第三方角色来调度， 变成了可任意组装的模式， 谁需要的时候注入谁，  降低了耦合度</p>
<p><img src="http://img.nixiaolei.com/2019-03-24-13-49-37.png" alt="IOC概念图"></p>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>oop</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title>了解汇编语言</title>
    <url>/2019/03/24/%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<ul>
<li>汇编语言是最贴近底层的计算机语言</li>
<li>汇编语言是直接操作硬件的，没有任何抽象</li>
<li>汇编语言由指令与数据组成，没有任何语句</li>
<li>汇编指令受到硬件平台限制，可移植性很低</li>
<li>了解一些底层语言知识，对理解计算机的运作机制和内存管理大有好处</li>
</ul>
<h2 id="体验一下汇编语言"><a href="#体验一下汇编语言" class="headerlink" title="体验一下汇编语言"></a>体验一下汇编语言</h2><p>来看一下一个简单的汇编语言代码， 这段代码只是为了输出一个”hello world”</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-13-07-06.png" alt="Helloworld"></p>
<p>上面部分也就是程序的数据段:<br><img src="http://img.nixiaolei.com/2019-04-06-13-10-58.png" alt="代码段"></p>
<p>下面这部分是程序的代码段:<br><img src="http://img.nixiaolei.com/2019-04-06-13-11-29.png" alt="数据段"></p>
<p>代码段和数据段是严格分开的， </p>
<p>汇编语言最原始的方式是：当这段代码转换为机器指令后， 数据和代码是相邻在一起的.</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-13-13-58.png" alt="存储结构"></p>
<p>但其实放在一起是不太安全的！</p>
<p>现代计算机的做法是， 将代码段和数据段严格区分开来， 如果越界，在数据段的地方取代码， 操作系统就会给你抛出错误， 也就是经典的<code>蓝屏</code></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计原则之S.O.L.I.D</title>
    <url>/2019/03/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BSOLID/</url>
    <content><![CDATA[<p>作为一名优秀的工程师，最重要的不是招式， 而是内功， 像武侠小说里的高手， 一旦有了几十年的内功， 学什么武功都能快人一步</p>
<p>那编程里如何提升内功， 主要就是体现在编程思想上了，</p>
<h2 id="逐层提升你编程思想"><a href="#逐层提升你编程思想" class="headerlink" title="逐层提升你编程思想"></a>逐层提升你编程思想</h2><p>比如从一开始的最传统的面向对象 到 面向切面</p>
<p>面向对象 -&gt; 工厂模式 -&gt; 面向切面</p>
<p>从 “oop 的静态抽象” 演变为 “aop的动态抽象”</p>
<p><img src="http://img.nixiaolei.com/2019-03-24-09-45-24.png" alt="提升思想"></p>
<h2 id="SOLID原则的基本概念"><a href="#SOLID原则的基本概念" class="headerlink" title="SOLID原则的基本概念"></a>SOLID原则的基本概念</h2><p>让我们来看下 <code>SOLID</code> 的概念</p>
<p>程序设计领域， SOLID (单一一功能、开闭原则、⾥里里⽒氏替换、接⼝口隔离以及依赖反转)是由罗伯特·C·⻢马丁在21世纪早期 引⼊入的记忆术⾸首字⺟母缩略略字，指代了了⾯面向对象编程和⾯面向对象设计的五个基本原则。当这些原则被一一起应⽤用时，它们使得一一个程序员开发一一个容易易进⾏行行软件维护和扩展的系统变得更更加可能SOLID被典型的应⽤用在测试驱动开发上，并且是敏敏捷开发以及⾃自适应软件开发的基本原则的重要组成部分。</p>
<h2 id="SOLID这几个字母代表什么意义？"><a href="#SOLID这几个字母代表什么意义？" class="headerlink" title="SOLID这几个字母代表什么意义？"></a>SOLID这几个字母代表什么意义？</h2><h3 id="S-单一一功能原则"><a href="#S-单一一功能原则" class="headerlink" title="S (单一一功能原则)"></a>S (单一一功能原则)</h3><blockquote>
<p>Single Responsibility Principle </p>
</blockquote>
<p>单一一功能原则 ：单一一功能原则 认为对象应该仅具有一一种单一一功能的概念。<br>换句句话说就是让一一个类只做一一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。<br>在所有的SOLID原则中，这是⼤大多数开发⼈人员感到最能完全理理解的一一条。严格来说，这也可能是违反最频繁的一一条原则了了。<br>单一一责任原则可以看作是低耦合、⾼内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。<br>责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产⽣生影响，<br>从⽽而极⼤大的损伤其内聚性和耦合度。单一一责任，通常意味着单一一的功能，因此不不要为一一个模块实 现过多的功能点，以保证实体只有一一个引起它变化的原因。</p>
<p><strong>缩减一下就是:</strong></p>
<blockquote>
<p>让每个函数和每个类都只做一件小事，职责单一，解耦和</p>
</blockquote>
<h3 id="O-开闭原则"><a href="#O-开闭原则" class="headerlink" title="O (开闭原则)"></a>O (开闭原则)</h3><blockquote>
<p>Open Close Principle</p>
</blockquote>
<p>开闭原则(ocp) 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。<br>软件实体应该是可扩展，而不不可修改的。也就是说，对扩展是开放的，而对修改是封闭的（“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不不应该被修改。也就是说你可以新增功能但不能去修改源码。）。这个原则是诸多面向对象编程原则中最抽象、最难理理解的一个。</p>
<p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独⽴立完成其⼯工作，⽽而不要对类进⾏行行任何修改。可以使用变化和不变来说明：封装不变部分，开放变化部分，一般使用接口继承实现⽅方式来实现“开放”应对变化。</p>
<p>说大白话就是：你不不是要变化吗？，那么我就让你继承实现一个对象，用一个接口来抽象你的职责，你变化越多，继承实现的子类就越多。</p>
<p>让我们来看下一个简单的 <code>Ts</code> demo</p>
<p><strong>糟糕的实现</strong><br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.name == <span class="string">'小猫'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'吃猫粮'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="keyword">this</span>.name == <span class="string">"小狗"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'吃狗粮'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种糟糕的实现不但使程序的可扩展性降低， 而且每次新增一种动物都需要修改之前的代码， 容易造成隐患， 这和编程思想极大的违背</p>
<p><strong>利用 <code>OCP</code> 思想</strong><br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Animal 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> eat(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Animal抽象类</span></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'吃狗粮'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">'小狗'</span>)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中， 首先使用<code>abstract</code> 定义抽象类和抽象方法，提供其他类继承的基类<br>我们定义只要是<code>Animal</code>就必须要有<code>eat</code>方法</p>
<p>于是， 我们创建了一个<code>Dog</code> 继承<code>Animal</code> ,<br>这个<code>Dog</code>就不一般了， 它规定了必须重新实现 <code>eat</code> 方法， 并且可以扩展自己的方法</p>
<p>当我们将来如果需要一只 <code>Cat</code><br>我们一样只需要让他继承<code>Animal</code>抽象类， 然后实现一个自己的<code>eat</code>方法</p>
<h3 id="L-里⽒氏替换原则"><a href="#L-里⽒氏替换原则" class="headerlink" title="L (里⽒氏替换原则)"></a>L (里⽒氏替换原则)</h3><blockquote>
<p>Liskov Substitution Principle</p>
</blockquote>
<p>里氏替换原则: 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下提前被它的子类所替换的”的概念。</p>
<p><strong>子类必须能够替换他们的基类</strong>。即： 子类应该可以替换任何基类能够出现的地方， 并且经过替换以后， 代码还能正常工作。 另外， 不应该在代码中出现<code>if/else</code>之类对子类类型进行判断的条件。 里氏替换原则<code>LSP</code>使使代码符合开闭原则的一个重要保证。 正是由于子类的替换性才使得父类型的模块在无需修改的情况下就可以扩展。在很多情况下， 在设计初期我们类之间的关系不是很明确， <code>LSP</code>则给了我们一个判断和设计类之间关系的基准: 需不需要继承， 以及怎样设计继承关系。</p>
<p>当一个子类的实例应该能够替换任何其超类的实例时， 它们之间才具有is-A关系。 继承对于OCP， 就相当于多态性对于里氏替换原则。子类可以代替基类， 客户使用基类， 他们不需要知道派生类所做的事情。这是一个针对行为职责可替代的原则， 如果S是T的子类型， 那么S对象就应该在不改变任何抽象属性情况下替换所有T对象。</p>
<p><strong>缩减一下就是:</strong></p>
<blockquote>
<p>老爸能干的事， 儿子必须都能干， 并且还要干的能多， 只要有儿子在， 老爸不在现场都没关系</p>
</blockquote>
<h3 id="I-接⼝隔离原则"><a href="#I-接⼝隔离原则" class="headerlink" title="I (接⼝隔离原则)"></a>I (接⼝隔离原则)</h3><blockquote>
<p>Interface Segregation Principle</p>
</blockquote>
<p>接口隔离原则: 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</p>
<p>不能强迫用户去依赖那些他们不能使用的接口。 换句话说， <strong>使用多个专门的接口比使用单一的总接口总要好(JavaScript几乎没有接口的概念， 所以使用ts)。</strong> 注意： 在代码中应用 <code>ISP</code> 并不一定意味着服务就是绝对安全的。 仍然需要采用良好的编码实践， 以确保正确的验证与授权。</p>
<p>这个原则起源于施乐公司， 他们需要建立了一个新的打印机系统， 可以执行诸如装订的印刷品一套，传真多种任务。此系统软件创建从底层开始编制， 并实现了这些任务功能， 但是不断增长的软件功能却使软件本身越来越难适应变化和维护。 每一次改变，即使是最小的变化， 有人可能需要近一个小时的重新编译和重新部署。这几乎不可能再继续发展， 所以他们聘请罗伯特(Robert)帮助他们。他们首先设计了一个主要类Job,几乎能够用于实现所有任务功能。 只要调用Job类的一个方法就可以实现一个功能， Job类就变动非常大， 是一个胖模型啊， 对于客户端如果只需要一个打印功能， 但是其他无关打印的方法功能也和其耦合， <code>ISP</code>原则建议在客户端和Job类之间增加一个接口层， 对于不同功能有不同的接口， 比如打印功能就是Print接口， 然后将大的Job类切分为继承不同接口的子类， 这样有一个Print Job类 等等。</p>
<p><strong>缩减一下就是:</strong></p>
<blockquote>
<p>每一个业务都要准备一个接口， 每个不同功能的接口再继承自公共的基础接口</p>
</blockquote>
<h3 id="D-依赖反转原则"><a href="#D-依赖反转原则" class="headerlink" title="D (依赖反转原则)"></a>D (依赖反转原则)</h3><blockquote>
<p>Dependency Inversion Principle</p>
</blockquote>
<p>依赖倒置原则（Dependency Inversion Principle， DIP）规定： 代码应当取决于抽象概念， 而不是具体实现。</p>
<p><strong>高层模块不应该依赖于底层模块， 二者都应该依赖于抽象</strong><br><strong>抽象不应该依赖于细节， 细节应该依赖于抽象(总结解耦)</strong></p>
<p>类可能依赖于其他类来执行其工作， 但是， 他们不应当依赖于该类的特定具体实现， 而应当是它的抽象。 这个原则实在是太重要了， 社会的分工化， 标准化都是这个设计原则的体现。显然， 这一概念会大大提高系统的灵活性。 如果类只是关心他们支持特定锲约而不是特定类型的组件， 就可以快速而轻松地修改这些低级服务的功能， 同时最大限度地降低对系统其余部分地影响。</p>
<p><strong>举个例子:</strong></p>
<p>你家里需要洗衣机， 不可能把整个洗衣机的生产流程都给实现了， 搬到自己家里， 当然时去超市商场购买一台洗衣机。 你需要电饭煲，也不可能把电饭煲地生产工艺实现了， 也是去商场买现成地。</p>
<p>此时商场就是一个容器， 商场帮我们去各个工厂采购这些商品，  当我们需要某件物品时就可以去商场购买现成地商品</p>
<h4 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h4><p><strong>依赖注入</strong></p>
<p>当某个⻆角⾊色要另一个角色协助时，通常由调用者来创建被调用者的实例。现在创建实例由容器来完成然后注⼊调用者。</p>
<p><strong>注⼊入过程</strong></p>
<p>如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注⼊</p>
<p><strong>依赖反转有两种方式</strong></p>
<ol>
<li>设值注入（在类上方设置字段）</li>
<li>构造注入 （在<code>constructor</code>中接收需要地参数）</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-03-24-13-25-50.png" alt="依赖反转原则"></p>
<h4 id="DI（依赖注⼊入）"><a href="#DI（依赖注⼊入）" class="headerlink" title="DI（依赖注⼊入）"></a>DI（依赖注⼊入）</h4><blockquote>
<p>依赖注⼊入（Dependency Injection）</p>
</blockquote>
<p>为一个方法应该遵从“依赖于抽象而不是一个实例” 的概念。依赖注⼊是该原则的一种实现⽅方式。</p>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>oop</tag>
        <tag>编程原则</tag>
      </tags>
  </entry>
  <entry>
    <title>【C语言】入门知识</title>
    <url>/2019/03/23/%E3%80%90C%E8%AF%AD%E8%A8%80%E3%80%91%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="http://img.nixiaolei.com/2019-04-04-22-39-41.png" alt="C语言"><br>C语言的诞生要比JavaScript早很多, 属于低级语言，比较擅长和系统交互写底层应用。</p>
<p>C语言的编译工具就是gcc</p>
<h2 id="🤯前端不限端"><a href="#🤯前端不限端" class="headerlink" title="🤯前端不限端"></a>🤯前端不限端</h2><p>作为一名优质的前端切图仔， 不应该把自己困死在前端中， 更应该多开阔视野， 朝较底层的方向探索</p>
<p>当然， 这只是鸡汤， 我们来看看前端学习C语言的必要性</p>
<ul>
<li>编译开源软件的源代码</li>
<li>C语言基本语法，要看得懂代码</li>
<li>指针和C语言的坑</li>
<li>从内存层面理解数据结构</li>
<li>搞懂V8的内存管理机制</li>
<li>分析webkit引擎代码</li>
<li>用C语言编写Node.js和PHP扩展模块</li>
</ul>
<h2 id="C语言沉浮录"><a href="#C语言沉浮录" class="headerlink" title="C语言沉浮录"></a>C语言沉浮录</h2><p>C语言的前身是B语言</p>
<ul>
<li>天生的系统级语言</li>
<li>最早用来编写Unix内核</li>
<li>曾经最流行的语言</li>
<li>至今仍在不断发展</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-06-13-46-58.png" alt="语言发展史"></p>
<h2 id="C语言和JavaScript的异同"><a href="#C语言和JavaScript的异同" class="headerlink" title="C语言和JavaScript的异同"></a>C语言和JavaScript的异同</h2><ul>
<li>C语言是编译型语言</li>
<li>C语言要借助编译器转换成可执行程序</li>
<li>JavaScript是解释型语言</li>
<li>JavaScript要借助解释引擎运行</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-06-13-58-53.png" alt="语言编译过程"></p>
<p>需要编译的语言经过编译后生成目标程序， 其实生成目标程序时已经是机器指令了， 但是计算机仍旧无法直接运行它，因为操作系统有他自己的规则， 想要符合操作系统的规则， 这时候就要走链接， 那链接做了哪些事让操作系统能够识别到该程序呢：</p>
<ol>
<li>给操作系统一个识别块，操作系统先读识别块再运行程序</li>
<li>把生成的很多<code>.obj</code>文件串起来， 连成一块</li>
</ol>
<h2 id="C语言与C-语言的区别"><a href="#C语言与C-语言的区别" class="headerlink" title="C语言与C++语言的区别"></a>C语言与C++语言的区别</h2><ol>
<li>C++是新的编程语言，并不是C的扩展</li>
<li>C语言是面向过程的，C＋＋是面向对象的</li>
<li>C和C++语言都有标准库【standard.io】</li>
<li>目前C大多用在网络相关和嵌入式等方面【不管Python、还是JS，底层都需要C语言基本环境】</li>
<li>目前C++大多用在复杂引擎和应用软件方面</li>
</ol>
<h2 id="理解内存与指针"><a href="#理解内存与指针" class="headerlink" title="理解内存与指针"></a>理解内存与指针</h2><ul>
<li>内存与内存地址</li>
<li>指针、地址与引用</li>
<li>指向变量的指针</li>
<li>指向指针的指针</li>
<li>指向函数的指针</li>
<li>动态内存分配</li>
</ul>
<p>要理解内存和指针首先我们应该知道内存在计算机中是什么样子的， 我们可以把内存看作是一个打了很多格子的小纸条，<strong>每个格子就是内存的基本存储单位</strong>, 1个单位是一个字节，也就是一个<code>byte</code>, 而一个<code>byte</code>等于8个<code>bit</code>，那我们该如何找到对应的内存呢， 实际上内存是有编号的，这个编号从0开始， 作为内存的地址（门牌）</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-14-38-20.png" alt="内存地址"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote>
<p>指针其实也是可以运算的，但大多数情况没有意义，  一般用在计算存储空间</p>
</blockquote>
<p>容纳内存地址的变量就是指针</p>
<p>C语言中， 指针也是有类型的， 因为不同的数据类型对应内存中的所占的大小不一样， 定义类型是为了从内存中拿出正确长度的数据， 比如： 短整型只占两个字节、 长整型占4个字节、  超长整型占8个字节、单精度浮点型占6个字节、 双精度浮点型占8个字节</p>
<p>如果不正确定义指针的类型，就会导致从内存中拿出来的长度是错的， 也就是导致得到的值是错的</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-15-09-10.png" alt="理解指针"></p>
<h4 id="🕵️‍一级指针结构"><a href="#🕵️‍一级指针结构" class="headerlink" title="🕵️‍一级指针结构"></a>🕵️‍一级指针结构</h4><p><img src="http://img.nixiaolei.com/2019-04-06-15-13-36.png" alt="一级指针结构"></p>
<h4 id="🕵️‍二级指针结构"><a href="#🕵️‍二级指针结构" class="headerlink" title="🕵️‍二级指针结构"></a>🕵️‍二级指针结构</h4><p><img src="http://img.nixiaolei.com/2019-04-06-15-14-35.png" alt="二级指针结构"></p>
<h4 id="🤒声明指针"><a href="#🤒声明指针" class="headerlink" title="🤒声明指针"></a>🤒声明指针</h4><blockquote>
<p>一开始声明的指针我们只能给他一个Null或是 内存地址, 因为一个具体的值对于指针是没有意义的，</p>
</blockquote>
<p>声明一个整型的指针<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量， 会自动分配内存</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向变量a的指针</span></span><br><span class="line"><span class="keyword">int</span> * p_a = &amp;a;</span><br></pre></td></tr></table></figure></p>
<h4 id="🧐直接寻址和间接寻址"><a href="#🧐直接寻址和间接寻址" class="headerlink" title="🧐直接寻址和间接寻址"></a>🧐直接寻址和间接寻址</h4><p>直接使用变量和利用指针访问的结构是一样的<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(a);  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">printf</span>( *p );  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<h4 id="🤒二级指针及多级指针"><a href="#🤒二级指针及多级指针" class="headerlink" title="🤒二级指针及多级指针"></a>🤒二级指针及多级指针</h4><blockquote>
<p>不管是几级指针编译器都是能够通过的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量， 会自动分配内存</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向变量a的指针</span></span><br><span class="line"><span class="keyword">int</span> * p_a = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个指向指针的指针</span></span><br><span class="line"><span class="keyword">int</span> ** pp_a = &amp;p_a;</span><br></pre></td></tr></table></figure>
<h4 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h4><blockquote>
<p>函数它本身也在内存当中, 当我们看到一个指向函数的指针时就代表着函数调用， 回调函数就是基于指针的</p>
</blockquote>
<p>C语言的函数是有原型的</p>
<p>声明一个两数相加函数的原型<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数返回类型及参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>实现函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建指向函数的指针<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>*(<span class="keyword">int</span>, <span class="keyword">int</span>) p_func;</span><br><span class="line">p_func = add;</span><br></pre></td></tr></table></figure></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是对指针的封装， 现代语言不允许你直接去操作地址  因为现代语言都自带着垃圾回收机制， 在垃圾回收的过程中， 地址会经常改变，  改变地址的目的是为了提高内存的利用效率， 使内存连续</p>
<h2 id="内存动态分配"><a href="#内存动态分配" class="headerlink" title="内存动态分配"></a>内存动态分配</h2><p>C语言主要分如下四个区</p>
<table>
<thead>
<tr>
<th style="text-align:center">内存</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">特性 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">栈区</td>
<td style="text-align:center">是一个确定的常数(1~2M) 不同平台会有不同大小，超出会提示stackoverflow</td>
<td style="text-align:center">自动分配, 自动释放</td>
</tr>
<tr>
<td style="text-align:center">堆区</td>
<td style="text-align:center">用于动态内存分配</td>
<td style="text-align:center">手动分配和释放 ， 可占用80%内存</td>
</tr>
<tr>
<td style="text-align:center">全局区或静态区</td>
<td style="text-align:center">在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）</td>
<td style="text-align:center">只初始化一次 </td>
</tr>
<tr>
<td style="text-align:center">程序代码区</td>
<td style="text-align:center">代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</td>
<td style="text-align:center">代码区的指令中包括操作码和要操作的对象（或对象地址引用）</td>
</tr>
</tbody>
</table>
<ul>
<li>栈区： 还用来保存当前函数的局部变量</li>
<li>堆区： 存放new出来的变量</li>
<li>全局区或静态区: 存放全局变量及对象的静态变量</li>
<li>程序代码区:  存放指令、代码， 以前的金山游侠修改器就是专门改程序代码区的</li>
</ul>
<h3 id="分配内存代码"><a href="#分配内存代码" class="headerlink" title="分配内存代码"></a>分配内存代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t 表示一个无符号整型</span></span><br><span class="line"><span class="comment">// p = malloc( size_t );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给整型分配空间必须 传入整型长度的倍数（ 整型长度是 4个字节）</span></span><br><span class="line"><span class="comment">// 这样我就申请了40个字节的内存空间， 它能容纳10个整型的数字</span></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上 malloc 申请到的是一个数组， 下面这样是对前4个字节进行赋值</span></span><br><span class="line">*p = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 实际等价于</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你要给其他位置的字节赋值, 这样表示向后移动一个元素单位的位置</span></span><br><span class="line">*(p+<span class="number">1</span>) = <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">p[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】理解权限命令-chown</title>
    <url>/2019/03/22/%E3%80%90Linux%E3%80%91%E7%90%86%E8%A7%A3chown%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更改文件属组</span></span><br><span class="line">chgrp [-R] 属组名  文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改文件属主 或 属组</span></span><br><span class="line">chown [-R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件权限 9 个属性</span></span><br><span class="line"><span class="comment"># 有两种设置方式， 一种是数字 一种是符号</span></span><br><span class="line"><span class="comment"># 基本身份 owner/group/others 的各自三种权限</span></span><br><span class="line"><span class="comment"># read(r 4)/write(w 2)/execute(x 1): -rwxr-xr-- = [4+2+1][4+0+1][4+0+0]=754</span></span><br><span class="line">chmod [-R] xyz 文件或目录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 符号修改权限</span></span><br><span class="line">chmod u(user)        +(加入)    r 文件或目录</span><br><span class="line">      g(group)       -(减去)    w </span><br><span class="line">      o(others)      =(设定)    x</span><br><span class="line">      a(all 全部身份)      </span><br><span class="line"></span><br><span class="line">chmod u=rwx,g=rx, o=r 文件名</span><br><span class="line">chmod a-x test1</span><br></pre></td></tr></table></figure>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="http://img.nixiaolei.com/2019-04-02-20-47-10.png" alt="chmod命令"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合</title>
    <url>/2019/03/20/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一:"></a>题目一:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"done"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 微任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>答案:</strong></p>
<blockquote>
<p>1 , 2 , 5 , 4, 6</p>
</blockquote>
<p>注意， 没有<code>done</code>！</p>
<p><strong>分析:</strong><br><code>Promise</code> 的<code>resolve</code>只会触发一次， 因为<code>Promise</code>的状态已经被修改为<code>resolve</code></p>
<p>所以第二次的<code>resolve</code> 不会触发</p>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二:"></a>题目二:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">"done"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"aa"</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    resolve(<span class="number">8</span>)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>答案:</strong></p>
<blockquote>
<p>1, 7, 2, 8 , 5 , 4 , aa</p>
</blockquote>
<p><strong>分析:</strong><br><code>Promise</code>的完成先后还得看谁先挂载了 <code>then</code>， 并不是谁先<code>new</code>就是谁</p>
<h2 id="ES6系列"><a href="#ES6系列" class="headerlink" title="ES6系列"></a>ES6系列</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await:"></a>async await:</h3><h4 id="题目一-async-什么原理"><a href="#题目一-async-什么原理" class="headerlink" title="题目一: async 什么原理 ?"></a>题目一: async 什么原理 ?</h4><p><strong>例子:</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>  <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="number">10</span> </span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p>
<p>经过 Babel 转换<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (_context.prev = _context.next) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      _context.next = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result = _context.sent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">      <span class="keyword">return</span> _context.stop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>我们可以看到，经过<code>babel</code> 转换过的 <code>async await</code> 代码中关键的这句， <code>while</code>循环， 并且是一个死循环， <code>babel</code> 就是这样来模拟 <code>async await</code>的， 当<code>await</code>返回结果时， <code>_context.stop</code>抛出异常退出死循环 , <code>babel</code>这样做也是为了更好的捕获异常</p>
<h4 id="题目二-请问result输出几"><a href="#题目二-请问result输出几" class="headerlink" title="题目二: 请问result输出几 ?"></a>题目二: 请问result输出几 ?</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>  <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">a = a + <span class="number">1</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p><strong>答案:</strong></p>
<blockquote>
<p>10  , 11</p>
</blockquote>
<p><strong>分析:</strong></p>
<ol>
<li><code>await</code> 后如果是一个常量, 将作为 <code>Promise.resolve</code>的结果返回</li>
<li>因为 <code>async await</code> 是 <code>generator</code>的语法糖， 当执行 <code>test</code> 方法时， 变量<code>a</code>的值会被锁住</li>
</ol>
<p>所以第一个结果是<code>10</code>， 第二个结果是 <code>11</code></p>
<h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><h4 id="题目一-请用-ES5实现ES6-Promise-A-规范的代码，-用时你能解释下如何使用Promise完成事务的操作吗"><a href="#题目一-请用-ES5实现ES6-Promise-A-规范的代码，-用时你能解释下如何使用Promise完成事务的操作吗" class="headerlink" title="题目一: 请用 ES5实现ES6 Promise A+规范的代码， 用时你能解释下如何使用Promise完成事务的操作吗"></a>题目一: 请用 ES5实现ES6 Promise A+规范的代码， 用时你能解释下如何使用Promise完成事务的操作吗</h4>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript手册</title>
    <url>/2019/03/18/TypeScript%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>TypeScript是JavaScript的超集</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><blockquote>
<p>我的环境: window10 + vscode</p>
</blockquote>
<p>全局安装Ts</p>
<blockquote>
<p>npm i -g typescript</p>
</blockquote>
<p>生成并配置<code>tsconfig.json</code></p>
<blockquote>
<p>tsc –init</p>
</blockquote>
<p>配置文件， 下面的配置中<code>ts</code>应存放在<code>src</code> 目录下， 并且会自动编译到dist文件夹下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es2017"</span>,                         <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                       <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,                 <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>,              <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,             <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,       <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                             <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                      <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                       <span class="comment">// 以严格模式检查没个模块，并在没个文件里加入 'use strict'</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">false</span>,                            <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                     <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                      <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,                   <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"lib"</span>: [<span class="string">"es2017"</span>],                          <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [<span class="string">"node_modules/@types"</span>],</span><br><span class="line">    <span class="string">"types"</span>: [</span><br><span class="line">      <span class="string">"node"</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./dist"</span>,                        <span class="comment">// 编译后文件产出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./src"</span>                          <span class="comment">// 你的ts文件目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"include"</span>: [                                 <span class="comment">// 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题</span></span><br><span class="line">    <span class="string">"./src/*.ts"</span>,</span><br><span class="line">    <span class="string">"./src/**/*.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"node_modules"</span>,</span><br><span class="line">    <span class="string">"dist"</span>,</span><br><span class="line">    <span class="string">"**/*.test.ts"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速生成<code>package.json</code></p>
<blockquote>
<p>npm init -y</p>
</blockquote>
<p>运行命令， 开始监听</p>
<blockquote>
<p>tsc -w</p>
</blockquote>
<p>是否有效呢？ 让我们来试一下</p>
<p>进入src目录新建一个 <code>hello.ts</code>，记得是<code>.ts</code>， 不要写习惯了打成<code>.js</code>😅</p>
<p>随便写点东西， 比如定义一个字符串类型:<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="built_in">string</span> = <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>如果你配置没有问题的话， 我们就会看到他监听文件修改并编译</p>
<p>这是ts文件与 编译后的js文件</p>
<p><img src="http://img.nixiaolei.com/2019-03-18-22-50-51.png" alt="编译前后"></p>
<p>并且在他运行过程中， 我们可以按<code>F5</code>进行调试</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Array</li>
<li>Enum</li>
<li>Any</li>
<li>Void</li>
</ul>
<p>简单的几种数据的定义<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Boolean</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 定义一个Number</span></span><br><span class="line"><span class="keyword">var</span> a:<span class="built_in">number</span> = <span class="number">13</span></span><br><span class="line"><span class="comment">// 定义一个 String </span></span><br><span class="line"><span class="keyword">var</span> a:<span class="built_in">string</span> = <span class="string">"13"</span></span><br></pre></td></tr></table></figure></p>
<p>基本的数据结构定义<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list:<span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>interfaces</p>
</blockquote>
<h3 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a>基础接口</h3><p>没有接口时我们如何规范参数类型<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">dog:&#123;name:string&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dog.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = &#123; <span class="attr">name</span>: <span class="string">"Hello"</span> &#125;</span><br><span class="line">fn(myObj)</span><br></pre></td></tr></table></figure></p>
<p>有了接口， 我们就可以把参数规定与函数分离</p>
<p>如何创建接口</p>
<p>通过 <code>interface</code> 关键字来声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface dogValue &#123;</span><br><span class="line">  name:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定参数`dog`是接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">dog: dogValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dog.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = &#123; <span class="attr">name</span>: <span class="string">"Hello"</span> &#125;</span><br><span class="line">fn(myObj)  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<h3 id="接口的可选属性"><a href="#接口的可选属性" class="headerlink" title="接口的可选属性"></a>接口的可选属性</h3><p>接口定义的参数不一定每一个都会被用到</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>什么是泛型?</p>
<p>泛型: 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型</p>
<p>一句话理解就是：  参数化类型（把类型当作是参数一样传递）</p>
<p>使用泛型的好处:</p>
<ul>
<li>代码更加简洁【不用强制转换】</li>
<li>程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】</li>
<li>可读性和稳定性【在编写集合的时候，就限定了类型】</li>
</ul>
<p>指定一个最简单的泛型<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h2><p>Module 模式是常见的JavaScript模式之一， 在ES6的模块话实现之前， 人们通常通过 IFEE 来实现Module</p>
<p>Module 的好处</p>
<ol>
<li>模块化</li>
<li>可重用</li>
<li>封装变量和函数</li>
</ol>
<p>来看看在ES6之前是如何书写的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somtiong</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>让我们来看一个例子， 使用 TS 的 Module 来防止调用多种 interface 时的麻烦</p>
<p>使用Module之前<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  <span class="comment">// 接口定义的方法</span></span><br><span class="line">  isAcceptable(s:<span class="built_in">string</span>):<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$]/</span>;</span><br><span class="line"><span class="keyword">var</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"><span class="comment">// 实现接口的方法</span></span><br><span class="line"><span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s:<span class="built_in">string</span>):<span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lettersRegexp.test(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s:<span class="built_in">string</span>):<span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用了Module 的书写方式后</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Validation &#123;</span><br><span class="line">  <span class="comment">// 需要使用 export 来表示对外暴露</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$]/</span>;</span><br><span class="line">  <span class="keyword">var</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s:<span class="built_in">string</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lettersRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s:<span class="built_in">string</span>):<span class="built_in">boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Module 与 类相结合使用<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Person &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Student &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    study() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在学习'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'在说话'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 使用时 -------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Person.Student(<span class="string">'小明'</span>)</span><br><span class="line">xiaoming.study()</span><br></pre></td></tr></table></figure></p>
<h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p>Namespaces 的和Module 的用法相同，  在Ts 的1.5 版本后， 用 Namespaces 取代了 Module </p>
<p>查看一下官方的示例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123; &#125;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Square &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square(); <span class="comment">// Same as 'new Shapes.Polygons.Square()'</span></span><br></pre></td></tr></table></figure>
<h2 id="装饰器-lt-Decorators-gt"><a href="#装饰器-lt-Decorators-gt" class="headerlink" title="装饰器 &lt; Decorators &gt;"></a>装饰器 &lt; Decorators &gt;</h2><p>如何定义一个装饰器</p>
<p>其实装饰器就是一个普通的函数， 他接收一个参数<code>target</code> ，这个参数就是被装饰对象， 看下面的例子， <code>sealed</code> 装饰了<code>Dog</code>类， 并且在<code>sealed</code> 中打印了 <code>target</code> ， 让我们看看 <code>target</code>到底是什么？<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">target:<span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with 'target' ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(target)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被装饰的对象 foo</span></span><br><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果<br><img src="http://img.nixiaolei.com/2019-03-22-22-06-26.png" alt="使用装饰器"></p>
<p>我们可以看到， 得到的正是 <code>Dog</code>这个类</p>
<h3 id="装饰器工厂-lt-Decorator-Factories-gt"><a href="#装饰器工厂-lt-Decorator-Factories-gt" class="headerlink" title="装饰器工厂&lt; Decorator Factories &gt;"></a>装饰器工厂&lt; Decorator Factories &gt;</h3><blockquote>
<p>如果希望自定义如何将装饰器应用于声明，可以编写装饰器工厂。装饰器工厂只是一个函数，它返回将在运行时由装饰器调用的表达式。</p>
</blockquote>
<p>装饰器工厂和普通装饰器相比的好处就是更加的自定义了， 可以根据不同情况自定义效果</p>
<p>如何定义一个<code>装饰器工厂</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">value:<span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span></span>)  </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="built_in">console</span>.log(target)    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里使用并传入自定义的参数</span></span><br><span class="line"><span class="meta">@dec</span>(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">class</span> Cat &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来看看运行的结果</p>
<p><img src="http://img.nixiaolei.com/2019-03-22-22-22-55.png" alt="定义装饰器工厂"></p>
<p>可以看到，我们传入的<code>test</code>字符串和 <code>Cat</code>类都被打印出来了，</p>
<h3 id="多装饰器的执行顺序"><a href="#多装饰器的执行顺序" class="headerlink" title="多装饰器的执行顺序"></a>多装饰器的执行顺序</h3><p>使用多个装饰器时如何书写呢?</p>
<p>当我们使用多个装饰器时有两种写法</p>
<ol>
<li><p>写成一行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f</span> <span class="meta">@g</span> x</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直书写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="meta">@g</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>多个装饰器的执行顺序是如何的呢？</strong></p>
<p>套用官网的说明</p>
<ol>
<li>对每个装饰器的表达式进行自上而下的计算。</li>
<li>然后将结果作为自下而上的函数调用。</li>
</ol>
<p>其实真实的运行原理是<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">f(g(x))</span><br></pre></td></tr></table></figure></p>
<h3 id="访问器修饰器"><a href="#访问器修饰器" class="headerlink" title="访问器修饰器"></a>访问器修饰器</h3><p>访问器修饰器的接收的参数和方法修饰器接收的参数一样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">value:<span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>)  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里使用并传入自定义的参数</span></span><br><span class="line"><span class="meta">@dec</span>(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">class</span> Cat &#123;</span><br><span class="line">  <span class="keyword">private</span> _x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> _y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._x = x</span><br><span class="line">    <span class="keyword">this</span>._y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 访问器修饰器</span></span><br><span class="line">  <span class="meta">@dec</span>(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">get</span>  x() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._x &#125;</span><br><span class="line">  <span class="meta">@dec</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span>  y() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性修饰器"><a href="#属性修饰器" class="headerlink" title="属性修饰器"></a>属性修饰器</h3><p>属性修饰器只有前两个参数<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">value:<span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>)  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里使用并传入自定义的参数</span></span><br><span class="line"><span class="meta">@dec</span>(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">class</span> Cat &#123;</span><br><span class="line">  <span class="keyword">private</span> _x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> _y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 属性修饰器</span></span><br><span class="line">    <span class="meta">@dec</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">this</span>._x = x</span><br><span class="line">    <span class="keyword">this</span>._y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数修饰器"><a href="#参数修饰器" class="headerlink" title="参数修饰器"></a>参数修饰器</h3><p>参数修饰器也是三个参数， 但不同的是第三个参数接收</p>
<p><strong>参数装饰器只能确认一个方法的参数是否被传入</strong></p>
<p>前两个和其他的修饰器都相同， </p>
<ol>
<li>target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象</li>
<li>propertyKey 成员的名称</li>
<li>参数在所处函数的参数列表中的索引， 说人话就是告诉你他是第几个参数</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">value:<span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>)  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里使用并传入自定义的参数</span></span><br><span class="line"><span class="meta">@dec</span>(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">class</span> Cat &#123;</span><br><span class="line">  run(<span class="meta">@require</span>(<span class="literal">true</span>) name:<span class="built_in">string</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰器参数"><a href="#装饰器参数" class="headerlink" title="装饰器参数"></a>装饰器参数</h3><ol>
<li>类装饰器</li>
</ol>
<p>类装饰器的参数只接收一个， 那就是<code>target</code> 也就是这个类本身</p>
<p>就和上面演示的那些例子一样</p>
<ol start="2">
<li>方法装饰器</li>
</ol>
<p>一般会传入三个参数</p>
<ol>
<li>target 对于静态成员是类的构造函数， 而对于实例成员是类的实例对象</li>
<li>propertyKey 成员的名称</li>
<li>descriptor 成员属性的描述符</li>
</ol>
<p>我们来验证下方法装饰器的参数</p>
<p>让我们看看这段例子会输出什么<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">value:<span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>)  </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(target)    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Tiger &#123;</span><br><span class="line">  <span class="meta">@f</span>(<span class="string">'tiger run'</span>)</span><br><span class="line">  run() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输入结果: </p>
<p><img src="http://img.nixiaolei.com/2019-03-23-11-35-28.png" alt="方法装饰器参数"></p>
<p>在控制台输出， 我们看到了，<br>第一个参数是 <code>tiger</code> 的实例对象（因为<code>run</code>是实例成员）</p>
<p>第二个参数是成员名称， 也就是被装饰的<code>run</code></p>
<p>第三个参数是 <code>run</code> 的属性描述符</p>
<h2 id="Mixins-混入"><a href="#Mixins-混入" class="headerlink" title="Mixins 混入"></a>Mixins 混入</h2><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在Scala等语言里对mixins及其特性已经很熟悉了，但它在JavaScript中也是很流行的。</p>
<p>Mixins 其实可以拆分为两个单词</p>
<p>Mix : 混合</p>
<p>ins : 是进入</p>
<p>所以合在一起就是叫 <code>混入</code> 的意思的单词</p>
<p>它想要表达的是一个对象中混入另一个对象的方法</p>
<p><strong>让我们来实现一下Mixins</strong></p>
<p>代码里首先定义两个类，它们将做为mixins。 可以看到每个类都只定义了一个特定的行为或功能。 稍后我们使用它们来创建一个新类，同时具有这两种功能。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Disposable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Disposable &#123;</span><br><span class="line">    isDisposed: <span class="built_in">boolean</span>;</span><br><span class="line">    dispose() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isDisposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activatable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Activatable &#123;</span><br><span class="line">    isActive: <span class="built_in">boolean</span>;</span><br><span class="line">    activate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deactivate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个类，结合了这两个mixins。 下面来看一下具体是怎么操作的：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> SmartObject <span class="keyword">implements</span> Disposable, Activatable &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们没有使用extends而是使用implements。 把类当成了接口，仅使用Disposable和Activatable的类型而非其实现。 这意味着我们需要在类里面实现接口。 但是这是我们在用mixin时想避免的。</p>
<p>我们可以这么做来达到目的，为将要mixin进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用mixin带来的便利，虽说需要提前定义一些占位属性。</p>
<p>也就是这样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SmartObject <span class="keyword">implements</span> Disposable, Activatable &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.isActive + <span class="string">" : "</span> + <span class="keyword">this</span>.isDisposed), <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interact() &#123;</span><br><span class="line">      <span class="keyword">this</span>.activate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disposable</span></span><br><span class="line">  isDisposed: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  dispose: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// Activatable</span></span><br><span class="line">  isActive: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  activate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  deactivate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，把mixins混入定义的类，完成全部实现部分。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">applyMixins(SmartObject, [Disposable, Activatable]);</span><br></pre></td></tr></table></figure></p>
<p>我们同时也需要创建这个帮助函数， 帮我们做混入操作。 它会遍历mixins上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">derivedCtor: <span class="built_in">any</span>, baseCtors: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  baseCtors.forEach(<span class="function"><span class="params">baseCtor</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">          derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://segmentfault.com/a/1190000016305647" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016305647</a></li>
</ul>
<p>————————-待完善—————————-</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的Css矩阵</title>
    <url>/2019/03/18/%E3%80%90CSS%E7%9F%A9%E9%98%B5%E3%80%91%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Css%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><ol>
<li>matrix(a,b,c,d,e,f);        </li>
<li>a c e 分别和 X, Y, 1 相乘得出线性方程</li>
<li>b d f 分别和 X, Y, 1 相乘得出线性方程</li>
</ol>
<p>这是很清楚的计算公式</p>
<p><img src="http://img.nixiaolei.com/matrix.png" alt></p>
<h2 id="rotateZ矩阵推理"><a href="#rotateZ矩阵推理" class="headerlink" title="rotateZ矩阵推理"></a>rotateZ矩阵推理</h2><p>推理过程</p>
<p><img src="http://img.nixiaolei.com/note.png" alt></p>
<h2 id="参考同学的笔记"><a href="#参考同学的笔记" class="headerlink" title="参考同学的笔记"></a>参考同学的笔记</h2><p>同学写的很不错👍</p>
<p><img src="http://img.nixiaolei.com/classmate-note01.png" alt></p>
<p><img src="http://img.nixiaolei.com/classmate-note02.png" alt></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSS全景】淘宝造物节H5原理</title>
    <url>/2019/03/18/%E3%80%90CSS%E5%85%A8%E6%99%AF%E3%80%91%E6%B7%98%E5%AE%9D%E9%80%A0%E7%89%A9%E8%8A%82H5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="http://img.nixiaolei.com/zaowu.gif" alt></p>
<p>2016年的淘宝造物节邀请函， 太牛了， 不过，我们这回先不研究他的入场特效，先研究下它的全景是如何实现的</p>
<h2 id="一、-载入图片-定位至统一位置"><a href="#一、-载入图片-定位至统一位置" class="headerlink" title="一、 载入图片, 定位至统一位置"></a>一、 载入图片, 定位至统一位置</h2><blockquote>
<p>因为20张图片被定位到统一地方, 所以所有图片都叠在一起了</p>
</blockquote>
<blockquote>
<p>此时效果</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/taobao01.png" alt></p>
<h2 id="二、依照Y轴旋转图片"><a href="#二、依照Y轴旋转图片" class="headerlink" title="二、依照Y轴旋转图片"></a>二、依照Y轴旋转图片</h2><blockquote>
<p>先说下为什么要依照y轴:  我们需要把图片围绕成一个环形, 类似于 木桶的每一块木板,   图片就是木板, 按图片的顺序旋转自各自的角度, 目前也是原地旋转, 所以图片依旧叠加在一起</p>
</blockquote>
<blockquote>
<p>素材有20张图片, 那每张的旋转角度就是 360 / 20 = 18度, 每张旋转的度数在前一张的基础上累加 18 度, </p>
</blockquote>
<blockquote>
<p>这里注意注意注意: 因为是按图片中心的Y轴旋转, 所以同一个度数会有两张图片,  比如: 0度的图片, 头在0度, 尾在90度,    然后当轮到头在90度的图片时, 他的尾在 0 度, 所以会有同一个度数两张图片的现象</p>
</blockquote>
<blockquote>
<p>此时效果</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/taobao02.png" alt></p>
<blockquote>
<p>为了方便理解, 切换成上帝视角, ,  所有图片围绕中心点旋转</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/taobao03.png" alt></p>
<p><img src="http://img.nixiaolei.com/taobao04.png" alt></p>
<h2 id="三、将图片沿着各自Z轴向外推"><a href="#三、将图片沿着各自Z轴向外推" class="headerlink" title="三、将图片沿着各自Z轴向外推"></a>三、将图片沿着各自Z轴向外推</h2><blockquote>
<p>现在木板(也就是每一张图片)是穿插在一起的, 我们需要让他们远离中心点, 拉开距离, 让他,们边缘连接而不是这样交叉在一起,  才能形成一个圆</p>
</blockquote>
<h3 id="先了解每一块木板怎么推"><a href="#先了解每一块木板怎么推" class="headerlink" title="先了解每一块木板怎么推"></a>先了解每一块木板怎么推</h3><blockquote>
<p>简单的画了个前后的效果图,  用的是上帝视角, 也就是你低头看一个木桶的视角</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/taobao05.png" alt></p>
<h3 id="如何计算该推多少距离"><a href="#如何计算该推多少距离" class="headerlink" title="如何计算该推多少距离"></a>如何计算该推多少距离</h3><blockquote>
<p>做一道三角函数数学题</p>
<p>画的角度不太对别介意</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/taobao06.png" alt></p>
<blockquote>
<p>设一共12条线,  每条长200px(此时的长就对应图片的宽) ,  求将橙线移动到图中最终位置的距离 “黑线”,<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先求旋转度数</span></span><br><span class="line"><span class="comment">// 然后取度数的一半</span></span><br><span class="line"><span class="number">360</span> / <span class="number">12</span> / <span class="number">2</span> = <span class="number">15</span> 度</span><br><span class="line"><span class="comment">// 得知直角底边长度</span></span><br><span class="line"><span class="number">200</span> / <span class="number">2</span> = <span class="number">100</span>px</span><br><span class="line"><span class="comment">// 根据度数得知 tan, 顺便说下, tan是对边比邻边</span></span><br><span class="line">tan15°= <span class="number">0.26794</span></span><br><span class="line"><span class="comment">// 求出黑线</span></span><br><span class="line"><span class="number">100</span>PX / 黑线 = <span class="number">0.26794</span></span><br><span class="line">黑线约等于 <span class="number">373.2</span>px</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="js计算时注意"><a href="#js计算时注意" class="headerlink" title="js计算时注意"></a>js计算时注意</h2><ol>
<li>Math.tan 接收的是弧度单位</li>
<li>Math.PI 表示的是一个 Π</li>
<li>360度 = 2Π <blockquote>
<p>计算出每张图片之间的形成的弧度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 假设图片数量是 8 张</span></span><br><span class="line"><span class="comment">// 因为 360 = 2Π</span></span><br><span class="line"><span class="comment">// 1度 = Π / 180</span></span><br><span class="line"><span class="comment">// 每份的角度是</span></span><br><span class="line"><span class="keyword">const</span> deg = <span class="number">360</span> / <span class="number">8</span> <span class="comment">// 此时为 45</span></span><br><span class="line"><span class="comment">// 一份的弧度就是 每份弧度 * 旋转角度的一半</span></span><br><span class="line"><span class="comment">// 最后结果就等于 Π / 图片数量</span></span><br><span class="line">( <span class="built_in">Math</span>.PI / <span class="number">180</span> ) * ( <span class="number">45</span> / <span class="number">2</span> )  ==&gt;  <span class="built_in">Math</span>.PI / <span class="number">8</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<div style="display: none;"><br>谢谢最可爱的贝玺<br></div>















]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机语言的本源与发展</title>
    <url>/2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%AC%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<ul>
<li>本源：二进制数据</li>
<li>第一代语言：机器指令 （痛苦指数 ✮✮✮✮✮）</li>
<li>第二代语言：汇编指令（痛苦指数 ✮✮✮✮✩）</li>
<li>第三代语言：高级语言（主要特征：面向过程）</li>
<li>第四代语言：面向对象语言（面向互联网、天然支持数据库）</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-06-13-46-58.png" alt="语言发展史"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】源码解析</title>
    <url>/2019/03/18/%E3%80%90Vue%E3%80%91%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>现在三大框架风起云涌， <code>JQuery</code>老大哥的光辉不再， 使前端成为了各路诸侯的兵家必争之地， </p>
<p>当然作为一名优质的前端，光跟风学框架是肯定不行的， 要知其然而知其所以然</p>
<p>要了解<code>MVVM</code>的本质原理， <code>virtual Dom</code>和 <code>Diff</code>算法解决的问题</p>
<p>拒绝盲目跟风</p>
<h2 id="🍎diffDom优劣"><a href="#🍎diffDom优劣" class="headerlink" title="🍎diffDom优劣"></a>🍎diffDom优劣</h2><p>现在很多人都说 <code>Vue</code>, <code>React</code> 多牛， <code>Diff</code>算法快，不用操作<code>Dom</code>。</p>
<p>其实不然。</p>
<p><code>Diff</code>算法不是不需要操作<code>Dom</code>,  而是不需要开发者去操作<code>Dom</code>了， <code>Diff</code>算法其实不快， 就算使用了<code>virtual Dom</code>,  还得花实现把真实<code>Dom</code> 转换为 <code>virtual Dom</code> 再去比对， 这远远没有<code>js</code>直接 <code>getElementById</code>直达目标来的快</p>
<p>那Diff算法不快为什么还要用呢?</p>
<p><code>Diff</code>算法其实是给那些比较随意的新手开发者准备的</p>
<p>看这个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原本的dom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到结果不管三七二十一把旧dom全替换了</span></span><br><span class="line">$.<span class="keyword">get</span>('/api', (res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> _HTML = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; res.length; i++)&#123;</span><br><span class="line">    _HTML = <span class="string">"&lt;li&gt;"</span> + res[i] +<span class="string">"&lt;/li&gt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">"#ul"</span>).html(_HTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果是原始的<code>Dom</code>操作， 有很多小白会像这个例子一样， 不管<code>Dom</code>需不需要更新， 他都把<code>ajax</code>返回的请求全部跑一边，生成<code>HTML</code>模板， 然后把原本的所有<code>li</code>都删了，  再把新的模板放进去， <code>Dom</code>少还看不出来， 如果<code>Dom</code>多了呢， 上千的<code>Dom</code>， 这顿操作一下就玩炸了。</p>
<p>况且网站优化原则就是尽量减小<code>Dom</code>操作， 如果是有经验的开发者， 会选择找到有变化的位置，使用<code>append</code>插入</p>
<h2 id="📄Vue架构目录"><a href="#📄Vue架构目录" class="headerlink" title="📄Vue架构目录"></a>📄Vue架构目录</h2><p>去<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue官网</a>下载<code>Vue</code>源码看看，</p>
<p>打开里面会有一个 <code>src</code>目录， 里面就是整个的<code>Vue</code>源码</p>
<p>目前有6个目录， 作用分别如下</p>
<p><img src="http://img.nixiaolei.com/2019-03-30-10-44-35.png" alt="Vue目录"></p>
<p><code>Vue.js</code> 的组成是由 <code>core</code> + 对应的 ‘平台’ 补充代码构成（独立构建和运行时构建只是 <code>platforms</code> 下 <code>web</code> 平台的两种选择）</p>
<p><code>Vue</code>的核心原理就在<code>core</code>文件夹中， 让我们进入 <code>core</code> 文件夹看看</p>
<p><img src="http://img.nixiaolei.com/2019-03-30-10-57-26.png" alt="core文件夹"></p>
<p>了解了目录，接下来我们就来研究<code>Vue</code>的双向绑定</p>
<h2 id="🔗双向绑定（响应式原理）-所涉及到的技术"><a href="#🔗双向绑定（响应式原理）-所涉及到的技术" class="headerlink" title="🔗双向绑定（响应式原理） 所涉及到的技术"></a>🔗双向绑定（响应式原理） 所涉及到的技术</h2><ul>
<li>✅ <strong>Obejct.defineProperty</strong> <em>【提供getter 和 setter】</em></li>
<li>✅ <strong>Observer</strong> <em>【提供getter 和 setter】</em></li>
<li>✅ <strong>watcher</strong>  <em>【提供getter 和 setter】</em></li>
<li>✅ <strong>Dep</strong> <em>【负责收集watcher】</em></li>
<li>✅ <strong>Directive</strong> <em>【处理Vue模板指令】</em></li>
</ul>
<h3 id="Obejct-defineProperty"><a href="#Obejct-defineProperty" class="headerlink" title="Obejct.defineProperty"></a>Obejct.defineProperty</h3><p><code>Obejct.defineProperty</code> 是整个<code>Vue</code>的灵魂， </p>
<p>来看一下<code>Obejct.defineProperty</code> 如何使用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getter'</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter'</span>)</span><br><span class="line">    c = newVal</span><br><span class="line">    <span class="keyword">this</span>.a = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">'234'</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 234</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 234</span></span><br></pre></td></tr></table></figure></p>
<p>它帮助<code>Vue</code>实现了双向绑定, 但也因为这个， <code>Vue</code>也只能舍弃了对低版本浏览器的支持。</p>
<p><img src="http://img.nixiaolei.com/2019-03-30-11-48-41.png" alt="defineProperty兼容"></p>
<p>它只能兼容到<code>IE9</code> ， 并且市面上的<code>polyfill</code>实现的也并不是很好</p>
<p>那低版本如何代替<code>Obejct.defineProperty</code> ， 难道真没了它就不行吗？</p>
<p><strong>当然有</strong>：</p>
<ol>
<li>👆 &gt; IE 7</li>
</ol>
<p>实际上在<code>IE7</code>的时候就已经有暴露了 <code>__defineGetter__</code> 方法，<br><img src="http://img.nixiaolei.com/2019-03-30-12-57-56.png" alt="__defineGetter__"></p>
<p>具体用法如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> random = &#123;&#125;;</span><br><span class="line">random.__defineGetter__(<span class="string">'ten'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>); &#125;);</span><br><span class="line">random.__defineGetter__(<span class="string">'hundred'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>); &#125;);</span><br><span class="line"></span><br><span class="line">random.ten <span class="comment">// 随机的一个值</span></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>👇 &lt; IE 7</li>
</ol>
<p>早年间的<code>IE</code> 是支持<code>VBScript</code>,  <a href="http://www.w3school.com.cn/vbscript/index.asp" target="_blank" rel="noopener">VBScript</a> 就可以直接写类， 并且也支持<code>get</code>，<code>set</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> name () &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🐶霸道的IE"><a href="#🐶霸道的IE" class="headerlink" title="🐶霸道的IE"></a>🐶霸道的IE</h3><p>说了这么多<code>IE</code>的坏， 这里也带一嘴<code>IE</code>的好，</p>
<p><code>IE</code>能够调用<code>EXE</code>程序, 比如<code>JS</code>无法设置打印机的宽高，就可以利用<code>ActiveObjectX</code>来做到, 甚至可以修改<code>word</code>格式等等  , 所以办公类的项目离不开<code>IE</code></p>
<h2 id="😕MVVM-双向数据绑定流程"><a href="#😕MVVM-双向数据绑定流程" class="headerlink" title="😕MVVM 双向数据绑定流程"></a>😕MVVM 双向数据绑定流程</h2><p>MVVM: Model–view–viewmodel</p>
<p>那怎么区分这些层呢</p>
<ul>
<li>🚀<strong>Model</strong>: <code>Observer</code></li>
<li>✈️<strong>view</strong> : <code>directive</code></li>
<li>🚚<strong>viewmodel</strong>: <code>Watcher</code> &amp;&amp; <code>Dep</code>  <em>【用于连接 Model 和 view】</em></li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-03-30-11-51-42.png" alt="双向数据绑定"></p>
<p>先看<code>Directive</code>, 这就是我们平时写的<code>vue</code>指令， 如上面举例得的<code>v-text=&quot;times&quot;</code>, 这就是一个指令， 一个<code>Directive</code>会分配一个<code>Watcher</code></p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。订阅者模式涉及三个对象：发布者、主题对象、订阅者，三个对象间的是一对多的关系，每当主题对象状态发生改变时，其相关依赖对象都会得到通知，并被自动更新。</p>
<p>简单的描述就是:</p>
<p>你想买漫画， 但是问了报刊亭的大爷， 大爷说现在没有， 还没到货， 然后你回去了， 第二天你又去问， 大爷还是说没有， 如果你每天这样问， 大爷估计会嫌你烦。 如果这时候你把你的电话给大爷， 大爷记录到他的<strong>本子</strong>上,  当大爷的漫画到货的时候电话通知你。</p>
<p>这时你就是<code>订阅者</code>, 大爷就是<code>发布者</code>, 你们就存在一个发布订阅者的关系</p>
<p><strong>Vue 中的Observer</strong></p>
<p>Observer会观察两种类型的数据，<code>Object</code> 与 <code>Array</code><br>对于<code>Array</code>类型的数据，由于 <code>JavaScript</code> 的限制， <code>Vue</code> 不能检测变化,会先重写操作数组的原型方法，重写后能达到两个目的，</p>
<p>当数组发生变化时，触发 <code>notify</code> 如果是 <code>push</code>，<code>unshift</code>，<code>splice</code> 这些添加新元素的操作，则会使用<code>observer</code>观察新添加的数据重写完原型方法后，遍历拿到数组中的每个数据 使用<code>observer</code>观察它而对于<code>Object</code>类型的数据，则遍历它的每个<code>key</code>，使用 <code>defineProperty</code> 设置 <code>getter</code> 和 <code>setter</code>，当触发<code>getter</code>的时候，<code>observer</code>则开始收集依赖，而触发<code>setter</code>的时候，<code>observer</code>则触发<code>notify</code>。</p>
<h4 id="对-Object-的处理"><a href="#对-Object-的处理" class="headerlink" title="对 Object 的处理"></a>对 Object 的处理</h4><p><code>Observer</code> 对象的标志就是<code>__ob__</code> 这个属性，这个属性保存了 <code>Observer</code> 对象自己本身。对象在转化为 <code>Observer</code> 对象的过程中是一个递归的过程，对象的子元素如果是对象或数组的话，也会转化为 <code>Observer</code> 对象</p>
<h4 id="对数组的处理"><a href="#对数组的处理" class="headerlink" title="对数组的处理"></a>对数组的处理</h4><p>其实 <code>observeArray</code> 方法就是对数组进行遍历，递归调用 <code>observe</code> 方法，最终都会走入 <code>walk</code> 方监控单个元素。而 <code>walk</code> 方法就是遍历对象，结合 defineReactive 方法递归将属性转化为 <code>getter</code> 和 <code>setter</code></p>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p><code>Watcher</code> 是将模板和 <code>Observer</code> 对象结合在一起的纽带。<code>Watcher</code> 是订阅者模式中的订阅者。<code>Watcher</code> 的两个参数： <code>expOrFn</code> 最终会被转换为 <code>getter</code> 函数， cb 是更新时执行的回调。依赖收集的入口就是get函数。</p>
<blockquote>
<p>getter 函数是用来连接监控属性与 <code>Watcher</code> 的关键</p>
</blockquote>
<p>只有通过<code>watcher</code> 触发的getter 会收集依赖，而所谓的被收集的依赖就是当前<code>watcher</code>.初始化时传入的参数 expOrFn 中涉及到的每一项数据，然后触发该数据项的 getter 函数；getter 函数中就是通过判断 Dep.target的有无来判断是 <code>Watcher</code> 初始化时调用的还是普通数据读取，如果有则进行依赖收集</p>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>这个方法是在响应式的过程中调用的，用户修改数据触发 setter 函数，函数的最后一行就是调用 dep.notify 去通知订阅者更新视图。</p>
<h3 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h3><p><img src="http://img.nixiaolei.com/2019-03-30-14-50-38.png" alt="Directive"></p>
<p>关于编译这块vue分了两种类型，一种是文本节点，一种是元素节点</p>
<p>vue内置了这么多的指令，这些指令都会抛出两个接口bind 和 update，这两个接口的作用是，编译的最后一步是执行所有用到的指令的bind方法，而 update 方法则是当watcher 触发 update 时，Directive会触发指令的update方法</p>
<p>observe -&gt; 触发setter -&gt; watcher -&gt; 触发update -&gt; Directive -&gt; 触发update -&gt; 指令</p>
<h2 id="💥源码分析"><a href="#💥源码分析" class="headerlink" title="💥源码分析"></a>💥源码分析</h2><p>Vue的完全版源码有很多判断以及其他的逻辑， 对于观看源码的人，会造成极大的困难，</p>
<p>因此准备了这版仿照Vue流程实现的 实现了双向绑定的<a href="https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue" target="_blank" rel="noopener">简版Vue</a>, 方便学习理解</p>
<p>通过这版对<a href="https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue" target="_blank" rel="noopener">Vue源码的简易翻版</a>， 我们来快速理解Vue原理</p>
<h3 id="✨-new-Vue"><a href="#✨-new-Vue" class="headerlink" title="✨ new Vue"></a>✨ new Vue</h3><p>首先看一下，我们的 new Vue, 这是所有操作的入口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    nickname: <span class="string">'张三'</span>,</span><br><span class="line">    email: <span class="string">"123123@qq.com"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  el: <span class="string">'#app'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>相信使用过<code>Vue</code>的小伙伴都明白， 这里定义了一个<code>data</code>， 用于存放变量， el是目标<code>dom</code>的选择器</p>
<h3 id="🔥-new-Vue-执行时做了什么"><a href="#🔥-new-Vue-执行时做了什么" class="headerlink" title="🔥 new Vue 执行时做了什么"></a>🔥 new Vue 执行时做了什么</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = option.data </span><br><span class="line">  <span class="keyword">this</span>.data = data</span><br><span class="line">  <span class="comment">// 挂载 getter 和 setter</span></span><br><span class="line">  observe(data, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">var</span> id = option.el</span><br><span class="line">  <span class="comment">// 编译 模板</span></span><br><span class="line">  <span class="keyword">var</span> dom = <span class="keyword">new</span> Compile(<span class="built_in">document</span>.querySelector(id), <span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 把编译好的模板挂载到 #app 上</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(id).appendChild(dom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到， Vue其实是一个构造函数， 它接收了一个参数<code>option</code>， 这个<code>option</code>就是我们<code>new Vue</code>传入的那个对象<br>因此我们可以通过<code>option</code> 拿到<code>data</code>和<code>el</code>两个变量， 当然这是js基础哈， 我就不再说了</p>
<p>拿到<code>data</code>后， 我们可以看到它调用了一个 <code>observe</code>方法, 将data和this传入( 此时this时Vue实例 )</p>
<p>接下来又根据<code>el</code>来获取<code>dom</code>， 同样的将获取到的<code>dom</code>和<code>this</code>传入了 <code>Compile</code>中，  并且还接收了一个返回值， 然后又将这个返回值挂到了 <code>#app</code>上</p>
<p>是不是感觉， 什么鬼？, 这顿操作是啥</p>
<p>首先看一下疑惑的 <code>observe</code>， 传入了 <code>data</code>， <code>this</code>, 然后就没动静了， 既然如此， 我们就进入<code>observe</code>看看</p>
<p>找到<code>Observe</code>的构造函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj, vm</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(vm, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它接收一个<code>obj</code>和 <code>vm</code>， 哦， 这里就一一对应上了， 就是我们刚才传入的 <code>data</code>和<code>this</code> </p>
<p>来看看它做了什么， </p>
<p>它把<code>obj</code>枚举了一遍， 并将每一次的  <code>vm</code>, <code>key</code>,<code>value</code> 都传入一个叫 <code>defineReactive</code>的方法</p>
<p>好，那就让来看<code>defineReactive</code>做了什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">vm, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为每个变量分配一个 dep实例</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 配置getter和setter并且挂载到vm上</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> ( Dep.target ) &#123;</span><br><span class="line">        <span class="comment">// JS的浏览器单线程特性， 保证整个全局变量在同一时间内， 只有一个监听器使用</span></span><br><span class="line">        dep.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( newVal == val ) <span class="keyword">return</span>;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 作为发布者发出通知</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到， 它<code>new</code>了一个<code>Dep</code>， 这个<code>Dep</code>就是报刊亭大爷的电话本， 用来收集所有想买报纸或杂志的人的电话， 等到到货时就好挨个通知</p>
<p>然后我们看到了灵魂函数 <code>Object.defineProperty</code>,  </p>
<p>嗷那我们应该就明白了， 这里的一顿操作就是为了给<code>data</code>里的每个属性都挂载上 <code>getter</code>，<code>setter</code>, 并且将这些属性直接转移到了<code>vm</code>上（Vue实例）</p>
<p>那既然如此， </p>
<p>🤪让我们看看 <code>getter</code>方法做了什么， </p>
<p>首先它判断了一下<code>Dep.target</code>，  如果<code>Dep.target</code>为<code>true</code> , 就调用<code>dep</code>的<code>addSub</code>方法， 这里<code>Dep.target</code>是啥我们先不管， 留个印象即可</p>
<p>然后它直接<code>return</code>了<code>val</code></p>
<p>😵再来看看<code>setter</code>方法</p>
<p><code>setter</code>方法接收一个新值，  首先就是判断了新值和原本的值是否相等， 如果相等就不做处理了， 如果不相等， 它将新值赋给<code>val</code></p>
<p>然后调用<code>dep</code>实例上的<code>notify</code>方法， <code>notify</code> 看着名字也知道是通知， 也就是大爷挨个打电话的一个操作</p>
<p>好, 这一块我们理顺了， 是为了挂上<code>getter</code>和<code>setter</code>， 但又遇到了新问题<code>dep</code>， <code>dep</code>到底在干什么， 为什么被<code>getter</code>，<code>setter</code>都使用了 </p>
<p>找到<code>Dep</code>的构造函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放watcher</span></span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  <span class="comment">// 添加watcher, 也就是添加订阅</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通知所有watcher</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到， <code>Dep</code>构造函数中维护了一个 <code>subs</code>数组， 并且下面的在<code>prototype</code>上定义了几个方法， <code>addSub</code> 和<code>notify</code>，<br>这不就是刚刚<code>observe</code>里调用的两个方法吗，<br>哦，明白了， <code>addSub</code>原来是将<code>getter</code>中传入的 <code>Dep.target</code>追加到每个<code>Dep</code>实例都单独维护的一个<code>subs</code>数组中呀， <code>notify</code>就是遍历整个数组，挨个调用<code>update</code>方法（先不管update的具体实现）</p>
<p>好， 解决了<code>observe</code>方法，那我们就回到最初的<code>Vue</code>构造函数中,  继续往下走, 攻克剩余的绿色区域</p>
<p><img src="http://img.nixiaolei.com/2019-03-31-11-36-41.png" alt="Compile"></p>
<p>我们可以看到，它通过<code>el</code> 获取到了<code>dom</code>, 并在<code>new Compile</code> 将<code>dom</code> 传入</p>
<p>那我们就找到<code>Compile</code>的构造函数一探究竟<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">node, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$frag = <span class="keyword">this</span>.nodeToFragment(node, vm)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$frag</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到， 它接收了一个<code>node</code>， 和一个<code>vm</code> , 并且判断了一下<code>node</code>是否存在， </p>
<p>并将<code>node</code>和<code>vm</code>，传入了<code>this.nodeToFragment</code>方法， 又将其的返回结果<code>return</code>出去， 也就是<code>new Compile</code>之后返回的值 ，如下</p>
<p><img src="http://img.nixiaolei.com/2019-03-31-11-49-23.png" alt="Compile02"></p>
<p>那<code>this.nodeToFragment</code>这个方法做了什么， 让我们找到他<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">  nodeToFragment(node, vm) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 创建文档片段</span></span><br><span class="line">    <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">    <span class="keyword">var</span> child;</span><br><span class="line">    <span class="keyword">while</span> ( child = node.firstChild ) &#123;</span><br><span class="line">      <span class="comment">// 替换变量</span></span><br><span class="line">      _this.compileElement(child, vm)</span><br><span class="line">      <span class="comment">// 剪贴子元素</span></span><br><span class="line">      frag.append(child)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frag</span><br><span class="line">  &#125;,</span><br><span class="line">  compileElement(node, vm) &#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="comment">// 节点类型为元素, 根据nodeType来判断</span></span><br><span class="line">    <span class="keyword">if</span> ( node.nodeType === <span class="number">1</span> ) &#123;</span><br><span class="line">      <span class="comment">// 获取自定义属性</span></span><br><span class="line">      <span class="keyword">var</span> attr = node.attributes</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attr[i].nodeName == <span class="string">"v-model"</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取v-model 绑定的属性名</span></span><br><span class="line">          <span class="keyword">var</span> name = attr[i].nodeValue</span><br><span class="line">          <span class="comment">// 双向绑定</span></span><br><span class="line">          node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 给相应的data属性赋值， 进而触发该属性的set方法</span></span><br><span class="line">            <span class="comment">// 再批处理渲染元素</span></span><br><span class="line">            vm[name] = e.target.value </span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 把this ，节点， 还有v-model绑定的变量交给watcher</span></span><br><span class="line">          <span class="keyword">new</span> Watcher(vm, node, name, <span class="string">"value"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类型为text</span></span><br><span class="line">    <span class="keyword">if</span> ( node.nodeType === <span class="number">3</span> ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( reg.test(node.nodeValue) ) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="built_in">RegExp</span>.$<span class="number">1</span>; <span class="comment">// 获取匹配到的字符串</span></span><br><span class="line">        name = name.trim()</span><br><span class="line">         <span class="comment">// 把this ，节点， 还有&#123;&#123; xxx &#125;&#125;中使用的变量交给watcher</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm, node, name, <span class="string">'nodeValue'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到它在<code>Compile</code>原型上挂了<code>nodeToFragment</code>, <code>compileElement</code>两个方法，  <code>nodeToFragment</code>方法接收 <code>node</code>, <code>vm</code>参数</p>
<p>先保存了一下<code>this</code>指向,  然后使用<code>document.createDocumentFragment()</code>方法创建了一个文档片段， 并将在<code>while</code>循环中传入的<code>node</code>节点的第一个元素赋值给 <code>child</code>变量，<br>然后使用<code>compileElement(child, vm)</code> 将<code>child</code>和<code>vm</code> 传入, 然后将<code>child</code> 追加给创建好的文档片段<code>frag</code>, 你肯定会觉得这是个死循环, 其实不是的， 这个<code>append</code>对<code>dom</code>有剪切的效果，<br>所以他会一直抽离<code>node</code>的第一个节点，直至<code>node</code>空了， 吸干他</p>
<p>完成了这顿操作后， 再将<code>frag</code>文档片段返回</p>
<p>然后我们来看看它在<code>while</code>中调用的<code>compileElement</code>方法做了什么</p>
<p>它同样接收<code>node</code>和<code>vm</code> , 首先就是定义一个正则， 这是用来匹配<code></code>双括号的， 也就是我们平时的变量写法</p>
<p>然后它判断了一下这个 <code>node</code>的节点类型,  如果<code>nodeType == 1</code>, 那就说明是元素，  如果<code>nodeType == 3</code> 那就说明节点类型是<code>text</code></p>
<p>如果节点类型是元素， 就利用<code>attributes</code> 方法，获取到该元素身上的属性,  查看是否存在<code>v-model</code>这样一个属性， 如果有，就获取到<code>v-model</code>填写的变量，交给变量<code>name</code>,<br>然后监听该元素的<code>input</code>事件， </p>
<p>所以每当改元素发生<code>input</code>时间时，就将元素上的<code>value</code>根据<code>v-model</code>上获取到的<code>name</code>作为<code>vm</code>的<code>key</code>去修改<code>vm</code>实例上的对应的值， 因为<code>vm</code>上的变量已经被挂载此来触发<code>vm</code></p>
<p>最后还创建了一个<code>Watcher</code>实例,  传入<code>vm, node ,name, &quot;value&quot;</code>这几个参数，</p>
<p><code>Watcher</code>的具体实现我们待会去看</p>
<p>接下来就是判断<code>node.nodeType == 3</code>， 也就是text类型的节点， 如果是此类节点， 就先用正则去匹配一下<code></code>语法， 看看有没有使用到某个变量，<br>如果匹配到了， 则通过<code>RegExp.$1</code>获取到被匹配到的值， 然后去除左右的空格， 交给变量<code>name</code><br>最后，同样的创建了一个<code>Watcher</code>实例,  传入<code>vm, node ,name, &quot;value&quot;</code>这几个参数，</p>
<p>出现两次<code>Watcher</code>， 什么情况， 到底干了啥<br>那， 现在就来让我们看看神秘的<code>Watcher</code>构造函数</p>
<p>找到<code>Watcher</code>的构造函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, node, name, type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 单例， 使用原因未知</span></span><br><span class="line">  Dep.target = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">// 呵呵哒 uid</span></span><br><span class="line">  <span class="keyword">this</span>.id = ++uid;</span><br><span class="line">  <span class="comment">// 与变量相关的Node节点</span></span><br><span class="line">  <span class="keyword">this</span>.node = node;</span><br><span class="line">  <span class="comment">// vm 实例</span></span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="comment">// 变量类型  nodeValue  || value</span></span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="comment">// 触发自己原型上的update方法</span></span><br><span class="line">  <span class="keyword">this</span>.update()</span><br><span class="line">  <span class="comment">// Watcher 实例创建结束就把单例置空</span></span><br><span class="line">  Dep.target = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时我们发现了一个关键的东西<code>Dep.target</code> ， 这个鬼东西原来在这里， 它被赋值为了<code>Watcher</code>的实例， 然后在<code>Watcher</code>实例上挂载了<code>name</code>，也就是用到的变量， 还使用了一个<code>uid</code>， 不过这<code>uid</code>也是呵呵了，用数字作为<code>uid</code>, <code>Vue</code>的真实源码就这么干的， 为每个<code>Watcher</code>都配分一个<code>uid</code>， 这会造成数组空间的不连续， 引发内存泄漏</p>
<p>接着说， 然后他将传入的<code>node</code>节点， <code>vm</code>实例， 还有<code>type</code>( ‘nodeValue’ 和 ‘value’ ), 都挂到了实例上面， 并且还在调用了<code>update</code>方法后， 将<code>Dep.target</code>设为<code>null</code></p>
<p>那我们来看下<code>update</code>做了啥</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span>(!batcher) &#123;</span><br><span class="line">      <span class="comment">// bastcher 单例</span></span><br><span class="line">      batcher = <span class="keyword">new</span> Batcher()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入队列</span></span><br><span class="line">    batcher.push(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取新值挂到自己的实例上</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.name]  <span class="comment">// 触发getter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到<code>update</code>方法， 首先调用了一下<code>get</code>方法， 这个<code>get</code>呢就是根据<code>this.name</code>从 <code>vm</code>实例上取一次值， 并挂到<code>Watcher</code>实例上的<code>value</code>属性上, 并且他还会触发一次<code>getter</code>方法，将自己加入到<code>dep</code>中， 也就是加入到报刊亭大爷的电话本中， 便于之后的通知</p>
<p>然后判断了一下<code>window.batcher</code>是否存在， 如果不存在就创建一个， 保证其是一个单例模式,<br>如果存在， 就将自己(<code>watcher</code>实例)，通过<code>push</code>方法传入</p>
<p>看到这里，又晕了， 什么时候又冒出来一个<code>Batcher</code></p>
<p>我们又找到<code>Batcher</code>的构造函数好好分析下，<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批处理构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Batcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  重置  has  queue waiting</span></span><br><span class="line">  <span class="keyword">this</span>.reset()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Batcher.prototype.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.has = &#123;&#125;</span><br><span class="line">  <span class="keyword">this</span>.queue = []</span><br><span class="line">  <span class="keyword">this</span>.waiting = <span class="literal">false</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将watcher 添加到队列中</span></span><br><span class="line">Batcher.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> id = job.id</span><br><span class="line">  <span class="comment">// 先根据 对象的key 看看是否已经有了这个watcher</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.has[id]) &#123;</span><br><span class="line">    <span class="comment">// console.log(batcher)</span></span><br><span class="line">    <span class="keyword">this</span>.queue.push(job)</span><br><span class="line">    <span class="comment">// 将watcher 的key的设为true</span></span><br><span class="line">    <span class="keyword">this</span>.has[id] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.waiting ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.waiting = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="string">"Promise"</span> <span class="keyword">in</span> <span class="built_in">window</span> ) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.flush()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.flush()</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行并情况事件队列</span></span><br><span class="line">Batcher.prototype.flush = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue.forEach(<span class="function"><span class="params">job</span> =&gt;</span> &#123;</span><br><span class="line">    job.cb()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Batcher</code>的构造函数很简单， 就调用了一下自己的<code>reset</code>方法， 但好像事情远没有这么简单，我们不是在 <code>Watcher</code>的<code>update</code>方法中调用了<code>batcher.push</code>吗， 我也可以在这原型上找的这个方法， 首先它接收一个<code>job</code>参数， 也就是<code>Watcher</code>实例， </p>
<p>获取到该<code>watcher</code>的<code>id</code>, 然后使用这个<code>id</code>,去<code>has</code>这个对象上访问一下， 看看是否存在，<br>如果不存在，在证明之前没有添加进来过， 然后将该<code>watcher</code>实例加到<code>queue</code>队列中，<br>并将<code>has</code>对象中<code>id</code>对应的值设为<code>true</code>, 以防止重复加入队列</p>
<p>并且判断一下<code>waiting</code>，得知当前是否处于等待状态， 如果不是， 就将<code>waiting</code>改为<code>true</code>, 然后就是判断当前浏览器的支持情况， 将处理的任务扔到异步队列中</p>
<p>它这里这么做是为了，只批处理一次， 你一瞬间加入多个<code>watcher</code>, 很容易造成重复执行， 利用<code>Watcher</code>的<code>id</code>来过滤， 并且利用异步， 等你要加的<code>watcher</code>都加完了， 我再给你统一的去执行所有<code>Watcher</code></p>
<p>也就是异步任务结束后调用的<code>flush</code>方法， 它在内部会遍历<code>queue</code>队列， 挨个的调用<code>Watcher</code>的<code>cb</code>方法<br>在这一切都执行完成之后， 又调用了一次<code>reset</code>方法， 将<code>bascher</code>的三个属性重置为初始状态</p>
<p>此时关注点又回到了<code>Watcher</code>身上， 它的<code>cb</code>方法又做了什么<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给dom赋值</span></span><br><span class="line">  cb() &#123;</span><br><span class="line">    <span class="comment">// 最终实际虚拟dom 处理结果， 只处理一次</span></span><br><span class="line">    <span class="comment">// 虚拟dom -&gt; diff( 虚拟dom ) -&gt; 局部更新 -&gt; createElement(vNode) -&gt; render</span></span><br><span class="line">    <span class="keyword">this</span>.node[<span class="keyword">this</span>.type] = <span class="keyword">this</span>.value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>cb</code>方法做的事情很简单那， 就是<strong>根据元素的值类型去修改元素对象的值</strong>， 而这个<code>this.value</code>早在之前调用 <code>Watcher</code>的<code>get</code>方法时就被赋上了</p>
<p>到这里，整个流程就走完了， 相信你还是一头雾水， 我们把整个流程来串一下</p>
<ol>
<li>new Vue</li>
<li>将<code>data</code>中的值挂上 <code>getter</code>和<code>setter</code> 的相应方法， 然后暂且搁置，因为此时还无人调用<code>getter</code>和<code>setter</code></li>
<li>通过 <code>Compile</code>解析模板， 挨个递归<code>#app</code>下的<code>dom</code>, 判断元素类型， 如果是元素，并且使用了<code>v-model</code>， 就绑定一个<code>input</code>事件,  如果是文本类型节点,就去匹配是使用了<code></code>语法， 最后为他们都创建了一个<code>watcher</code></li>
<li>每个<code>watcher</code> 用来保存相关的元素对象， <code>vm</code>实例，使用的<code>变量</code> 以及元素值类型, 并将自己的实例交给， <code>Dep.target</code>， 并触发自己的<code>update</code>方法，<code>update</code>方法又会调用<code>get</code>方法， <code>get</code>方法又会触发该变量的<code>getter</code>， 这也就使得<code>getter</code>中可以将该<code>watcher</code>放入<code>dep</code>实例中， 最后将自己也放入<code>Bacher</code>中，用以批处理以及将<code>Dep.target</code>置空</li>
<li><code>Batcher</code>是个单例， 根据<code>Watcher</code>的<code>id</code>, 它用来过滤重复传入的<code>Watcher</code>, 保证一个<code>Watcher</code>只触发一次, 并将更新事件丢入异步，等当前的连续操作执行完成后去调用<code>Watcher</code>的<code>cb</code>方法更新<code>dom</code></li>
<li>之后用户修改了变量, <code>setter</code>又会调用<code>dep</code>这个发布者来发出通知， 相关的<code>Watcher</code>的<code>update</code>方法再次被调用， 又会加入<code>batcher</code> , <code>batcher</code>等待异步完成后又调用<code>Watcher</code>的<code>cb</code>方法更新<code>dom</code></li>
</ol>
<p><strong>到这里就整个串完了，但是感觉废话还是有点多， 再简化一点流程</strong>:</p>
<p>new Vue –&gt; <code>Observe</code> 挂载 <code>setter</code> 和 <code>getter</code> –&gt;  <code>Compile</code> 编译模板 –&gt; 为每个指令分配一个<code>watcher</code> –&gt; 创建时会调用一次<code>watcher.update</code> 将自己加入到<code>batcher</code>的队列 –&gt;<br>并且此时会触发 <code>getter</code> 将<code>watcher</code>加入<code>dep</code> –&gt;  <code>batcher</code> 统一来处理<code>watcher</code>后初始化自己 –&gt;  当用户修改某个变量时 –&gt; <code>dep</code>通知<code>watcher</code> –&gt; <code>watcher</code>又被加入<code>batcher</code>处理 –&gt; <code>watcher</code> 更新<code>dom</code></p>
<p><code>Vue</code>的<code>batcher</code>还是实现的不是很好， 缺少调度机制， 这点上还是<code>React Fiber</code>更优秀点，<code>Fiber</code>如果遇上了长时间的任务会选择放弃， 避免阻塞进程。</p>
<p>😕好了， 神秘的<code>Vue</code>源码已被揭开面纱， 但这仅仅是简易版的实现， 真实的<code>Vue</code>非常庞大， 还有更多的内容， 这里只是让大家明白<code>MVVM</code>的核心原理</p>
<p>项目源码:</p>
<blockquote>
<p><a href="https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue" target="_blank" rel="noopener">https://github.com/nxl3477/note/tree/master/Javascript/Vue/%E5%AE%9E%E7%8E%B0vue</a></p>
</blockquote>
<p>优质文献: </p>
<ul>
<li><a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="noopener">汤姆大叔的观察者模式</a></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】工具目录</title>
    <url>/2019/03/17/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E5%B7%A5%E5%85%B7%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>这里存放各种可能用到的用不到的东西， 真用到时方便查找😄</p>
<p>当然平日里经常用到的， 耳熟能详的， 我就不放进来了， 主要是起个备忘录的作用</p>
<hr>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="兼容查询"><a href="#兼容查询" class="headerlink" title="兼容查询"></a>兼容查询</h3><ul>
<li><a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a> </li>
<li><a href="https://cssdb.org/" target="_blank" rel="noopener">https://cssdb.org/</a></li>
</ul>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul>
<li>贝塞尔: <a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="noopener">http://cubic-bezier.com/#.17,.67,.83,.67</a></li>
</ul>
<h2 id="可生成matrix的网站"><a href="#可生成matrix的网站" class="headerlink" title="可生成matrix的网站"></a>可生成matrix的网站</h2><table>
<thead>
<tr>
<th>名称</th>
<th>网址</th>
</tr>
</thead>
<tbody>
<tr>
<td>matrix3d</td>
<td><a href="http://ds-overdesign.com/transform/matrix3d.html" target="_blank" rel="noopener">http://ds-overdesign.com/transform/matrix3d.html</a></td>
</tr>
<tr>
<td>CSS-Matrix3d</td>
<td><a href="https://github.com/Zhangdroid/CSS-Matrix3d" target="_blank" rel="noopener">https://github.com/Zhangdroid/CSS-Matrix3d</a></td>
</tr>
<tr>
<td>matrix</td>
<td><a href="http://meyerweb.com/eric/tools/matrix/" target="_blank" rel="noopener">http://meyerweb.com/eric/tools/matrix/</a></td>
</tr>
<tr>
<td>tools</td>
<td><a href="http://www.f2e.name/case/css3/tools.html" target="_blank" rel="noopener">http://www.f2e.name/case/css3/tools.html</a></td>
</tr>
</tbody>
</table>
<h3 id="高逼格"><a href="#高逼格" class="headerlink" title="高逼格"></a>高逼格</h3><ul>
<li>web component CSS: <a href="https://css-doodle.com/" target="_blank" rel="noopener">https://css-doodle.com/</a></li>
</ul>
<h3 id="PostCss-值得收藏的插件"><a href="#PostCss-值得收藏的插件" class="headerlink" title="PostCss 值得收藏的插件"></a>PostCss 值得收藏的插件</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名 </th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时变量</td>
<td>POSTCSS-CUSTOM-PROPERTIES </td>
</tr>
<tr>
<td>与SCSS一致的变量实现</td>
<td>POSTCSS-SIMPLE-VARS  </td>
</tr>
<tr>
<td>实现类似SASS的@MIXIN的功能</td>
<td>POSTCSS-MIXINS </td>
</tr>
<tr>
<td>实现类似SASS的继承功能</td>
<td>POSTCSS-EXTEND   </td>
</tr>
<tr>
<td>实现类似SASS的IMPORT</td>
<td>POSTCSS-IMPORT </td>
</tr>
<tr>
<td>面向未来</td>
<td>CSSNext  </td>
</tr>
<tr>
<td>修复过去（兼容IE，zomm、一像素留白等）</td>
<td>CSS Grace </td>
</tr>
</tbody>
</table>
<h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><ul>
<li>集成化解决方案 lavas</li>
<li>离线状态检测插件 offline.js</li>
</ul>
<hr>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名</th>
<th>周边生态</th>
</tr>
</thead>
<tbody>
<tr>
<td>帮助实现DI的库</td>
<td>Awilix</td>
<td>awilix-koa</td>
</tr>
<tr>
<td>实现控制反转&amp;构造注入的框架</td>
<td>InversifyJS</td>
<td>inversify-koa-utils</td>
</tr>
</tbody>
</table>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><table>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td> 性能测试</td>
<td>Benchmark.js</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="webpack4"><a href="#webpack4" class="headerlink" title="webpack4"></a>webpack4</h2><h3 id="学习帮助"><a href="#学习帮助" class="headerlink" title="学习帮助"></a>学习帮助</h3><ul>
<li>webpack-internal-plugin-relation  可视化的webpack 钩子</li>
</ul>
<h3 id="功能性能类"><a href="#功能性能类" class="headerlink" title="功能性能类"></a>功能性能类</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动插入html及静态文件</td>
<td>HtmlWebpackPlugin【配置自动注入loading（监测资源）】</td>
</tr>
<tr>
<td>抽离css文件</td>
<td>MiniCssExtractPlugin</td>
</tr>
<tr>
<td>清空指定目录</td>
<td>CleanWebpackPlugin</td>
</tr>
<tr>
<td>js 深度 tree sharking 基于ES6模块</td>
<td>webpack-deep-scope-plugin </td>
</tr>
<tr>
<td>css tree sharking</td>
<td>PurifyCSSPlugin</td>
</tr>
<tr>
<td>多核打包件 [需要babel]</td>
<td>uglifyjs-webpack-plugin[官方], happypack</td>
</tr>
<tr>
<td>前端缓存负载【自动生成缓存文件】</td>
<td>Webpack Manifest Plugin</td>
</tr>
<tr>
<td>js 压缩 以及 es压缩 多核压缩</td>
<td>webpack-parallel-uglify-plugin, happypack</td>
</tr>
<tr>
<td>hint css 多核压缩css</td>
<td>css-nano, optimize-css-assets-webpack-plugin </td>
</tr>
<tr>
<td>js 转 ast静态语法分析树</td>
<td>acorn , acorn-walk</td>
</tr>
<tr>
<td>能对html进行hint 以及 fix 的插件</td>
<td>html-minifier, html-minifier-lint</td>
</tr>
<tr>
<td>搬运静态文件</td>
<td>copy-webpack-plugin</td>
<td></td>
</tr>
<tr>
<td>在html 插入静态资源路径</td>
<td>add-asset-html-webpack-plugin</td>
</tr>
</tbody>
</table>
<h3 id="优化体验类"><a href="#优化体验类" class="headerlink" title="优化体验类"></a>优化体验类</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>监测 webpack 打包速度</td>
<td>speed-measure-webpack-plugin</td>
</tr>
<tr>
<td>打包成功通知</td>
<td>webpack-build-notifier</td>
</tr>
<tr>
<td>显示打包进度</td>
<td>progress-bar-webpack-plugin</td>
</tr>
<tr>
<td>信息面板优化</td>
<td>webpack-dashboard[需要配置Pagejson]， webpack-jarvis[网页中浏览]</td>
</tr>
<tr>
<td>修改cmd 标题</td>
<td>node-bash-title[ github ][cmder 无效]</td>
</tr>
</tbody>
</table>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存Loader结果</td>
<td>cache-loader</td>
</tr>
</tbody>
</table>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><ul>
<li>acorn 生成 Ast</li>
<li>acorn-walk 将AST转回代码</li>
<li>estraverse 用于遍历Ast 树</li>
</ul>
<hr>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="颜色提取"><a href="#颜色提取" class="headerlink" title="颜色提取"></a>颜色提取</h3><ul>
<li>RGBaster</li>
</ul>
<hr>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="运行工具"><a href="#运行工具" class="headerlink" title="运行工具"></a>运行工具</h3><table>
<thead>
<tr>
<th>功能</th>
<th>插件名</th>
<th>周边生态</th>
</tr>
</thead>
<tbody>
<tr>
<td>在node中不用编译就运行</td>
<td>ts-node</td>
<td>ts-node-dev 热重启</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><ul>
<li>快速学习vim的网站: <a href="https://vim-adventures.com/" target="_blank" rel="noopener">https://vim-adventures.com/</a></li>
</ul>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="学习帮助-1"><a href="#学习帮助-1" class="headerlink" title="学习帮助"></a>学习帮助</h3><ul>
<li>算法过程可视化: <a href="https://algorithm-visualizer.org/branch-and-bound/binary-search" target="_blank" rel="noopener">https://algorithm-visualizer.org/branch-and-bound/binary-search</a></li>
</ul>
<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><ul>
<li>中文手册: <a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">https://www.kubernetes.org.cn/docs</a></li>
<li>Chart 应用仓库: <a href="https://hub.kubeapps.com/" target="_blank" rel="noopener">https://hub.kubeapps.com/</a></li>
</ul>
<h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><ul>
<li>算法生成图像: <a href="https://blog.csdn.net/zhangpiu/article/details/49511107s" target="_blank" rel="noopener">https://blog.csdn.net/zhangpiu/article/details/49511107s</a></li>
</ul>
<h3 id="canvas-库"><a href="#canvas-库" class="headerlink" title="canvas 库"></a>canvas 库</h3><ul>
<li>提供基础的<code>canvas</code>效果库： <a href="http://spritejs.org/#/" target="_blank" rel="noopener">http://spritejs.org/#/</a></li>
</ul>
<h3 id="物理引擎"><a href="#物理引擎" class="headerlink" title="物理引擎"></a>物理引擎</h3><ul>
<li>cocos2D： <a href="https://cocos2d-x.org/products" target="_blank" rel="noopener">https://cocos2d-x.org/products</a></li>
<li>phaser： <a href="http://phaser.io/" target="_blank" rel="noopener">http://phaser.io/</a></li>
</ul>
<h2 id="Three"><a href="#Three" class="headerlink" title="Three"></a>Three</h2><ul>
<li>stats.min.js 显示动画帧率 </li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="更新算法（文件增量更新）"><a href="#更新算法（文件增量更新）" class="headerlink" title="更新算法（文件增量更新）"></a>更新算法（文件增量更新）</h3><ul>
<li>mt.js (<a href="https://github.com/mtjs/mt" target="_blank" rel="noopener">https://github.com/mtjs/mt</a>)</li>
</ul>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【容器】docker命令手册</title>
    <url>/2019/03/17/%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91docker%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><strong>使用<code>docker</code> 查看所有命令</strong></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FROM</td>
<td style="text-align:center">声明底包来源</td>
<td style="text-align:center">FROM centos</td>
</tr>
<tr>
<td style="text-align:center">RUN</td>
<td style="text-align:center">构建命令–只在构建镜像中使用</td>
<td style="text-align:center">RUN yum install wget -y</td>
</tr>
<tr>
<td style="text-align:center">WORKDIR</td>
<td style="text-align:center">docker中必须用此切换目录</td>
<td style="text-align:center">WORKDIR Python-3.7.0</td>
</tr>
<tr>
<td style="text-align:center">CMD</td>
<td style="text-align:center">运行命令</td>
<td style="text-align:center">CMD python3 -m http.server</td>
</tr>
<tr>
<td style="text-align:center">docker build ‘dockerfile的路径’</td>
<td style="text-align:center">构建新镜像</td>
</tr>
</tbody>
</table>
<h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><blockquote>
<p>在docker client中使用</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">docker ps</td>
<td style="text-align:center">查看进城</td>
<td style="text-align:center">docker ps</td>
</tr>
<tr>
<td style="text-align:center">docker kill ‘id’</td>
<td style="text-align:center">杀死指定容器</td>
<td style="text-align:center">docker kill 123</td>
</tr>
<tr>
<td style="text-align:center">docker rename</td>
<td style="text-align:center">容器改名</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">docker restart</td>
<td style="text-align:center">重启容器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">docker rm</td>
<td style="text-align:center">移除一个或多个’容器’(停止状态的容器)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">docker rmi</td>
<td style="text-align:center">移除一个或多个’镜像’</td>
</tr>
</tbody>
</table>
<h2 id="python项目配置文件分析"><a href="#python项目配置文件分析" class="headerlink" title="python项目配置文件分析"></a>python项目配置文件分析</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前两行固定写法~</span></span><br><span class="line"><span class="comment"># 你的底包来源</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="comment"># 作者(用于上传时使用)</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> nxl &lt;nxl3477@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)</span></span><br><span class="line"><span class="keyword">RUN</span> yum install gcc automake autoconf libtool make -y  </span><br><span class="line"><span class="comment"># python 依赖于 zlib</span></span><br><span class="line"><span class="keyword">RUN</span> yum install zlib zlib-devel libffi-devel -y</span><br><span class="line"><span class="comment"># 安装 wget</span></span><br><span class="line"><span class="keyword">RUN</span> yum install wget -y</span><br><span class="line"><span class="comment"># 下载python安装包</span></span><br><span class="line"><span class="keyword">RUN</span> wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line"><span class="keyword">RUN</span> tar -zxvf Python-3.7.0.tgz</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> Python-3.7.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="keyword">RUN</span> ./configure</span><br><span class="line"><span class="keyword">RUN</span> ls -al</span><br><span class="line"><span class="keyword">RUN</span> make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 运行命令， 唤起python自带的服务器</span></span><br><span class="line"><span class="keyword">CMD</span> python3 -m http.server</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>css分层&命名规范</title>
    <url>/2019/03/16/css%E5%88%86%E5%B1%82-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>为什么要分层? </p>
<ul>
<li>CSS有语义化的命名约定和CSS层的分离， 将有助于它的可扩展性， 性能的提高和代码的组织管理。</li>
<li>避免大量的样式、 覆盖、 权重和很多！important, 分好层可以让团队命名统一规范， 方便维护。</li>
<li>有责任感地去命名你的选择器</li>
</ul>
<p>有哪些分层理论? </p>
<ul>
<li>SMACSS</li>
<li>BEM</li>
<li>SUIT</li>
<li>ACSS</li>
<li>ITCSS</li>
</ul>
<h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>BEM和SMACCS非常类似， 主要用来如何给项目命名。一个简单命名更容易让别人一起工作。 比如选项卡导航是一个块(Block)， 这个块里的元素是其中标签之一（Element）, 而当前选项卡是一个修饰状态( Modifier )</p>
<ul>
<li>block - 代表了更高级别的抽象或组件</li>
<li>block__element - 代表.block的后代， 用于形成一个完整的.block的整体。</li>
<li>block–modifier - 代表.block 的不同状态或不同版本。</li>
<li>修饰符使用的是_, 子模块使用的是__符号。 ( 不同一个-的原因是因为CSS单词连接 )</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- container 是大容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu--item menu--item__active"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu--item"</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"menu--item"</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title>【css-doodle】 css web-component入门</title>
    <url>/2019/03/16/%E3%80%90css-doodle%E3%80%91css-web-component%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>

<p>首先祭出 css-doodle的官网， 真的老厉害了， 使用它能够轻松的实现各种炫酷特效</p>
<blockquote>
<p><a href="https://css-doodle.com/" target="_blank" rel="noopener">https://css-doodle.com/</a></p>
</blockquote>
<p><code>&lt;css-doodle /&gt;</code>基于 Shadow DOM v1和 Custom Elements v1。您可以立即在最新的Chrome，Safari和Firefox上使用它，而无需使用polyfill。<br>该组件将根据其中的规则（纯CSS）生成div网格。您可以使用CSS轻松操作这些单元格，以获得图形模式或动画图形。限制是CSS本身的限制。</p>
<p>既然它这么牛逼， 那怎么用呢？</p>
<p>我们一起来搭几个demo</p>
<h2 id="css-doodle入门"><a href="#css-doodle入门" class="headerlink" title="css-doodle入门"></a>css-doodle入门</h2><blockquote>
<p>此处用到的语法或api有不了解的 请看页面下方的“释义” 区域</p>
</blockquote>
<p>动手过程中需要注意， 不要在<code>css-doodle</code>内部写注释， 会导致样式无效</p>
<p>首先搭建好运行<code>css-doodle</code>的环境<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.5.1/css-doodle.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 页面上加入 css-doodle --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 我们将在这里写代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时如果我们打开页面， 你会发现是空空如也的， 因为这个元素既没有宽高也没有背景颜色， 我们当然看不到。</p>
<p>现在我们给他加点料。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时我们再看看页面， 就出现了一个<code>100 x 100</code>的红色小方块，</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-21-22-36.png" alt="红色方块"></p>
<p>好，这个相当于hello world 级别的练习就完成了， </p>
<p>我们再来点难的：</p>
<p><strong>我想要一个10 x 10 个的小方块组成的大正方形!</strong></p>
<p>正好我们可以借此尝试使用一下它提供的API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;css-doodle&gt;</span><br><span class="line">  :doodle &#123;</span><br><span class="line">    @grid: 10x10 / 500px;</span><br><span class="line">  &#125;</span><br><span class="line">  background: #60569e;</span><br><span class="line">&lt;/css-doodle&gt;</span><br></pre></td></tr></table></figure>
<p>出现了！ 我们要的 10 x 10 个小方块组成的大正方， 并且还把颜色换成了骚骚的紫色</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-21-28-29.png" alt="10x10的大正方"></p>
<p>好既然实现了， 那现在需求升级了</p>
<p><strong>那我要10个长方形怎么办， 并且我还要长短不一的！</strong></p>
<p>我去，还要长短不一， 咋整呢</p>
<p>别慌</p>
<p>机制的你一定可以在官网找到有一个获取当前小方块顺序的的参数<br><code>@index</code> 严格的来说他会返回当前单元格的索引值</p>
<p>既然有方法了那我们也有思路了， 二话不说开始动手。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 首先把 10 x 10 小方块变为10个长方形 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 然后根据 @index 获取当前单元格的索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line">  :doodle &#123;</span><br><span class="line">    @grid: 1x10 / 61.8vmin;</span><br><span class="line">  &#125;</span><br><span class="line">  background: #60569e;</span><br><span class="line">  @size: calc(@index() * 1vmin);</span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据 index 这个索引值乘以高度 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>duang!</p>
<p>这就是我们想要的结果了， 虽然还有点不完美， 其实每个紫色都是一个正方形， 但所在的单元格是长方形没跑了</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-21-45-14.png" alt="10个长方形"></p>
<p>我们再给他加上<code>border-radius: 50%;</code> 它就变成10个球了</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-21-50-12.png" alt="10个球"></p>
<p>此时需求又来了</p>
<p><strong>甲方：可不可以弄10个光环？还是渐变的那种?</strong></p>
<p>行吧， 试试喽谁怕谁</p>
<p>我们可以举一反三， 利用<code>@index</code>这个好东西来修改<code>hsla</code>产生不同的颜色， 当然修改<code>rgba</code> 也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据index 每个的单元格递增20的色调， 再调整出不同的透明度 --&gt;</span><br><span class="line">&lt;css-doodle&gt;</span><br><span class="line">  :doodle &#123;</span><br><span class="line">    @grid: 1x10 / 61.8vmin;</span><br><span class="line">  &#125;</span><br><span class="line">  border-color: hsla(</span><br><span class="line">    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)</span><br><span class="line">  );</span><br><span class="line">  @size: calc(@index() * 10%);</span><br><span class="line">  border-style: dashed;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">&lt;/css-doodle&gt;</span><br></pre></td></tr></table></figure>
<p>好， 甲方爸爸， 你的需求我做到了</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-22-11-38.png" alt="渐变光环"></p>
<p><strong>甲方: 还不够，我要的是同心圆</strong></p>
<p>我。。。。。</p>
<p>得嘞，您说是啥就是啥</p>
<p>同心圆， 你第一反应想到的是不是使用<code>position: absolute;</code> ?<br>不 ，那太low 了<br>我们只需要 <code>@place-cell: center;</code> 这个参数就搞定了， 它会将每个单元格都摆放至中间</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line">  :doodle &#123;</span><br><span class="line">    @grid: 1x10 / 61.8vmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @place-cell: center;</span><br><span class="line">  <span class="comment">&lt;!-- ...省略之前的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后去看一下效果， 卧槽</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-22-20-13.png" alt="我把背景色调成深色方便大家观看"></p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>基础学的差不多了， 其他的一些api有了上面的参照都应该思路了吧</p>
<p>既然是进阶篇， 我们就做点难的， 我们看看能不能利用这些特性和 CSS动画结合一下</p>
<p>我们先让光环变粗一点， 让他呈现扇叶的形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-width: calc(@index() * 10px);</span><br></pre></td></tr></table></figure>
<p>然后让我们用上 <code>keyframes</code> ， 为他添加动画</p>
<p>为每个单元格注册几个css变量（css的新特性），  </p>
<ul>
<li>变量<code>--speed</code>控制动画的持续时间，也就是速度。</li>
<li><code>--start</code> 控制当前光环的起始角度</li>
<li><code>--direction</code>: 控制方向， 因为<code>turn</code>表示一圈， 所以 <code>1turn</code> 就是正的转一圈,<code>-1turn</code> 就是反着转一圈， 利用<code>@pick</code>方法来随机取一个值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ...省略之前的代码 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 动画执行时间在20秒 - 40秒之间取值--&gt;</span></span><br><span class="line">  --speed: @rand(20s, 40s);</span><br><span class="line">  <span class="comment">&lt;!-- 360度里取随机数 --&gt;</span></span><br><span class="line">  --start: @rand(360deg);</span><br><span class="line">  <span class="comment">&lt;!-- 顺时针 或 逆时针 --&gt;</span></span><br><span class="line">  --direction: calc(var(--start) + @pick(1turn, -1turn));</span><br><span class="line"></span><br><span class="line">  animation: demo var(--speed) linear infinite;</span><br><span class="line"></span><br><span class="line">  @keyframes demo &#123;</span><br><span class="line">    form &#123;</span><br><span class="line">      <span class="comment">&lt;!-- 填入起始角度 --&gt;</span></span><br><span class="line">      transform: rotate(var(--start));</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      <span class="comment">&lt;!-- 随机顺时针和逆时针旋转 --&gt;</span></span><br><span class="line">      transform: rotate(var(--direction));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看看效果</p>
<p><img src="http://img.nixiaolei.com/KUXh4tYGe4.gif" alt="随机旋转效果"></p>
<p>炫酷不？</p>
<p>能不能再酷一点？</p>
<p>可以， 我们再给他添一笔， </p>
<p>给他加上一个自定义的贝塞尔</p>
<p>贝塞尔可以去这个网站，根据需要生成</p>
<blockquote>
<p><a href="http://cubic-bezier.com/#1,.25,.83,.67" target="_blank" rel="noopener">http://cubic-bezier.com/#1,.25,.83,.67</a></p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-16-23-11-46.png" alt="贝塞尔"></p>
<p>然后我们你所需要的贝塞尔去更改<code>animation</code> 的参数<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">animation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;</span><br></pre></td></tr></table></figure></p>
<p>根据贝塞尔曲线完成了加速减速的动画效果</p>
<p><img src="http://img.nixiaolei.com/ApPKe0brCf.gif" alt="添加了贝塞尔曲线的动画"></p>
<p>😎cool~</p>
<p>还有更多更酷的特效等着大家去探索~</p>
<p><strong>切记<code>css-doodle</code> 中不能写注释，大家拷贝的时候记得删掉</strong></p>
<h2 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h2><ul>
<li><code>:doodle</code> 选择器会创建一个<code>display: grid;</code> 的布局</li>
<li><code>@grid</code>提供布局， 用法为 <code>@grid: 行 x 列 /  总宽高</code> </li>
<li><code>@index</code> 返回当前单元格的索引</li>
<li><code>hsla</code> 此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度。<ul>
<li>H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360</li>
<li>S：Saturation(饱和度)。取值为：0.0% - 100.0%</li>
<li>L：Lightness(亮度)。取值为：0.0% - 100.0%</li>
<li>A：Alpha透明度。取值0~1之间。</li>
</ul>
</li>
<li><code>@place-cell</code> 调整单元格相对于网格放置。</li>
<li><code>@pick</code>： 从给定列表中随机选择一个值。</li>
<li><code>turn</code>: 转、圈（Turns）。一个圆共1圈 ( 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad )<ul>
<li><code>1turn</code> 就是1圈</li>
</ul>
</li>
</ul>
<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">css-doodle</span>&gt;</span></span><br><span class="line">  :doodle &#123;</span><br><span class="line">    @grid: 1x10 / 61.8vmin;</span><br><span class="line">  &#125;</span><br><span class="line">  @place-cell: center;</span><br><span class="line">  border-color: hsla(</span><br><span class="line">    calc(20 * @index()), 70%, 68%, calc(3 / @index() * 0.8)</span><br><span class="line">  );</span><br><span class="line">  border-width: calc(@index() * 10px);</span><br><span class="line">  @size: calc(@index() * 10%);</span><br><span class="line">  border-style: dashed;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  --speed: @rand(20s, 40s);</span><br><span class="line">  --start: @rand(360deg);</span><br><span class="line">  --direction: calc(var(--start) + @pick(1turn, -1turn));</span><br><span class="line">  animation: demo var(--speed) cubic-bezier(0,.88,.42,.99)  infinite;</span><br><span class="line"></span><br><span class="line">  @keyframes demo &#123;</span><br><span class="line">    form &#123;</span><br><span class="line">      transform: rotate(var(--start));</span><br><span class="line">    &#125;</span><br><span class="line">    to &#123;</span><br><span class="line">      transform: rotate(var(--direction));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">css-doodle</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web-component</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title>利用CSS混合模式更改图片颜色</title>
    <url>/2019/03/16/%E5%88%A9%E7%94%A8CSS%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E6%9B%B4%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>


<p>CSS3 新增了一个很有意思的属性 <code>mix-blend-mode</code> ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。</p>
<p>混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。</p>
<p>开始动手吧 ~</p>
<h2 id="尝试修改图片物体颜色"><a href="#尝试修改图片物体颜色" class="headerlink" title="尝试修改图片物体颜色"></a>尝试修改图片物体颜色</h2><p>首先我们创建一个Input框和一个 Img标签（其实这里我选择的图片不是很好）<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1553336864&amp;di=2f41edc8eedbf09fb1d106545acaed5f&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic44.nipic.com%2F20140723%2F19276212_171901262000_2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们将图片撑满屏幕， 将Input也撑满屏幕， 将input覆盖至图片之上， 然后为input 添加上混合模式<code>mix-blend-mode: hue;</code> </p>
<blockquote>
<p>因为input框自带颜色， 所以当用户切换颜色时也就能不依靠JS 即时生效</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>, <span class="selector-tag">input</span>, <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>&#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">mix-blend-mode</span>: hue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h3><p>原图:<br><img src="http://img.nixiaolei.com/2019-03-16-18-43-09.png" alt="原图"></p>
<p>添加上了混合模式(变灰是因为color选择器默认是黑色):<br><img src="http://img.nixiaolei.com/2019-03-16-18-44-01.png" alt="添加上了混合模式"></p>
<p>切换颜色中:<br><img src="http://img.nixiaolei.com/2019-03-16-18-45-53.png" alt="切换颜色中"></p>
<p>切换后: </p>
<p><img src="http://img.nixiaolei.com/2019-03-16-18-46-30.png" alt="切换后"></p>
<p>虽然有点丑但我们成功了~</p>
<h2 id="更多可能性"><a href="#更多可能性" class="headerlink" title="更多可能性"></a>更多可能性</h2><p>利用整个混合模式的特性， 我们还能做出更多的东西， 比如利用三原色实现彩色loading、 万花筒等等炫酷动画， 可以看看参考文献中的例子， 非常的不错</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://www.cnblogs.com/coco1s/p/6829372.html" target="_blank" rel="noopener">https://www.cnblogs.com/coco1s/p/6829372.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>【容器】Docker入门教程</title>
    <url>/2019/03/16/%E3%80%90%E5%AE%B9%E5%99%A8%E3%80%91Docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 Docker简介</h2><ul>
<li>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</li>
<li>Docker通常用于如下场景：<ul>
<li>web应用的自动化打包和发布；</li>
<li>自动化测试和持续集成、发布；</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
</li>
</ul>
<h2 id="2-1-Docker-vs-VM"><a href="#2-1-Docker-vs-VM" class="headerlink" title="2.1 Docker vs. VM"></a>2.1 Docker vs. VM</h2><ul>
<li>VM：<ul>
<li>运行在宿主机之上的完整的操作系统</li>
<li>运行自身操作系统会占用较多的资源</li>
</ul>
</li>
<li>Docker：<ul>
<li>Docker更加轻量高效</li>
<li>对系统资源的利用率很高</li>
<li>比虚拟机技术更为轻便、快捷</li>
<li>隔离效果不如VM</li>
</ul>
</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-06-22-42-11.png" alt="Docker与VM"></p>
<hr>
<p>总的来说， 虚拟机是在操作系统上又装了一个操作系统，运行操作系统特别消耗资源</p>
<p>而<code>Docker</code>是一种类似于隔离的技术， 由<code>CPU</code> 和<code>Linux</code>内核提供的虚拟化技术， 公用你宿主机上的内核， 在<code>Docker</code>中再装了一层<code>shell</code>, 并且<code>Docker</code>和其他<code>Docker</code>之间是可以通过内核相互进行通信的(<code>Linux</code>进程之间必须经过内核)</p>
<h2 id="3-1-镜像与容器"><a href="#3-1-镜像与容器" class="headerlink" title="3.1 镜像与容器"></a>3.1 镜像与容器</h2><p>image是静态的概念， 比如： 你的<code>exe</code>文件</p>
<p>container是动态的概念， 比如： 你执行<code>exe</code>后的进程</p>
<h2 id="4-1-Docker相关概念"><a href="#4-1-Docker相关概念" class="headerlink" title="4.1 Docker相关概念"></a>4.1 Docker相关概念</h2><ul>
<li>Docker是CS架构，主要有两个概念：</li>
<li>Docker daemon:<ul>
<li>运行在宿主机上</li>
<li>Docker守护进程</li>
<li>用户通过Docker client(Docker命令)与Docker daemon交互</li>
</ul>
</li>
<li>Docker client:<ul>
<li>Docker 命令行工具，是用户使用Docker的主要方式</li>
<li>Docker client与Docker daemon通信并将结果返回给用户</li>
<li>Docker client也可以通过socket或者RESTful api访问远程的</li>
<li>Docker daemon</li>
</ul>
</li>
</ul>
<h2 id="4-2-相关概念详解"><a href="#4-2-相关概念详解" class="headerlink" title="4.2 相关概念详解"></a>4.2 相关概念详解</h2><p><code>Docker</code>最底层是宿主的操作系统内核， </p>
<p>再上层就是底包， 底包就是存放<code>bash</code>以及<code>bash</code>所依赖的基本环境， 每个系统都有不一样的底包， 你可以自己去做底包， 也可以到<a href="https://www.docker.com/products/docker-hub" target="_blank" rel="noopener">dockerHub</a>里找</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-22-56-37.png" alt="Docker结构"></p>
<p>在此之上一层一层的往上累加，比如<code>Node</code>、<code>Mysql</code>啥的, 最后扔到容器里跑, 就像下面这张图， 一层一层的往上叠加，跟码头的集装箱一样</p>
<p><img src="http://img.nixiaolei.com/2019-04-06-23-14-37.png" alt="Docker上层结构"></p>
<h2 id="5-1-Dockerfile-脚本"><a href="#5-1-Dockerfile-脚本" class="headerlink" title="5.1 Dockerfile 脚本"></a>5.1 Dockerfile 脚本</h2><blockquote>
<p>规定了如何创建Image</p>
</blockquote>
<ul>
<li>Dockerfile 概念</li>
<li>Dockerfile 文件格式</li>
<li>构建镜像</li>
<li>镜像标签</li>
<li>修改容器内容</li>
</ul>
<p><img src="http://img.nixiaolei.com/2019-04-07-10-26-12.png" alt="配置文件"></p>
<h2 id="6-1-配置文件分析"><a href="#6-1-配置文件分析" class="headerlink" title="6.1 配置文件分析"></a>6.1 配置文件分析</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前两行固定写法~</span></span><br><span class="line"><span class="comment"># 你的底包来源</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="comment"># 作者(用于上传时使用)</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> nxl &lt;nxl3477@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN构建命令--只在构建镜像中使用    ( -y 表示全部yes)</span></span><br><span class="line"><span class="keyword">RUN</span> yum install gcc automake autoconf libtool make -y  </span><br><span class="line"><span class="comment"># python 依赖于 zlib</span></span><br><span class="line"><span class="keyword">RUN</span> yum install zlib zlib-devel libffi-devel -y</span><br><span class="line"><span class="comment"># 安装 wget</span></span><br><span class="line"><span class="keyword">RUN</span> yum install wget -y</span><br><span class="line"><span class="comment"># 下载python安装包</span></span><br><span class="line"><span class="keyword">RUN</span> wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line"><span class="keyword">RUN</span> tar -zxvf Python-3.7.0.tgz</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> Python-3.7.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line"><span class="keyword">RUN</span> ./configure</span><br><span class="line"><span class="keyword">RUN</span> ls -al</span><br><span class="line"><span class="keyword">RUN</span> make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 运行命令， 唤起python自带的服务器</span></span><br><span class="line"><span class="keyword">CMD</span> python3 -m http.server</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>容器技术</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Js与CSS变量操作</title>
    <url>/2019/03/16/Js%E4%B8%8ECSS%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>



<p>就目前来说CSS变量已经不是什么新鲜的东西了， 渐渐的我们可以在浏览器中尝试使用它， 和SCSS、 LESS 等预处理器不同的是， CSS的变量机制是浏览器天生支持的， 并且浏览器还对其做了优化， 减少了我们使用JS 去操作CSS变量造成的重绘和重排</p>
<p>一起来看看如何操作吧~</p>
<blockquote>
<p>变量虽好， 不可滥用哦</p>
</blockquote>
<h3 id="定义一个简单的变量"><a href="#定义一个简单的变量" class="headerlink" title="定义一个简单的变量"></a>定义一个简单的变量</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义css 变量 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--backgroundColor</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--backgroundColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点我改变背景<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="获取root元素并绑定按钮的点击事件"><a href="#获取root元素并绑定按钮的点击事件" class="headerlink" title="获取root元素并绑定按钮的点击事件"></a>获取root元素并绑定按钮的点击事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> root = <span class="built_in">document</span>.documentElement</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将变量修改为天蓝色</span></span><br><span class="line">  root.style.setProperty(<span class="string">'--backgroundColor'</span>, <span class="string">'skyblue'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p>点击前<br><img src="http://img.nixiaolei.com/2019-03-16-17-52-45.png" alt="按钮点击前"></p>
<p>按钮点击后<br><img src="http://img.nixiaolei.com/2019-03-16-17-53-39.png" alt="按钮点击后"></p>
<p>非常Nice~</p>
<p>利用这个特性实现更多的可能吧！</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS如何了解新知识</title>
    <url>/2019/03/16/CSS%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E6%96%B0%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>

<p>平时闲着无聊的时候多去看看MDN或者一些国外的网站， 多试试一些新特性， 说不定就会有新的发现</p>
<p>并且还可以尝试着参与MDN的文章翻译及国外优质技术文章</p>
<ul>
<li>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference</a> </li>
</ul>
]]></content>
      <categories>
        <category>学习技巧</category>
      </categories>
      <tags>
        <tag>学习技巧</tag>
        <tag>学习渠道</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>【PostCss】使用明天的CSS</title>
    <url>/2019/03/16/%E3%80%90PostCss%E3%80%91%E4%BD%BF%E7%94%A8%E6%98%8E%E5%A4%A9%E7%9A%84CSS/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>


<p>通过PostCss作为CSS的后处理器， 可以根据浏览器的市场份额， 选择性的将一些最新的CSS新特性编译成浏览器支持的语法</p>
<p>当然国内的情况有点不一样</p>
<h2 id="新特性举例"><a href="#新特性举例" class="headerlink" title="新特性举例"></a>新特性举例</h2><p>比如这个CSS变量:<br>他存储了媒体查询的规则， 在多个媒体查询的情况下就不用重复写了<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">custom</span>-<span class="keyword">media</span> --viewport-medium (width &lt;= <span class="number">50rem</span>);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> (--viewport-medium) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="built_in">calc</span>(var(--fontSize) * <span class="number">1.2</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那这个属性浏览器兼容不理想怎么办？ 别担心， 交给PostCss, 经过处理， 我们可以看到，生成了一个规规矩矩的媒体查询代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> (max-width: <span class="number">50rem</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.2rem</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更多演示"><a href="#更多演示" class="headerlink" title="更多演示"></a>更多演示</h2><blockquote>
<p>编译前后以 —— 分割</p>
</blockquote>
<p>自定义选择器<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">custom</span>-<span class="keyword">selector</span> :--heading h1, h2, h3, h4, h5, h6;</span><br><span class="line"><span class="selector-pseudo">:--heading</span> &#123; <span class="attribute">margin-top</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">/* ------------------------------------ */</span></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span> &#123; <span class="attribute">margin-top</span>: <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>自动一倍图(1X)和二倍图(2X)<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* image-set function */</span></span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>:</span><br><span class="line">    <span class="built_in">image-set</span>(</span><br><span class="line">      url(img/test.png) <span class="number">1</span>x,</span><br><span class="line">      <span class="built_in">url</span>(img/test-2x.png) <span class="number">2</span>x</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认状态 */</span></span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">      <span class="built_in">url</span>(img/test.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 满足 设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例  */</span></span><br><span class="line">@<span class="keyword">media</span> (-webkit-min-device-pixel-ratio: <span class="number">2</span>), (min-resolution: <span class="number">192dpi</span>) &#123;</span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>:</span><br><span class="line">      <span class="built_in">url</span>(img/test-2x.png);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>any-link</code>, 补齐标签的剩余的所有状态， 这是为了防止某些样式不生效<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--highlightColor);</span><br><span class="line"><span class="attribute">transition</span>: color <span class="number">1s</span>; <span class="comment">/* autoprefixed ! */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: <span class="built_in">gray</span>(255, 50%) &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: rebeccapurple &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(255 153 0 / 33%); <span class="attribute">outline</span>: <span class="number">3px</span> solid <span class="built_in">hsl</span>(1turn 60% 50%); &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:any-link</span> &#123; <span class="attribute">color</span>: <span class="built_in">color</span>(var(--highlightColor) <span class="built_in">blackness</span>(+20%)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(89, 185, 204);</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: color <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: color <span class="number">1s</span>; <span class="comment">/* autoprefixed ! */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.5) &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: <span class="number">#639</span> &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255, 153, 0, .33); </span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">3px</span> solid <span class="built_in">hsl</span>(360, 60%, 50%); </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: <span class="built_in">rgb</span>(89, 142, 153) &#125;</span><br></pre></td></tr></table></figure></p>
<p>还有很多， 不一一举例了， 比如：</p>
<ul>
<li>各个浏览器的滤镜<code>filter</code>兼容</li>
<li>选择器正则</li>
<li>css嵌套</li>
</ul>
<h2 id="如何让PostCS支持嵌套"><a href="#如何让PostCS支持嵌套" class="headerlink" title="如何让PostCS支持嵌套"></a>如何让PostCS支持嵌套</h2><blockquote>
<p>本环境基于webpack</p>
</blockquote>
<p>npm地址:</p>
<ul>
<li><a href="https://www.npmjs.com/package/postcss" target="_blank" rel="noopener">https://www.npmjs.com/package/postcss</a></li>
<li><a href="https://www.npmjs.com/package/postcss-loader" target="_blank" rel="noopener">https://www.npmjs.com/package/postcss-loader</a></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="comment">/* 一定要带上 &amp; 才会编译 */</span></span><br><span class="line">  &amp; .menu &#123;</span><br><span class="line">    <span class="selector-tag">height</span>: 40<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-tag">sandybrown</span>; </span><br><span class="line">    &amp; <span class="selector-class">.menu--item</span> &#123;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">      <span class="attribute">color</span>: skyblue;</span><br><span class="line">      &amp; .menu--item__active &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-tag">pink</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在项目的根目录中创建一个文件<code>postcss.config.js</code></p>
<p>相关依赖安装就不说了， 真的缺了也会报错提示的</p>
<p>我们将会在里面做<code>PostCSS</code>的相关配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-nested'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后接下来是配置 Loader ，</p>
<p>进入webpack 配置css loader 的地方， 我们在css loader 后面加上PostCss 的loader<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// --------------新增区域---------------</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          ident: <span class="string">'postcss'</span>,</span><br><span class="line">          plugins: <span class="function">(<span class="params">loader</span>) =&gt;</span> [</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)(&#123;</span><br><span class="line">              <span class="comment">/* 这里要改成 0  否则不一定编译嵌套 */</span></span><br><span class="line">              stage: <span class="number">0</span>,</span><br><span class="line">              features: &#123;</span><br><span class="line">                <span class="string">'nesting-rules'</span>: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// --------------新增区域---------------</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>像这样，记得把 <code>stage</code> 这个参数修改为 0 ， 因为PostCss 会根据这个参数分为好几个阶段，阶段太高它是不处理嵌套的。</p>
<p>我们运行一下看看</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="comment">/* 一定要带上 &amp; 才会编译 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: sandybrown</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.menu</span> <span class="selector-class">.menu--item</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">color</span>: skyblue</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.menu</span> <span class="selector-class">.menu--item</span> <span class="selector-class">.menu--item__active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成😄~</p>
<p>想知道有用的PostCSS的插件大纲，可以在本站内搜索: <code>CSS插件</code> </p>
<h2 id="相关的网站"><a href="#相关的网站" class="headerlink" title="相关的网站"></a>相关的网站</h2><blockquote>
<p>PostCss: <a href="https://postcss.org/" target="_blank" rel="noopener">https://postcss.org/</a><br>css next: <a href="http://cssnext.io/" target="_blank" rel="noopener">http://cssnext.io/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jenkins构建前端持续集成</title>
    <url>/2019/03/16/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>


<ol>
<li>安装JDK</li>
</ol>
<p>直接使用yum 安装的是 <code>openjdk</code> , 和sun 公司发布的jdk有略微区别， 但这里我们并不需要使用java,所以使用最快的方式安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y java</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装jenkins</li>
</ol>
<p>添加Jenkins库到yum库，Jenkins将从这里下载安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo</span><br><span class="line">rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br><span class="line">yum install -y jenkins</span><br></pre></td></tr></table></figure>
<p>添加Jenkins库到yum库，Jenkins将从这里下载安装。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpm</span><br><span class="line">rpm -ivh jenkins-2.7.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>配置jenkis的端口</li>
</ol>
<p>jenkins 的默认端口为 8080 ， 为了避免和其他的应用程序冲突， 所以建议修改一下默认占用的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure>
<p>找到修改端口号：</p>
<blockquote>
<p>JENKINS_PORT=”8080” </p>
</blockquote>
<ol start="4">
<li>启动jenkins </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins start/stop/restart</span><br></pre></td></tr></table></figure>
<ul>
<li>安装成功后Jenkins将作为一个守护进程随系统启动</li>
<li>系统会创建一个“jenkins”用户来允许这个服务，如果改变服务所有者，同时需要修改<code>/var/log/jenkins</code>, <code>/var/lib/jenkins</code>, 和<code>/var/cache/jenkins</code>的所有者</li>
<li>启动的时候将从/etc/sysconfig/jenkins获取配置参数</li>
<li>默认情况下，Jenkins运行在8080端口，在浏览器中直接访问该端进行服务配置</li>
<li>Jenkins的RPM仓库配置被加到/etc/yum.repos.d/jenkins.repo</li>
</ul>
<h2 id="配置阶段"><a href="#配置阶段" class="headerlink" title="配置阶段"></a>配置阶段</h2><p>安装好<code>jenkins</code> 后 ， 我们就可以根据刚才所设置的端口号访问 <code>jenkins</code> 服务了 </p>
<p>比如进入 <code>127.0.0.1:8081</code> 访问<code>jenkins</code></p>
<p>首先会看到让我们输入初始密码</p>
<p>它提示我们进入 <code>/var/lib/jenkins/secrets/initialAdminPassword</code> 查看</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-16-27.png" alt="输入初始密码"></p>
<p>输入密码无误后， 就是提示我们安装对应的插件了，</p>
<p>左边是推荐安装， 右边是自定义安装，  这里我们建议点击 <code>推荐安装</code></p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-17-31.png" alt="选择推荐安装"></p>
<p>安装过程可能稍长</p>
<p><img src="http://img.nixiaolei.com/jenkins03.png" alt="等待安装完毕 "></p>
<p>这时我们创建一个 <code>Jenkins</code> 账户，<br>一定要牢记你的输入账号和密码， 用作之后的登录</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-29-08.png" alt="创建账户"></p>
<p>创建账户之后， 会显示一个 <code>jenkins</code> 的资源根路径， 一般不需要修改， 保持默认即可</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-32-04.png" alt="资源路径"></p>
<p>之后就是愉快的<code>jenkins</code> 之旅啦</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-32-37.png" alt="开始使用Jenkins"></p>
<h2 id="补善插件阶段"><a href="#补善插件阶段" class="headerlink" title="补善插件阶段"></a>补善插件阶段</h2><p>我们要做的前端持续集成， 所以 <code>jenkins</code> 默认安装的插件 并不能完全的满足我们的需求</p>
<p>进入<code>jenkins</code> 主页面后， 找到插件管理</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-16-36-26.png" alt="插件管理"></p>
<p>首先查看我们必要的插件是否安装好了</p>
<ul>
<li>NodeJs Plugin</li>
<li>Publish Over SSH</li>
<li>GitHub</li>
</ul>
<p>如果发现没有安装的就安装， 查漏补缺</p>
<h2 id="变量及远程服务器基本配置"><a href="#变量及远程服务器基本配置" class="headerlink" title="变量及远程服务器基本配置"></a>变量及远程服务器基本配置</h2><p>插件安装好后, 进入<code>系统设置</code> 界面, 进行变量的相关配置, 这里就展示几个可以修改的参数, 大部分都可以不用动, 使用默认就好</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-36-54.png" alt="系统设置"></p>
<p>管理员邮件地址, 推荐填写,  当jenkins 工作完成后会把 构建信息发送至此邮箱</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-42-24.png" alt="邮件地址"></p>
<p>(这条选择填写) 可以选择配置 github 服务器, 并且可以配置多个, 因为你的项目代码有可能在多个服务器上</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-43-51.png" alt="github"></p>
<p>比较重要的就是这里了 ,  配置远程服务器, 也就是你的发布地址</p>
<p>点击新增添加你的服务器</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-48-05.png" alt="添加你的服务器"></p>
<p>点击新增后, 这里有几个关键的参数,  需要注意</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-51-39.png" alt="参数注意"></p>
<p>连接目标服务器肯定需要登录,  下面几个参数就是对应的验证参数, 你可以输入固定的密码, 也可以告诉Jenkins 你的本地私钥路径或私钥的内容,  前提是你配置了 ssh 的免密登录</p>
<p><img src="http://img.nixiaolei.com/2019-03-09-17-54-49.png" alt="配置免密"></p>
<blockquote>
<p>填写密钥路径这里你很有可能会出现权限不够的错误， 如下图，</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-10-10-43-33.png" alt="编路径错误"></p>
<p>因为<code>jenkins</code>的在运行时会自动的创建一个名为<code>jenkins</code>的用户， 而这个用户的权限不够，无法访问你的目录</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-10-46-12.png" alt="编运行身份"></p>
<p>解决方案有两个:</p>
<ol>
<li>把密钥切换至一个普通用户可以访问的目录， 并修改密钥的所属用户身份和访问权限</li>
<li>把<code>jenkins</code> 的运行身份修改为 <code>root</code>, 但是会有点安全性问题</li>
</ol>
<p>本次实践以学习为目的， 所以这里我选择了第二钟</p>
<blockquote>
<p>相关操作文章: <a href="https://blog.csdn.net/jeikerxiao/article/details/80768949" target="_blank" rel="noopener">https://blog.csdn.net/jeikerxiao/article/details/80768949</a></p>
</blockquote>
<p>ssh 免密配置成功后， 我们就可以开始创建一个自己的任务了</p>
<h2 id="创建任务阶段"><a href="#创建任务阶段" class="headerlink" title="创建任务阶段"></a>创建任务阶段</h2><p>回到主页， 找到<code>新建任务</code></p>
<p><img src="http://img.nixiaolei.com/2019-03-10-10-55-02.png" alt="编新建任务"></p>
<p>进入新建任务后， 有几种不同的项目， 我们这里选择 <code>自由风格</code>， 并且输入项目名称</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-10-59-00.png" alt="编自由风格"></p>
<p>创建好项目后就会自动进入 当前项目的配置文件中</p>
<p>首先我们看到<code>General</code>, 这是一些全局的配置， 在这里我们可以写上该项目的描述</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-11-02-26.png" alt="编全局配置"></p>
<p><code>General</code>的后面几个类目是构建项目阶段几个比较大的步骤和流程</p>
<p>如果你要配置的“github”项目， 可以在<code>Git</code>这里打上勾</p>
<p>并且填写上仓库地址 及 分支 即可， 如果需要填写账户密码， 则可在<code>Credentials</code> 处新增配置</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-11-11-35.png" alt="编github项目"></p>
<p>接下来是看看构建触发器， 这里的填写根据你的工程需要， </p>
<p>可以配置定时任务 或 多任务构建</p>
<blockquote>
<p>本次演示我并没有用到</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-10-13-26-16.png" alt="编触发器"></p>
<p>现在来到我们的重点<code>构建</code> ， </p>
<p>我们可以添加步骤，我们可以看到能够支持 <code>Node</code>、<code>shell</code> 、<code>批处理</code>等等方式</p>
<p>这些添加的步骤会按顺序执行， </p>
<p><img src="http://img.nixiaolei.com/2019-03-10-13-30-56.png" alt="编构建"></p>
<p>我们需要<code>shell</code> 脚本来运行npm 命令</p>
<p>所以我创建了 <code>shell</code>的操作步骤</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-13-35-35.png" alt="编shell脚本"></p>
<p>基于此， <code>jenkins</code> 就会自动帮我们做好 测试与打包的步骤，</p>
<p>在此之后， 我们需要将测试通过的项目代码推送到远程发布服务器上， 所以， 我们添加一个<code>send files or execute commands over SSH</code> 步骤， </p>
<p><img src="http://img.nixiaolei.com/2019-03-16-13-05-58.png" alt="编overSSH"></p>
<p>建议新旧文件搞两个文件夹存放， 这样可以先删除掉旧文件再把新文件拷贝过去</p>
<blockquote>
<p>deploy文件参考</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-16-13-08-32.png" alt="编deploy文件参考"></p>
<h2 id="你可能遇到的问题"><a href="#你可能遇到的问题" class="headerlink" title="你可能遇到的问题"></a>你可能遇到的问题</h2><h3 id="命令无效或不存在"><a href="#命令无效或不存在" class="headerlink" title="命令无效或不存在"></a>命令无效或不存在</h3><blockquote>
<p>这里拿npm举例，  其他命令如:node ,都是同理</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-16-12-54-06.png" alt="编无法使用npm命令"></p>
<p>因为全局的命令需要设置<code>软连接</code> Jenkins 才可以访问的到</p>
<p>如何设置:</p>
<p>先查看一下你的 npm 在哪</p>
<blockquote>
<p>whereis npm</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-16-12-57-08.png" alt="编查看npm位置"></p>
<p>这个<code>/usr/local/bin/npm</code> 就是你的npm所在位置 ( 使用带 <code>local</code> 的地址)</p>
<p>我们来创建 <code>软连接</code>, 这里使用刚刚获取到的npm </p>
<blockquote>
<p>ln -s /usr/local/bin/npm   /usr/bin</p>
</blockquote>
<p>如果出现无法修改的情况， 那我们就将他强制更改 😄</p>
<blockquote>
<p>ln -sf /usr/local/bin/npm   /usr/bin</p>
</blockquote>
<p>再去构建一次Jenkins 任务</p>
<p>看到控制台输出， 现在npm 可以正常运行了</p>
<p><img src="http://img.nixiaolei.com/2019-03-10-18-56-51.png" alt="编npm运行成功"></p>
<h2 id="持续集成的必要条件"><a href="#持续集成的必要条件" class="headerlink" title="持续集成的必要条件"></a>持续集成的必要条件</h2><ol>
<li>必须有github 、svn或私有git服务器</li>
<li>完整的项目<ol>
<li>test</li>
<li>接口测试</li>
<li>其他的测试内容</li>
</ol>
</li>
<li>CI 平台</li>
<li>项目代码要提交到Github、 svn等服务器上</li>
<li>保证代码在开发机的正常<ol>
<li>bug</li>
<li>运行环境 ( 引用的包要写入packa)</li>
</ol>
</li>
<li>保证jenkins 环境一切正常</li>
<li>发布服务器上也要存在基础的运行环境(不包括项目本身引用的包)</li>
<li>必要的静态资源服务器</li>
<li>配置jenkins的自动化处理流程</li>
</ol>
<p>参考文章:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/loveyouyou616/p/8714544.html" target="_blank" rel="noopener">https://www.cnblogs.com/loveyouyou616/p/8714544.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>前端持续集成</tag>
        <tag>Jenkins</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>css预处理与后处理器</title>
    <url>/2019/03/16/css%E9%A2%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>

<p>预处理器在前两年是非常流行的技术， 但是这两年发展的却不怎么有起色， 因为人们渐渐发先即使代码经过了预处理的的编译， 还要经过后处理， 并且PostCss 的崛起拥有了预处理器的功能， 可以完美代替预处理的工作， 并且可以做到让人们使用下一个版本的css</p>
<p>一旦预处理器阶段代码出现污染，预处理器的事就算是白干了， 不如直接交给后处理器，  所以使用预处理器的意义越来越小了</p>
<h2 id="预处理器具有的能力"><a href="#预处理器具有的能力" class="headerlink" title="预处理器具有的能力"></a>预处理器具有的能力</h2><ul>
<li>变量</li>
<li>混合(Mixin) Extend</li>
<li>嵌套规则</li>
<li>运算</li>
<li>函数</li>
<li>Namespaces &amp; Accessors (命名空间和访问器)</li>
<li>scope</li>
<li>注释</li>
</ul>
<h2 id="后处理器的能力"><a href="#后处理器的能力" class="headerlink" title="后处理器的能力"></a>后处理器的能力</h2><ul>
<li>CSS 压缩 CLEAN-CSS</li>
<li>自动添加浏览器前缀 Autoprefixer</li>
<li>CSS更加美观排序 CSScomb</li>
<li>Rework取代stylus 后处理器发热</li>
<li>前后通吃的 PostCss</li>
</ul>
<h2 id="他们是如何处理的CSS"><a href="#他们是如何处理的CSS" class="headerlink" title="他们是如何处理的CSS"></a>他们是如何处理的CSS</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器， 如： <code>sass</code> 它会先将他的语法转换成 AST–抽象语法树（Abstract Syntax Tree ）, AST是程序的一种中间表示形式， 然后遍历 AST 这棵树， 将对应想要的结果生成为CSS </p>
<h3 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h3><p>PostCss 改变了之前对CSS的处理流程， 它提供了一套插件的机制， 对于PostCss来说，自己是一套空的工程，它为插件提供了CSS数据， 根据配置的不同插件， 产生不同的功能</p>
<p><img src="http://img.nixiaolei.com/2019-03-16-13-23-52.png" alt="PostCss处理流程"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>PostCss</tag>
      </tags>
  </entry>
  <entry>
    <title>手摸手AngularJs入门教程</title>
    <url>/2019/03/16/%E6%89%8B%E6%91%B8%E6%89%8BAngularJs%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>

<p>AngularJs 是一款来自Google 的前端JavaScript框架， 也是SPA框架。 AngularJs框架的体积非常小， 但是设计理念和功能却非常强大， 极大地简化前端开发的负担， 它快速成为了JavaScript的主流框架， 帮助开发者从事web开发。</p>
<p>这里我们用AngularJs7的练手吧</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote>
<p>请确保电脑已安装了<code>Node.js</code></p>
</blockquote>
<p>首先是全局安装脚手架<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure></p>
<p>安装好后查看一下版本</p>
<blockquote>
<p>ng –version</p>
</blockquote>
<p><img src="http://img.nixiaolei.com/2019-03-17-15-54-41.png" alt="查看版本"></p>
<p>确认<code>ng</code>命令存在后就可以开始创建我们的第一个 Angular 项目了<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 创建项目  project 替换为你的项目名称</span><br><span class="line">ng new project</span><br></pre></td></tr></table></figure></p>
<p>当你输入命令后他会问你需要的配置，  </p>
<p>这里附上我的选择， 大家可以参照</p>
<ol>
<li>你是否需要添加路由？ —- yes</li>
<li>选择你喜欢的css 风格 —- SCSS</li>
</ol>
<p><img src="http://img.nixiaolei.com/2019-03-17-15-36-01.png" alt="选择配置"></p>
<p>选择好后， 就会进入漫长的安装了<br><img src="http://img.nixiaolei.com/2019-03-17-15-39-53.png" alt="安装中"></p>
<p>安装好后， cd 进入到项目所在的目录， 运行 <code>ng serve</code> 命令， 并打开<code>http://localhost:4200/</code> 查看我们第一个 <code>Angular</code>项目<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 进入你的项目目录</span><br><span class="line">cd project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动项目</span><br><span class="line">ng serve</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果你需要 可以生产环境运行</span><br><span class="line">ng serve --prod --aot</span><br></pre></td></tr></table></figure></p>
<h2 id="基本的路由配置"><a href="#基本的路由配置" class="headerlink" title="基本的路由配置"></a>基本的路由配置</h2><blockquote>
<p>如果你不知道路由是什么， 你只需要先理解路由帮助我们实现切换页面的功能<br>因为之前我们在构建项目时就选择了加入<code>路由</code>， 因此也省去了很多配置过程， </p>
</blockquote>
<p>现在，我们来看看怎么用吧， </p>
<p>首先想使用路由， 得需要再创建一个”页面”（这里指组件）， 这样才能通过切换看出是否实现了路由， </p>
<p><strong>那如何创建一个组件呢？</strong></p>
<p>Angular 给我们提供了非常多的创建命令， 组件也可以一键的生成</p>
<p>我们来创建一个 <code>Demo</code> 组件</p>
<blockquote>
<p>ng g c Demo</p>
</blockquote>
<p>等待片刻， 安装好后</p>
<p>我们发现项目文件中的 <code>app</code> 目录下多了一个文件夹<br><img src="http://img.nixiaolei.com/2019-03-17-17-01-55.png" alt="Demo组件创建"></p>
<p>里面有配套的</p>
<ul>
<li>模板文件</li>
<li>样式文件</li>
<li>测试文件</li>
<li>ts 脚本文件</li>
</ul>
<p>既然有了组件， 那我们现在需要为这个路由分配相应的访问路径</p>
<p>进入 <code>app/app-routing.module.ts</code> 这个文件</p>
<p>我们首先导入刚刚创建的<code>Demo</code>组件， 再 <code>routes</code>数组中，分配一个用于访问的<code>path</code>, 并和导入的<code>DemoComponent</code>关联上</p>
<p>如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------新增区域------------</span></span><br><span class="line"><span class="keyword">import</span> &#123; DemoComponent &#125; <span class="keyword">from</span> <span class="string">'./demo/demo.component'</span>;</span><br><span class="line"><span class="comment">// ------------新增区域------------</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  <span class="comment">// -----------新增区域-------------</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"demo"</span>,</span><br><span class="line">    component: DemoComponent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ------------新增区域------------</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后进入 <code>app/app.component.html</code> 文件中找到 <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></p>
<p>刚才配置的路由就会显示在这个标签所在的位置，<br>为了减少一点干扰，我们把没有用的信息删除</p>
<p>!component19html<br>切换后](<a href="http://img.nixiaolei.com/2019-03--17-17-27-25.png" target="_blank" rel="noopener">http://img.nixiaolei.com/2019-03--17-17-27-25.png</a> app.我只留了一张图片,</p>
<p>然后我们进入 <code>app/demo/demo.component.html</code> 文件中</p>
<p>原本是<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  demo works!</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们改成明显一点的内容</p>
<blockquote>
<p>千万注意dom结构别错了， dom结构错误会造成白屏，坑的是没有错误信息</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是Demo 页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看看是否配置成功了</p>
<p>首先，刚进入， 只有一张图片</p>
<p><img src="http://img.nixiaolei.com/2019-03-17-17-34-37.png" alt="根路由"></p>
<p>让我们切换至<code>/demo</code></p>
<p>我们可以看到， 刚刚为demo组件编写的文字成功显示出来了， 并且是位于图片下方， 这跟我们之前 <code>app/app.component.html</code> 中所做的配置一样</p>
<p><img src="http://img.nixiaolei.com/2019-03-17-17-35-14.png" alt="切换至demo"></p>
<p>——————–待完善————————-</p>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><blockquote>
<p>把 XXX 替换成你要的名字</p>
</blockquote>
<ul>
<li>ng g cl xxx // 创建一个新类</li>
<li>ng g c xxx // 创建一个新组件</li>
<li>ng g d xxx // 创建一个新指令</li>
<li>ng g e xxx // 创建一个新枚举</li>
<li>ng g m xxx // 创建一个新模块</li>
<li>ng g p xxx // 创建一个新管道</li>
<li>ng g s xxx // 创建一个新的指服务</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p><a href="https://github.com/angular/angular-cli/wiki" target="_blank" rel="noopener">https://github.com/angular/angular-cli/wiki</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中如何使用本地图片</title>
    <url>/2019/03/16/hexo%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<script type="text/javascript" src="/js/src/bai.js"></script>


<p>首先需要修改<code>_config.yml</code>配置文件<code>post_asset_folder</code>项为<code>true</code></p>
<p>使用命令创建博客<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new 你的文章名称</span><br></pre></td></tr></table></figure></p>
<p>他会生成<code>.md</code>文件及一个对应的文件夹， 我们将图片放到该文件夹中</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>在文章中这样插入图片<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如下:</p>
<p><img src="http://img.nixiaolei.com/pika.png" alt="皮卡皮卡"></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote>
<p>这个方法在首页无法正常预览图片</p>
</blockquote>
<p>安装一下这个插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>在文章中这样插入图片<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这是一张图片](xxxx.png)</span><br></pre></td></tr></table></figure></p>
<p>效果如下:</p>
<p><img src="http://img.nixiaolei.com/pika.png" alt="皮卡皮卡"></p>
<p>参考文献</p>
<blockquote>
<p><a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/" target="_blank" rel="noopener">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
